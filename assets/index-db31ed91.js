var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var require_index_001 = __commonJS({
  "assets/index-db31ed91.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity)
          fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy)
          fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    const app = "";
    function noop$5() {
    }
    function run$3(fn) {
      return fn();
    }
    function blank_object() {
      return /* @__PURE__ */ Object.create(null);
    }
    function run_all(fns) {
      fns.forEach(run$3);
    }
    function is_function(thing) {
      return typeof thing === "function";
    }
    function safe_not_equal(a2, b) {
      return a2 != a2 ? b == b : a2 !== b || a2 && typeof a2 === "object" || typeof a2 === "function";
    }
    function is_empty(obj) {
      return Object.keys(obj).length === 0;
    }
    function append$2(target, node2) {
      target.appendChild(node2);
    }
    function insert(target, node2, anchor) {
      target.insertBefore(node2, anchor || null);
    }
    function detach(node2) {
      if (node2.parentNode) {
        node2.parentNode.removeChild(node2);
      }
    }
    function element(name) {
      return document.createElement(name);
    }
    function text$1(data2) {
      return document.createTextNode(data2);
    }
    function space() {
      return text$1(" ");
    }
    function attr(node2, attribute, value) {
      if (value == null)
        node2.removeAttribute(attribute);
      else if (node2.getAttribute(attribute) !== value)
        node2.setAttribute(attribute, value);
    }
    function children$1(element2) {
      return Array.from(element2.childNodes);
    }
    let current_component;
    function set_current_component(component) {
      current_component = component;
    }
    function get_current_component() {
      if (!current_component)
        throw new Error("Function called outside component initialization");
      return current_component;
    }
    function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
    }
    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */ Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush$3);
      }
    }
    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }
    const seen_callbacks = /* @__PURE__ */ new Set();
    let flushidx = 0;
    function flush$3() {
      if (flushidx !== 0) {
        return;
      }
      const saved_component = current_component;
      do {
        try {
          while (flushidx < dirty_components.length) {
            const component = dirty_components[flushidx];
            flushidx++;
            set_current_component(component);
            update(component.$$);
          }
        } catch (e) {
          dirty_components.length = 0;
          flushidx = 0;
          throw e;
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
          binding_callbacks.pop()();
        for (let i = 0; i < render_callbacks.length; i += 1) {
          const callback = render_callbacks[i];
          if (!seen_callbacks.has(callback)) {
            seen_callbacks.add(callback);
            callback();
          }
        }
        render_callbacks.length = 0;
      } while (dirty_components.length);
      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }
      update_scheduled = false;
      seen_callbacks.clear();
      set_current_component(saved_component);
    }
    function update($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
      }
    }
    function flush_render_callbacks(fns) {
      const filtered = [];
      const targets = [];
      render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
      targets.forEach((c2) => c2());
      render_callbacks = filtered;
    }
    const outroing = /* @__PURE__ */ new Set();
    let outros;
    function transition_in(block, local) {
      if (block && block.i) {
        outroing.delete(block);
        block.i(local);
      }
    }
    function transition_out(block, local, detach2, callback) {
      if (block && block.o) {
        if (outroing.has(block))
          return;
        outroing.add(block);
        outros.c.push(() => {
          outroing.delete(block);
          if (callback) {
            if (detach2)
              block.d(1);
            callback();
          }
        });
        block.o(local);
      } else if (callback) {
        callback();
      }
    }
    function create_component(block) {
      block && block.c();
    }
    function mount_component(component, target, anchor) {
      const { fragment, after_update } = component.$$;
      fragment && fragment.m(target, anchor);
      add_render_callback(() => {
        const new_on_destroy = component.$$.on_mount.map(run$3).filter(is_function);
        if (component.$$.on_destroy) {
          component.$$.on_destroy.push(...new_on_destroy);
        } else {
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
      after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
        flush_render_callbacks($$.after_update);
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }
    function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }
      component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
    }
    function init$2(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop$5,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
      };
      append_styles && append_styles($$.root);
      let ready = false;
      $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
          if (!$$.skip_bound && $$.bound[i])
            $$.bound[i](value);
          if (ready)
            make_dirty(component, i);
        }
        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all($$.before_update);
      $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
      if (options.target) {
        if (options.hydrate) {
          const nodes = children$1(options.target);
          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach);
        } else {
          $$.fragment && $$.fragment.c();
        }
        if (options.intro)
          transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush$3();
      }
      set_current_component(parent_component);
    }
    class SvelteComponent {
      constructor() {
        /**
         * ### PRIVATE API
         *
         * Do not use, may change at any time
         *
         * @type {any}
         */
        __publicField(this, "$$");
        /**
         * ### PRIVATE API
         *
         * Do not use, may change at any time
         *
         * @type {any}
         */
        __publicField(this, "$$set");
      }
      /** @returns {void} */
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop$5;
      }
      /**
       * @template {Extract<keyof Events, string>} K
       * @param {K} type
       * @param {((e: Events[K]) => void) | null | undefined} callback
       * @returns {() => void}
       */
      $on(type, callback) {
        if (!is_function(callback)) {
          return noop$5;
        }
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1)
            callbacks.splice(index, 1);
        };
      }
      /**
       * @param {Partial<Props>} props
       * @returns {void}
       */
      $set(props) {
        if (this.$$set && !is_empty(props)) {
          this.$$.skip_bound = true;
          this.$$set(props);
          this.$$.skip_bound = false;
        }
      }
    }
    const PUBLIC_VERSION = "4";
    if (typeof window !== "undefined")
      (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
    var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + '] || ""';
      }).join(",") + "}");
    }
    function customConverter(columns, f) {
      var object2 = objectConverter(columns);
      return function(row, i) {
        return f(object2(row), i, columns);
      };
    }
    function inferColumns(rows) {
      var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });
      return columns;
    }
    function pad$2(value, width) {
      var s2 = value + "", length2 = s2.length;
      return length2 < width ? new Array(width - length2 + 1).join(0) + s2 : s2;
    }
    function formatYear$2(year) {
      return year < 0 ? "-" + pad$2(-year, 6) : year > 9999 ? "+" + pad$2(year, 6) : pad$2(year, 4);
    }
    function formatDate(date2) {
      var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds = date2.getUTCSeconds(), milliseconds = date2.getUTCMilliseconds();
      return isNaN(date2) ? "Invalid Date" : formatYear$2(date2.getUTCFullYear()) + "-" + pad$2(date2.getUTCMonth() + 1, 2) + "-" + pad$2(date2.getUTCDate(), 2) + (milliseconds ? "T" + pad$2(hours, 2) + ":" + pad$2(minutes, 2) + ":" + pad$2(seconds, 2) + "." + pad$2(milliseconds, 3) + "Z" : seconds ? "T" + pad$2(hours, 2) + ":" + pad$2(minutes, 2) + ":" + pad$2(seconds, 2) + "Z" : minutes || hours ? "T" + pad$2(hours, 2) + ":" + pad$2(minutes, 2) + "Z" : "");
    }
    function dsvFormat(delimiter) {
      var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
      function parse2(text2, f) {
        var convert, columns, rows = parseRows(text2, function(row, i) {
          if (convert)
            return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }
      function parseRows(text2, f) {
        var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
        if (text2.charCodeAt(N - 1) === NEWLINE)
          --N;
        if (text2.charCodeAt(N - 1) === RETURN)
          --N;
        function token() {
          if (eof)
            return EOF;
          if (eol)
            return eol = false, EOL;
          var i, j = I, c2;
          if (text2.charCodeAt(j) === QUOTE) {
            while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)
              ;
            if ((i = I) >= N)
              eof = true;
            else if ((c2 = text2.charCodeAt(I++)) === NEWLINE)
              eol = true;
            else if (c2 === RETURN) {
              eol = true;
              if (text2.charCodeAt(I) === NEWLINE)
                ++I;
            }
            return text2.slice(j + 1, i - 1).replace(/""/g, '"');
          }
          while (I < N) {
            if ((c2 = text2.charCodeAt(i = I++)) === NEWLINE)
              eol = true;
            else if (c2 === RETURN) {
              eol = true;
              if (text2.charCodeAt(I) === NEWLINE)
                ++I;
            } else if (c2 !== DELIMITER)
              continue;
            return text2.slice(j, i);
          }
          return eof = true, text2.slice(j, N);
        }
        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF)
            row.push(t), t = token();
          if (f && (row = f(row, n++)) == null)
            continue;
          rows.push(row);
        }
        return rows;
      }
      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }
      function format2(rows, columns) {
        if (columns == null)
          columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }
      function formatBody(rows, columns) {
        if (columns == null)
          columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }
      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }
      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }
      function formatValue(value) {
        return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
      }
      return {
        parse: parse2,
        parseRows,
        format: format2,
        formatBody,
        formatRows,
        formatRow,
        formatValue
      };
    }
    var csv$1 = dsvFormat(",");
    var csvParse = csv$1.parse;
    function ascending$1(a2, b) {
      return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
    }
    function descending(a2, b) {
      return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
    }
    function bisector(f) {
      let compare1, compare2, delta;
      if (f.length !== 2) {
        compare1 = ascending$1;
        compare2 = (d, x) => ascending$1(f(d), x);
        delta = (d, x) => f(d) - x;
      } else {
        compare1 = f === ascending$1 || f === descending ? f : zero$1;
        compare2 = f;
        delta = f;
      }
      function left2(a2, x, lo = 0, hi = a2.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0)
            return hi;
          do {
            const mid = lo + hi >>> 1;
            if (compare2(a2[mid], x) < 0)
              lo = mid + 1;
            else
              hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      function right2(a2, x, lo = 0, hi = a2.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0)
            return hi;
          do {
            const mid = lo + hi >>> 1;
            if (compare2(a2[mid], x) <= 0)
              lo = mid + 1;
            else
              hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      function center2(a2, x, lo = 0, hi = a2.length) {
        const i = left2(a2, x, lo, hi - 1);
        return i > lo && delta(a2[i - 1], x) > -delta(a2[i], x) ? i - 1 : i;
      }
      return { left: left2, center: center2, right: right2 };
    }
    function zero$1() {
      return 0;
    }
    function number$3(x) {
      return x === null ? NaN : +x;
    }
    function* numbers(values2, valueof) {
      if (valueof === void 0) {
        for (let value of values2) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      } else {
        let index = -1;
        for (let value of values2) {
          if ((value = valueof(value, ++index, values2)) != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }
    const ascendingBisect = bisector(ascending$1);
    const bisectRight = ascendingBisect.right;
    bisector(number$3).center;
    const bisect = bisectRight;
    function extent(values2, valueof) {
      let min2;
      let max2;
      if (valueof === void 0) {
        for (const value of values2) {
          if (value != null) {
            if (min2 === void 0) {
              if (value >= value)
                min2 = max2 = value;
            } else {
              if (min2 > value)
                min2 = value;
              if (max2 < value)
                max2 = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values2) {
          if ((value = valueof(value, ++index, values2)) != null) {
            if (min2 === void 0) {
              if (value >= value)
                min2 = max2 = value;
            } else {
              if (min2 > value)
                min2 = value;
              if (max2 < value)
                max2 = value;
            }
          }
        }
      }
      return [min2, max2];
    }
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j], hi = x + y, lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo)
            p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo)
              break;
          }
          if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi)
              hi = x;
          }
        }
        return hi;
      }
    }
    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
        if (entries != null)
          for (const [key2, value] of entries)
            this.set(key2, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }
    class InternSet extends Set {
      constructor(values2, key = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
        if (values2 != null)
          for (const value of values2)
            this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }
    function intern_get({ _intern, _key }, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }
    function intern_set({ _intern, _key }, value) {
      const key = _key(value);
      if (_intern.has(key))
        return _intern.get(key);
      _intern.set(key, value);
      return value;
    }
    function intern_delete({ _intern, _key }, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(key);
        _intern.delete(key);
      }
      return value;
    }
    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }
    function permute(source, keys2) {
      return Array.from(keys2, (key) => source[key]);
    }
    function sort(values2, ...F) {
      if (typeof values2[Symbol.iterator] !== "function")
        throw new TypeError("values is not iterable");
      values2 = Array.from(values2);
      let [f] = F;
      if (f && f.length !== 2 || F.length > 1) {
        const index = Uint32Array.from(values2, (d, i) => i);
        if (F.length > 1) {
          F = F.map((f2) => values2.map(f2));
          index.sort((i, j) => {
            for (const f2 of F) {
              const c2 = ascendingDefined$2(f2[i], f2[j]);
              if (c2)
                return c2;
            }
          });
        } else {
          f = values2.map(f);
          index.sort((i, j) => ascendingDefined$2(f[i], f[j]));
        }
        return permute(values2, index);
      }
      return values2.sort(compareDefined(f));
    }
    function compareDefined(compare = ascending$1) {
      if (compare === ascending$1)
        return ascendingDefined$2;
      if (typeof compare !== "function")
        throw new TypeError("compare is not a function");
      return (a2, b) => {
        const x = compare(a2, b);
        if (x || x === 0)
          return x;
        return (compare(b, b) === 0) - (compare(a2, a2) === 0);
      };
    }
    function ascendingDefined$2(a2, b) {
      return (a2 == null || !(a2 >= a2)) - (b == null || !(b >= b)) || (a2 < b ? -1 : a2 > b ? 1 : 0);
    }
    const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
    function tickSpec(start2, stop, count) {
      const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
      let i1, i2, inc;
      if (power < 0) {
        inc = Math.pow(10, -power) / factor;
        i1 = Math.round(start2 * inc);
        i2 = Math.round(stop * inc);
        if (i1 / inc < start2)
          ++i1;
        if (i2 / inc > stop)
          --i2;
        inc = -inc;
      } else {
        inc = Math.pow(10, power) * factor;
        i1 = Math.round(start2 / inc);
        i2 = Math.round(stop / inc);
        if (i1 * inc < start2)
          ++i1;
        if (i2 * inc > stop)
          --i2;
      }
      if (i2 < i1 && 0.5 <= count && count < 2)
        return tickSpec(start2, stop, count * 2);
      return [i1, i2, inc];
    }
    function ticks(start2, stop, count) {
      stop = +stop, start2 = +start2, count = +count;
      if (!(count > 0))
        return [];
      if (start2 === stop)
        return [start2];
      const reverse2 = stop < start2, [i1, i2, inc] = reverse2 ? tickSpec(stop, start2, count) : tickSpec(start2, stop, count);
      if (!(i2 >= i1))
        return [];
      const n = i2 - i1 + 1, ticks2 = new Array(n);
      if (reverse2) {
        if (inc < 0)
          for (let i = 0; i < n; ++i)
            ticks2[i] = (i2 - i) / -inc;
        else
          for (let i = 0; i < n; ++i)
            ticks2[i] = (i2 - i) * inc;
      } else {
        if (inc < 0)
          for (let i = 0; i < n; ++i)
            ticks2[i] = (i1 + i) / -inc;
        else
          for (let i = 0; i < n; ++i)
            ticks2[i] = (i1 + i) * inc;
      }
      return ticks2;
    }
    function tickIncrement(start2, stop, count) {
      stop = +stop, start2 = +start2, count = +count;
      return tickSpec(start2, stop, count)[2];
    }
    function tickStep(start2, stop, count) {
      stop = +stop, start2 = +start2, count = +count;
      const reverse2 = stop < start2, inc = reverse2 ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
      return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
    }
    function max$5(values2, valueof) {
      let max2;
      if (valueof === void 0) {
        for (const value of values2) {
          if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
            max2 = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values2) {
          if ((value = valueof(value, ++index, values2)) != null && (max2 < value || max2 === void 0 && value >= value)) {
            max2 = value;
          }
        }
      }
      return max2;
    }
    function min$6(values2, valueof) {
      let min2;
      if (valueof === void 0) {
        for (const value of values2) {
          if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
            min2 = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values2) {
          if ((value = valueof(value, ++index, values2)) != null && (min2 > value || min2 === void 0 && value >= value)) {
            min2 = value;
          }
        }
      }
      return min2;
    }
    function quickselect(array2, k2, left2 = 0, right2 = Infinity, compare) {
      k2 = Math.floor(k2);
      left2 = Math.floor(Math.max(0, left2));
      right2 = Math.floor(Math.min(array2.length - 1, right2));
      if (!(left2 <= k2 && k2 <= right2))
        return array2;
      compare = compare === void 0 ? ascendingDefined$2 : compareDefined(compare);
      while (right2 > left2) {
        if (right2 - left2 > 600) {
          const n = right2 - left2 + 1;
          const m = k2 - left2 + 1;
          const z = Math.log(n);
          const s2 = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left2, Math.floor(k2 - m * s2 / n + sd));
          const newRight = Math.min(right2, Math.floor(k2 + (n - m) * s2 / n + sd));
          quickselect(array2, k2, newLeft, newRight, compare);
        }
        const t = array2[k2];
        let i = left2;
        let j = right2;
        swap(array2, left2, k2);
        if (compare(array2[right2], t) > 0)
          swap(array2, left2, right2);
        while (i < j) {
          swap(array2, i, j), ++i, --j;
          while (compare(array2[i], t) < 0)
            ++i;
          while (compare(array2[j], t) > 0)
            --j;
        }
        if (compare(array2[left2], t) === 0)
          swap(array2, left2, j);
        else
          ++j, swap(array2, j, right2);
        if (j <= k2)
          left2 = j + 1;
        if (k2 <= j)
          right2 = j - 1;
      }
      return array2;
    }
    function swap(array2, i, j) {
      const t = array2[i];
      array2[i] = array2[j];
      array2[j] = t;
    }
    function quantile$1(values2, p, valueof) {
      values2 = Float64Array.from(numbers(values2, valueof));
      if (!(n = values2.length) || isNaN(p = +p))
        return;
      if (p <= 0 || n < 2)
        return min$6(values2);
      if (p >= 1)
        return max$5(values2);
      var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max$5(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min$6(values2.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }
    function quantileSorted(values2, p, valueof = number$3) {
      if (!(n = values2.length) || isNaN(p = +p))
        return;
      if (p <= 0 || n < 2)
        return +valueof(values2[0], 0, values2);
      if (p >= 1)
        return +valueof(values2[n - 1], n - 1, values2);
      var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values2[i0], i0, values2), value1 = +valueof(values2[i0 + 1], i0 + 1, values2);
      return value0 + (value1 - value0) * (i - i0);
    }
    function median(values2, valueof) {
      return quantile$1(values2, 0.5, valueof);
    }
    function* flatten(arrays) {
      for (const array2 of arrays) {
        yield* array2;
      }
    }
    function merge$1(arrays) {
      return Array.from(flatten(arrays));
    }
    function range(start2, stop, step) {
      start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
      var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n);
      while (++i < n) {
        range2[i] = start2 + i * step;
      }
      return range2;
    }
    function reverse(values2) {
      if (typeof values2[Symbol.iterator] !== "function")
        throw new TypeError("values is not iterable");
      return Array.from(values2).reverse();
    }
    const scriptRel = "modulepreload";
    const assetsURL = function(dep) {
      return "/xxxx-missed-votes/" + dep;
    };
    const seen = {};
    const __vitePreload = function preload(baseModule, deps, importerUrl) {
      if (!deps || deps.length === 0) {
        return baseModule();
      }
      const links = document.getElementsByTagName("link");
      return Promise.all(deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen)
          return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i = links.length - 1; i >= 0; i--) {
            const link3 = links[i];
            if (link3.href === dep && (!isCss || link3.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link2 = document.createElement("link");
        link2.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link2.as = "script";
          link2.crossOrigin = "";
        }
        link2.href = dep;
        document.head.appendChild(link2);
        if (isCss) {
          return new Promise((res, rej) => {
            link2.addEventListener("load", res);
            link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
          });
        }
      })).then(() => baseModule()).catch((err) => {
        const e = new Event("vite:preloadError", { cancelable: true });
        e.payload = err;
        window.dispatchEvent(e);
        if (!e.defaultPrevented) {
          throw err;
        }
      });
    };
    var xhtml = "http://www.w3.org/1999/xhtml";
    const namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
        name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
    }
    function creatorInherit(name) {
      return function() {
        var document2 = this.ownerDocument, uri = this.namespaceURI;
        return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
      };
    }
    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }
    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local ? creatorFixed : creatorInherit)(fullname);
    }
    function none() {
    }
    function selector(selector2) {
      return selector2 == null ? none : function() {
        return this.querySelector(selector2);
      };
    }
    function selection_select(select) {
      if (typeof select !== "function")
        select = selector(select);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
          if ((node2 = group[i]) && (subnode = select.call(node2, node2.__data__, i, group))) {
            if ("__data__" in node2)
              subnode.__data__ = node2.__data__;
            subgroup[i] = subnode;
          }
        }
      }
      return new Selection$1(subgroups, this._parents);
    }
    function array(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }
    function empty$3() {
      return [];
    }
    function selectorAll(selector2) {
      return selector2 == null ? empty$3 : function() {
        return this.querySelectorAll(selector2);
      };
    }
    function arrayAll(select) {
      return function() {
        return array(select.apply(this, arguments));
      };
    }
    function selection_selectAll(select) {
      if (typeof select === "function")
        select = arrayAll(select);
      else
        select = selectorAll(select);
      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
          if (node2 = group[i]) {
            subgroups.push(select.call(node2, node2.__data__, i, group));
            parents.push(node2);
          }
        }
      }
      return new Selection$1(subgroups, parents);
    }
    function matcher(selector2) {
      return function() {
        return this.matches(selector2);
      };
    }
    function childMatcher(selector2) {
      return function(node2) {
        return node2.matches(selector2);
      };
    }
    var find$2 = Array.prototype.find;
    function childFind(match2) {
      return function() {
        return find$2.call(this.children, match2);
      };
    }
    function childFirst() {
      return this.firstElementChild;
    }
    function selection_selectChild(match2) {
      return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
    }
    var filter = Array.prototype.filter;
    function children() {
      return Array.from(this.children);
    }
    function childrenFilter(match2) {
      return function() {
        return filter.call(this.children, match2);
      };
    }
    function selection_selectChildren(match2) {
      return this.selectAll(match2 == null ? children : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
    }
    function selection_filter(match2) {
      if (typeof match2 !== "function")
        match2 = matcher(match2);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
          if ((node2 = group[i]) && match2.call(node2, node2.__data__, i, group)) {
            subgroup.push(node2);
          }
        }
      }
      return new Selection$1(subgroups, this._parents);
    }
    function sparse(update2) {
      return new Array(update2.length);
    }
    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }
    function EnterNode(parent, datum2) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum2;
    }
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function(selector2) {
        return this._parent.querySelector(selector2);
      },
      querySelectorAll: function(selector2) {
        return this._parent.querySelectorAll(selector2);
      }
    };
    function constant$4(x) {
      return function() {
        return x;
      };
    }
    function bindIndex(parent, group, enter, update2, exit, data2) {
      var i = 0, node2, groupLength = group.length, dataLength = data2.length;
      for (; i < dataLength; ++i) {
        if (node2 = group[i]) {
          node2.__data__ = data2[i];
          update2[i] = node2;
        } else {
          enter[i] = new EnterNode(parent, data2[i]);
        }
      }
      for (; i < groupLength; ++i) {
        if (node2 = group[i]) {
          exit[i] = node2;
        }
      }
    }
    function bindKey(parent, group, enter, update2, exit, data2, key) {
      var i, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data2.length, keyValues = new Array(groupLength), keyValue;
      for (i = 0; i < groupLength; ++i) {
        if (node2 = group[i]) {
          keyValues[i] = keyValue = key.call(node2, node2.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node2;
          } else {
            nodeByKeyValue.set(keyValue, node2);
          }
        }
      }
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data2[i], i, data2) + "";
        if (node2 = nodeByKeyValue.get(keyValue)) {
          update2[i] = node2;
          node2.__data__ = data2[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data2[i]);
        }
      }
      for (i = 0; i < groupLength; ++i) {
        if ((node2 = group[i]) && nodeByKeyValue.get(keyValues[i]) === node2) {
          exit[i] = node2;
        }
      }
    }
    function datum(node2) {
      return node2.__data__;
    }
    function selection_data(value, key) {
      if (!arguments.length)
        return Array.from(this, datum);
      var bind2 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
      if (typeof value !== "function")
        value = constant$4(value);
      for (var m = groups.length, update2 = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j], group = groups[j], groupLength = group.length, data2 = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data2.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
        bind2(parent, group, enterGroup, updateGroup, exitGroup, data2, key);
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1)
              i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength)
              ;
            previous._next = next || null;
          }
        }
      }
      update2 = new Selection$1(update2, parents);
      update2._enter = enter;
      update2._exit = exit;
      return update2;
    }
    function arraylike(data2) {
      return typeof data2 === "object" && "length" in data2 ? data2 : Array.from(data2);
    }
    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }
    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update2 = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter)
          enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update2 = onupdate(update2);
        if (update2)
          update2 = update2.selection();
      }
      if (onexit == null)
        exit.remove();
      else
        onexit(exit);
      return enter && update2 ? enter.merge(update2).order() : update2;
    }
    function selection_merge(context) {
      var selection2 = context.selection ? context.selection() : context;
      for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
          if (node2 = group0[i] || group1[i]) {
            merge2[i] = node2;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Selection$1(merges, this._parents);
    }
    function selection_order() {
      for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node2; --i >= 0; ) {
          if (node2 = group[i]) {
            if (next && node2.compareDocumentPosition(next) ^ 4)
              next.parentNode.insertBefore(node2, next);
            next = node2;
          }
        }
      }
      return this;
    }
    function selection_sort(compare) {
      if (!compare)
        compare = ascending;
      function compareNode(a2, b) {
        return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
      }
      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node2, i = 0; i < n; ++i) {
          if (node2 = group[i]) {
            sortgroup[i] = node2;
          }
        }
        sortgroup.sort(compareNode);
      }
      return new Selection$1(sortgroups, this._parents).order();
    }
    function ascending(a2, b) {
      return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
    }
    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }
    function selection_nodes() {
      return Array.from(this);
    }
    function selection_node() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node2 = group[i];
          if (node2)
            return node2;
        }
      }
      return null;
    }
    function selection_size() {
      let size = 0;
      for (const node2 of this)
        ++size;
      return size;
    }
    function selection_empty() {
      return !this.node();
    }
    function selection_each(callback) {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
          if (node2 = group[i])
            callback.call(node2, node2.__data__, i, group);
        }
      }
      return this;
    }
    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }
    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }
    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }
    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.removeAttribute(name);
        else
          this.setAttribute(name, v);
      };
    }
    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.removeAttributeNS(fullname.space, fullname.local);
        else
          this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }
    function selection_attr(name, value) {
      var fullname = namespace(name);
      if (arguments.length < 2) {
        var node2 = this.node();
        return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
      }
      return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
    }
    function defaultView(node2) {
      return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
    }
    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }
    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }
    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.style.removeProperty(name);
        else
          this.style.setProperty(name, v, priority);
      };
    }
    function selection_style(name, value, priority) {
      return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
    }
    function styleValue(node2, name) {
      return node2.style.getPropertyValue(name) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name);
    }
    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }
    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }
    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          delete this[name];
        else
          this[name] = v;
      };
    }
    function selection_property(name, value) {
      return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
    }
    function classArray(string2) {
      return string2.trim().split(/^|\s+/);
    }
    function classList$2(node2) {
      return node2.classList || new ClassList(node2);
    }
    function ClassList(node2) {
      this._node = node2;
      this._names = classArray(node2.getAttribute("class") || "");
    }
    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };
    function classedAdd(node2, names) {
      var list = classList$2(node2), i = -1, n = names.length;
      while (++i < n)
        list.add(names[i]);
    }
    function classedRemove(node2, names) {
      var list = classList$2(node2), i = -1, n = names.length;
      while (++i < n)
        list.remove(names[i]);
    }
    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }
    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }
    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }
    function selection_classed(name, value) {
      var names = classArray(name + "");
      if (arguments.length < 2) {
        var list = classList$2(this.node()), i = -1, n = names.length;
        while (++i < n)
          if (!list.contains(names[i]))
            return false;
        return true;
      }
      return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
    }
    function textRemove() {
      this.textContent = "";
    }
    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }
    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }
    function selection_text(value) {
      return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
    }
    function htmlRemove() {
      this.innerHTML = "";
    }
    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }
    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }
    function selection_html(value) {
      return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
    }
    function raise() {
      if (this.nextSibling)
        this.parentNode.appendChild(this);
    }
    function selection_raise() {
      return this.each(raise);
    }
    function lower() {
      if (this.previousSibling)
        this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower() {
      return this.each(lower);
    }
    function selection_append(name) {
      var create2 = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create2.apply(this, arguments));
      });
    }
    function constantNull() {
      return null;
    }
    function selection_insert(name, before) {
      var create2 = typeof name === "function" ? name : creator(name), select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }
    function remove() {
      var parent = this.parentNode;
      if (parent)
        parent.removeChild(this);
    }
    function selection_remove() {
      return this.each(remove);
    }
    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }
    function selection_datum(value) {
      return arguments.length ? this.property("__data__", value) : this.node().__data__;
    }
    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }
    function parseTypenames$1(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0)
          name = t.slice(i + 1), t = t.slice(0, i);
        return { type: t, name };
      });
    }
    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on)
          return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i)
          on.length = i;
        else
          delete this.__on;
      };
    }
    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on)
          for (var j = 0, m = on.length; j < m; ++j) {
            if ((o = on[j]).type === typename.type && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.options);
              this.addEventListener(o.type, o.listener = listener, o.options = options);
              o.value = value;
              return;
            }
          }
        this.addEventListener(typename.type, listener, options);
        o = { type: typename.type, name: typename.name, value, listener, options };
        if (!on)
          this.__on = [o];
        else
          on.push(o);
      };
    }
    function selection_on(typename, value, options) {
      var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;
      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on)
          for (var j = 0, m = on.length, o; j < m; ++j) {
            for (i = 0, o = on[j]; i < n; ++i) {
              if ((t = typenames[i]).type === o.type && t.name === o.name) {
                return o.value;
              }
            }
          }
        return;
      }
      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i)
        this.each(on(typenames[i], value, options));
      return this;
    }
    function dispatchEvent$3(node2, type, params) {
      var window2 = defaultView(node2), event = window2.CustomEvent;
      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window2.document.createEvent("Event");
        if (params)
          event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else
          event.initEvent(type, false, false);
      }
      node2.dispatchEvent(event);
    }
    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent$3(this, type, params);
      };
    }
    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent$3(this, type, params.apply(this, arguments));
      };
    }
    function selection_dispatch(type, params) {
      return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
    }
    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
          if (node2 = group[i])
            yield node2;
        }
      }
    }
    var root$2 = [null];
    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }
    function selection() {
      return new Selection$1([[document.documentElement]], root$2);
    }
    function selection_selection() {
      return this;
    }
    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };
    function select$1(selector2) {
      return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$2);
    }
    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }
    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition)
        prototype[key] = definition[key];
      return prototype;
    }
    function Color() {
    }
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    var named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define(Color, color$2, {
      copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    function color_formatHex() {
      return this.rgb().formatHex();
    }
    function color_formatHex8() {
      return this.rgb().formatHex8();
    }
    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }
    function color_formatRgb() {
      return this.rgb().formatRgb();
    }
    function color$2(format2) {
      var m, l;
      format2 = (format2 + "").trim().toLowerCase();
      return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }
    function rgbn(n) {
      return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
    }
    function rgba(r, g, b, a2) {
      if (a2 <= 0)
        r = g = b = NaN;
      return new Rgb(r, g, b, a2);
    }
    function rgbConvert(o) {
      if (!(o instanceof Color))
        o = color$2(o);
      if (!o)
        return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b, opacity2) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity2 == null ? 1 : opacity2);
    }
    function Rgb(r, g, b, opacity2) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity2;
    }
    define(Rgb, rgb, extend(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }
    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }
    function rgb_formatRgb() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
    }
    function clampa(opacity2) {
      return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
    }
    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }
    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla(h, s2, l, a2) {
      if (a2 <= 0)
        h = s2 = l = NaN;
      else if (l <= 0 || l >= 1)
        h = s2 = NaN;
      else if (s2 <= 0)
        h = NaN;
      return new Hsl(h, s2, l, a2);
    }
    function hslConvert(o) {
      if (o instanceof Hsl)
        return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color))
        o = color$2(o);
      if (!o)
        return new Hsl();
      if (o instanceof Hsl)
        return o;
      o = o.rgb();
      var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s2 = max2 - min2, l = (max2 + min2) / 2;
      if (s2) {
        if (r === max2)
          h = (g - b) / s2 + (g < b) * 6;
        else if (g === max2)
          h = (b - r) / s2 + 2;
        else
          h = (r - g) / s2 + 4;
        s2 /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
        h *= 60;
      } else {
        s2 = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s2, l, o.opacity);
    }
    function hsl$1(h, s2, l, opacity2) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity2 == null ? 1 : opacity2);
    }
    function Hsl(h, s2, l, opacity2) {
      this.h = +h;
      this.s = +s2;
      this.l = +l;
      this.opacity = +opacity2;
    }
    define(Hsl, hsl$1, extend(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Hsl(this.h, this.s, this.l * k2, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a2 = clampa(this.opacity);
        return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
      }
    }));
    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }
    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
    }
    const radians$1 = Math.PI / 180;
    const degrees$2 = 180 / Math.PI;
    const K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0$1 = 4 / 29, t1$1 = 6 / 29, t2 = 3 * t1$1 * t1$1, t3 = t1$1 * t1$1 * t1$1;
    function labConvert(o) {
      if (o instanceof Lab)
        return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl)
        return hcl2lab(o);
      if (!(o instanceof Rgb))
        o = rgbConvert(o);
      var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b)
        x = z = y;
      else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }
    function lab$1(l, a2, b, opacity2) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity2 == null ? 1 : opacity2);
    }
    function Lab(l, a2, b, opacity2) {
      this.l = +l;
      this.a = +a2;
      this.b = +b;
      this.opacity = +opacity2;
    }
    define(Lab, lab$1, extend(Color, {
      brighter(k2) {
        return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
      },
      darker(k2) {
        return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
      },
      rgb() {
        var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
          lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));
    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
    }
    function lab2xyz(t) {
      return t > t1$1 ? t * t * t : t2 * (t - t0$1);
    }
    function lrgb2rgb(x) {
      return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }
    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }
    function hclConvert(o) {
      if (o instanceof Hcl)
        return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab))
        o = labConvert(o);
      if (o.a === 0 && o.b === 0)
        return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees$2;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }
    function hcl$1(h, c2, l, opacity2) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c2, l, opacity2 == null ? 1 : opacity2);
    }
    function Hcl(h, c2, l, opacity2) {
      this.h = +h;
      this.c = +c2;
      this.l = +l;
      this.opacity = +opacity2;
    }
    function hcl2lab(o) {
      if (isNaN(o.h))
        return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians$1;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }
    define(Hcl, hcl$1, extend(Color, {
      brighter(k2) {
        return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
      },
      darker(k2) {
        return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));
    var A = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
    function cubehelixConvert(o) {
      if (o instanceof Cubehelix)
        return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb))
        o = rgbConvert(o);
      var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees$2 - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
    }
    function cubehelix$1(h, s2, l, opacity2) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity2 == null ? 1 : opacity2);
    }
    function Cubehelix(h, s2, l, opacity2) {
      this.h = +h;
      this.s = +s2;
      this.l = +l;
      this.opacity = +opacity2;
    }
    define(Cubehelix, cubehelix$1, extend(Color, {
      brighter(k2) {
        k2 = k2 == null ? brighter : Math.pow(brighter, k2);
        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
      },
      darker(k2) {
        k2 = k2 == null ? darker : Math.pow(darker, k2);
        return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
      },
      rgb() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$1, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a2 * (A * cosh + B * sinh)),
          255 * (l + a2 * (C * cosh + D * sinh)),
          255 * (l + a2 * (E * cosh)),
          this.opacity
        );
      }
    }));
    function identity$7(x) {
      return x;
    }
    var top$2 = 1, right$1 = 2, bottom$1 = 3, left$1 = 4, epsilon$2 = 1e-6;
    function translateX(x) {
      return "translate(" + x + ",0)";
    }
    function translateY(y) {
      return "translate(0," + y + ")";
    }
    function number$2(scale2) {
      return (d) => +scale2(d);
    }
    function center(scale2, offset2) {
      offset2 = Math.max(0, scale2.bandwidth() - offset2 * 2) / 2;
      if (scale2.round())
        offset2 = Math.round(offset2);
      return (d) => +scale2(d) + offset2;
    }
    function entering() {
      return !this.__axis;
    }
    function axis(orient, scale2) {
      var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top$2 || orient === left$1 ? -1 : 1, x = orient === left$1 || orient === right$1 ? "x" : "y", transform = orient === top$2 || orient === bottom$1 ? translateX : translateY;
      function axis2(context) {
        var values2 = tickValues == null ? scale2.ticks ? scale2.ticks.apply(scale2, tickArguments) : scale2.domain() : tickValues, format2 = tickFormat2 == null ? scale2.tickFormat ? scale2.tickFormat.apply(scale2, tickArguments) : identity$7 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale2.range(), range0 = +range2[0] + offset2, range1 = +range2[range2.length - 1] + offset2, position2 = (scale2.bandwidth ? center : number$2)(scale2.copy(), offset2), selection2 = context.selection ? context.selection() : context, path = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale2).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text2 = tick.select("text");
        path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
        tick = tick.merge(tickEnter);
        line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k2 * tickSizeInner));
        text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k2 * spacing).attr("dy", orient === top$2 ? "0em" : orient === bottom$1 ? "0.71em" : "0.32em"));
        if (context !== selection2) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text2 = text2.transition(context);
          tickExit = tickExit.transition(context).attr("opacity", epsilon$2).attr("transform", function(d) {
            return isFinite(d = position2(d)) ? transform(d + offset2) : this.getAttribute("transform");
          });
          tickEnter.attr("opacity", epsilon$2).attr("transform", function(d) {
            var p = this.parentNode.__axis;
            return transform((p && isFinite(p = p(d)) ? p : position2(d)) + offset2);
          });
        }
        tickExit.remove();
        path.attr("d", orient === left$1 || orient === right$1 ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset2 + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset2 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset2 + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset2 + "H" + range1);
        tick.attr("opacity", 1).attr("transform", function(d) {
          return transform(position2(d) + offset2);
        });
        line.attr(x + "2", k2 * tickSizeInner);
        text2.attr(x, k2 * spacing).text(format2);
        selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right$1 ? "start" : orient === left$1 ? "end" : "middle");
        selection2.each(function() {
          this.__axis = position2;
        });
      }
      axis2.scale = function(_) {
        return arguments.length ? (scale2 = _, axis2) : scale2;
      };
      axis2.ticks = function() {
        return tickArguments = Array.from(arguments), axis2;
      };
      axis2.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
      };
      axis2.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
      };
      axis2.tickFormat = function(_) {
        return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
      };
      axis2.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
      };
      axis2.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
      };
      axis2.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
      };
      axis2.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
      };
      axis2.offset = function(_) {
        return arguments.length ? (offset2 = +_, axis2) : offset2;
      };
      return axis2;
    }
    function axisBottom(scale2) {
      return axis(bottom$1, scale2);
    }
    var noop$4 = { value: () => {
    } };
    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
          throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch$3(_);
    }
    function Dispatch$3(_) {
      this._ = _;
    }
    function parseTypenames(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0)
          name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t))
          throw new Error("unknown type: " + t);
        return { type: t, name };
      });
    }
    Dispatch$3.prototype = dispatch.prototype = {
      constructor: Dispatch$3,
      on: function(typename, callback) {
        var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
        if (arguments.length < 2) {
          while (++i < n)
            if ((t = (typename = T[i]).type) && (t = get$4(_[t], typename.name)))
              return t;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type)
            _[t] = set$5(_[t], typename.name, callback);
          else if (callback == null)
            for (t in _)
              _[t] = set$5(_[t], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy2 = {}, _ = this._;
        for (var t in _)
          copy2[t] = _[t].slice();
        return new Dispatch$3(copy2);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0)
          for (var args = new Array(n), i = 0, n, t; i < n; ++i)
            args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i)
          t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
          t[i].value.apply(that, args);
      }
    };
    function get$4(type, name) {
      for (var i = 0, n = type.length, c2; i < n; ++i) {
        if ((c2 = type[i]).name === name) {
          return c2.value;
        }
      }
    }
    function set$5(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$4, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null)
        type.push({ name, value: callback });
      return type;
    }
    function basis(t12, v0, v1, v2, v3) {
      var t22 = t12 * t12, t32 = t22 * t12;
      return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
    }
    function basis$1(values2) {
      var n = values2.length - 1;
      return function(t) {
        var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
        return basis((t - i / n) * n, v0, v1, v2, v3);
      };
    }
    const constant$3 = (x) => () => x;
    function linear$1(a2, d) {
      return function(t) {
        return a2 + t * d;
      };
    }
    function exponential(a2, b, y) {
      return a2 = Math.pow(a2, y), b = Math.pow(b, y) - a2, y = 1 / y, function(t) {
        return Math.pow(a2 + t * b, y);
      };
    }
    function hue(a2, b) {
      var d = b - a2;
      return d ? linear$1(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a2) ? b : a2);
    }
    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function(a2, b) {
        return b - a2 ? exponential(a2, b, y) : constant$3(isNaN(a2) ? b : a2);
      };
    }
    function nogamma(a2, b) {
      var d = b - a2;
      return d ? linear$1(a2, d) : constant$3(isNaN(a2) ? b : a2);
    }
    const interpolateRgb = function rgbGamma(y) {
      var color2 = gamma(y);
      function rgb$1(start2, end2) {
        var r = color2((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g = color2(start2.g, end2.g), b = color2(start2.b, end2.b), opacity2 = nogamma(start2.opacity, end2.opacity);
        return function(t) {
          start2.r = r(t);
          start2.g = g(t);
          start2.b = b(t);
          start2.opacity = opacity2(t);
          return start2 + "";
        };
      }
      rgb$1.gamma = rgbGamma;
      return rgb$1;
    }(1);
    function rgbSpline(spline) {
      return function(colors2) {
        var n = colors2.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
        for (i = 0; i < n; ++i) {
          color2 = rgb(colors2[i]);
          r[i] = color2.r || 0;
          g[i] = color2.g || 0;
          b[i] = color2.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color2.opacity = 1;
        return function(t) {
          color2.r = r(t);
          color2.g = g(t);
          color2.b = b(t);
          return color2 + "";
        };
      };
    }
    var rgbBasis = rgbSpline(basis$1);
    function numberArray(a2, b) {
      if (!b)
        b = [];
      var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
      return function(t) {
        for (i = 0; i < n; ++i)
          c2[i] = a2[i] * (1 - t) + b[i] * t;
        return c2;
      };
    }
    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }
    function genericArray(a2, b) {
      var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x = new Array(na), c2 = new Array(nb), i;
      for (i = 0; i < na; ++i)
        x[i] = interpolate$1(a2[i], b[i]);
      for (; i < nb; ++i)
        c2[i] = b[i];
      return function(t) {
        for (i = 0; i < na; ++i)
          c2[i] = x[i](t);
        return c2;
      };
    }
    function date$1(a2, b) {
      var d = /* @__PURE__ */ new Date();
      return a2 = +a2, b = +b, function(t) {
        return d.setTime(a2 * (1 - t) + b * t), d;
      };
    }
    function interpolateNumber(a2, b) {
      return a2 = +a2, b = +b, function(t) {
        return a2 * (1 - t) + b * t;
      };
    }
    function object(a2, b) {
      var i = {}, c2 = {}, k2;
      if (a2 === null || typeof a2 !== "object")
        a2 = {};
      if (b === null || typeof b !== "object")
        b = {};
      for (k2 in b) {
        if (k2 in a2) {
          i[k2] = interpolate$1(a2[k2], b[k2]);
        } else {
          c2[k2] = b[k2];
        }
      }
      return function(t) {
        for (k2 in i)
          c2[k2] = i[k2](t);
        return c2;
      };
    }
    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
    function zero(b) {
      return function() {
        return b;
      };
    }
    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }
    function interpolateString(a2, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
      a2 = a2 + "", b = b + "";
      while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) {
          bs = b.slice(bi, bs);
          if (s2[i])
            s2[i] += bs;
          else
            s2[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
          if (s2[i])
            s2[i] += bm;
          else
            s2[++i] = bm;
        } else {
          s2[++i] = null;
          q.push({ i, x: interpolateNumber(am, bm) });
        }
        bi = reB.lastIndex;
      }
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s2[i])
          s2[i] += bs;
        else
          s2[++i] = bs;
      }
      return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
        for (var i2 = 0, o; i2 < b; ++i2)
          s2[(o = q[i2]).i] = o.x(t);
        return s2.join("");
      });
    }
    function interpolate$1(a2, b) {
      var t = typeof b, c2;
      return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? interpolateNumber : t === "string" ? (c2 = color$2(b)) ? (b = c2, interpolateRgb) : interpolateString : b instanceof color$2 ? interpolateRgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a2, b);
    }
    function interpolateRound(a2, b) {
      return a2 = +a2, b = +b, function(t) {
        return Math.round(a2 * (1 - t) + b * t);
      };
    }
    var degrees$1 = 180 / Math.PI;
    var identity$6 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
    function decompose(a2, b, c2, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a2 * a2 + b * b))
        a2 /= scaleX, b /= scaleX;
      if (skewX = a2 * c2 + b * d)
        c2 -= a2 * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c2 * c2 + d * d))
        c2 /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a2 * d < b * c2)
        a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a2) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX,
        scaleY
      };
    }
    var svgNode;
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$6 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }
    function parseSvg(value) {
      if (value == null)
        return identity$6;
      if (!svgNode)
        svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate()))
        return identity$6;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }
    function interpolateTransform(parse2, pxComma, pxParen, degParen) {
      function pop(s2) {
        return s2.length ? s2.pop() + " " : "";
      }
      function translate(xa, ya, xb, yb, s2, q) {
        if (xa !== xb || ya !== yb) {
          var i = s2.push("translate(", null, pxComma, null, pxParen);
          q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
        } else if (xb || yb) {
          s2.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }
      function rotate(a2, b, s2, q) {
        if (a2 !== b) {
          if (a2 - b > 180)
            b += 360;
          else if (b - a2 > 180)
            a2 += 360;
          q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b) });
        } else if (b) {
          s2.push(pop(s2) + "rotate(" + b + degParen);
        }
      }
      function skewX(a2, b, s2, q) {
        if (a2 !== b) {
          q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b) });
        } else if (b) {
          s2.push(pop(s2) + "skewX(" + b + degParen);
        }
      }
      function scale2(xa, ya, xb, yb, s2, q) {
        if (xa !== xb || ya !== yb) {
          var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
          q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
        } else if (xb !== 1 || yb !== 1) {
          s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
        }
      }
      return function(a2, b) {
        var s2 = [], q = [];
        a2 = parse2(a2), b = parse2(b);
        translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
        rotate(a2.rotate, b.rotate, s2, q);
        skewX(a2.skewX, b.skewX, s2, q);
        scale2(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
        a2 = b = null;
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n)
            s2[(o = q[i]).i] = o.x(t);
          return s2.join("");
        };
      };
    }
    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
    function hsl(hue2) {
      return function(start2, end2) {
        var h = hue2((start2 = hsl$1(start2)).h, (end2 = hsl$1(end2)).h), s2 = nogamma(start2.s, end2.s), l = nogamma(start2.l, end2.l), opacity2 = nogamma(start2.opacity, end2.opacity);
        return function(t) {
          start2.h = h(t);
          start2.s = s2(t);
          start2.l = l(t);
          start2.opacity = opacity2(t);
          return start2 + "";
        };
      };
    }
    const interpolateHsl = hsl(hue);
    function lab(start2, end2) {
      var l = nogamma((start2 = lab$1(start2)).l, (end2 = lab$1(end2)).l), a2 = nogamma(start2.a, end2.a), b = nogamma(start2.b, end2.b), opacity2 = nogamma(start2.opacity, end2.opacity);
      return function(t) {
        start2.l = l(t);
        start2.a = a2(t);
        start2.b = b(t);
        start2.opacity = opacity2(t);
        return start2 + "";
      };
    }
    function hcl(hue2) {
      return function(start2, end2) {
        var h = hue2((start2 = hcl$1(start2)).h, (end2 = hcl$1(end2)).h), c2 = nogamma(start2.c, end2.c), l = nogamma(start2.l, end2.l), opacity2 = nogamma(start2.opacity, end2.opacity);
        return function(t) {
          start2.h = h(t);
          start2.c = c2(t);
          start2.l = l(t);
          start2.opacity = opacity2(t);
          return start2 + "";
        };
      };
    }
    const interpolateHcl = hcl(hue);
    function cubehelix(hue2) {
      return function cubehelixGamma(y) {
        y = +y;
        function cubehelix2(start2, end2) {
          var h = hue2((start2 = cubehelix$1(start2)).h, (end2 = cubehelix$1(end2)).h), s2 = nogamma(start2.s, end2.s), l = nogamma(start2.l, end2.l), opacity2 = nogamma(start2.opacity, end2.opacity);
          return function(t) {
            start2.h = h(t);
            start2.s = s2(t);
            start2.l = l(Math.pow(t, y));
            start2.opacity = opacity2(t);
            return start2 + "";
          };
        }
        cubehelix2.gamma = cubehelixGamma;
        return cubehelix2;
      }(1);
    }
    cubehelix(hue);
    var cubehelixLong = cubehelix(nogamma);
    function piecewise(interpolate2, values2) {
      if (values2 === void 0)
        values2 = interpolate2, interpolate2 = interpolate$1;
      var i = 0, n = values2.length - 1, v = values2[0], I = new Array(n < 0 ? 0 : n);
      while (i < n)
        I[i] = interpolate2(v, v = values2[++i]);
      return function(t) {
        var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i2](t - i2);
      };
    }
    function quantize(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i)
        samples[i] = interpolator(i / (n - 1));
      return samples;
    }
    var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
      setTimeout(f, 17);
    };
    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }
    function clearNow() {
      clockNow = 0;
    }
    function Timer() {
      this._call = this._time = this._next = null;
    }
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time2) {
        if (typeof callback !== "function")
          throw new TypeError("callback is not a function");
        time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail)
            taskTail._next = this;
          else
            taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time2;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
    function timer(callback, delay, time2) {
      var t = new Timer();
      t.restart(callback, delay, time2);
      return t;
    }
    function timerFlush() {
      now();
      ++frame;
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0)
          t._call.call(void 0, e);
        t = t._next;
      }
      --frame;
    }
    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }
    function poke() {
      var now2 = clock.now(), delay = now2 - clockLast;
      if (delay > pokeDelay)
        clockSkew -= delay, clockLast = now2;
    }
    function nap() {
      var t02, t12 = taskHead, t22, time2 = Infinity;
      while (t12) {
        if (t12._call) {
          if (time2 > t12._time)
            time2 = t12._time;
          t02 = t12, t12 = t12._next;
        } else {
          t22 = t12._next, t12._next = null;
          t12 = t02 ? t02._next = t22 : taskHead = t22;
        }
      }
      taskTail = t02;
      sleep(time2);
    }
    function sleep(time2) {
      if (frame)
        return;
      if (timeout$1)
        timeout$1 = clearTimeout(timeout$1);
      var delay = time2 - clockNow;
      if (delay > 24) {
        if (time2 < Infinity)
          timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
        if (interval)
          interval = clearInterval(interval);
      } else {
        if (!interval)
          clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }
    function timeout(callback, delay, time2) {
      var t = new Timer();
      delay = delay == null ? 0 : +delay;
      t.restart((elapsed) => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time2);
      return t;
    }
    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];
    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;
    function schedule(node2, name, id2, index, group, timing) {
      var schedules = node2.__transition;
      if (!schedules)
        node2.__transition = {};
      else if (id2 in schedules)
        return;
      create$5(node2, id2, {
        name,
        index,
        // For context during callback.
        group,
        // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }
    function init$1(node2, id2) {
      var schedule2 = get$3(node2, id2);
      if (schedule2.state > CREATED)
        throw new Error("too late; already scheduled");
      return schedule2;
    }
    function set$4(node2, id2) {
      var schedule2 = get$3(node2, id2);
      if (schedule2.state > STARTED)
        throw new Error("too late; already running");
      return schedule2;
    }
    function get$3(node2, id2) {
      var schedule2 = node2.__transition;
      if (!schedule2 || !(schedule2 = schedule2[id2]))
        throw new Error("transition not found");
      return schedule2;
    }
    function create$5(node2, id2, self2) {
      var schedules = node2.__transition, tween;
      schedules[id2] = self2;
      self2.timer = timer(schedule2, 0, self2.time);
      function schedule2(elapsed) {
        self2.state = SCHEDULED;
        self2.timer.restart(start2, self2.delay, self2.time);
        if (self2.delay <= elapsed)
          start2(elapsed - self2.delay);
      }
      function start2(elapsed) {
        var i, j, n, o;
        if (self2.state !== SCHEDULED)
          return stop();
        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self2.name)
            continue;
          if (o.state === STARTED)
            return timeout(start2);
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
            delete schedules[i];
          } else if (+i < id2) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node2, node2.__data__, o.index, o.group);
            delete schedules[i];
          }
        }
        timeout(function() {
          if (self2.state === STARTED) {
            self2.state = RUNNING;
            self2.timer.restart(tick, self2.delay, self2.time);
            tick(elapsed);
          }
        });
        self2.state = STARTING;
        self2.on.call("start", node2, node2.__data__, self2.index, self2.group);
        if (self2.state !== STARTING)
          return;
        self2.state = STARTED;
        tween = new Array(n = self2.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self2.tween[i].value.call(node2, node2.__data__, self2.index, self2.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }
      function tick(elapsed) {
        var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
        while (++i < n) {
          tween[i].call(node2, t);
        }
        if (self2.state === ENDING) {
          self2.on.call("end", node2, node2.__data__, self2.index, self2.group);
          stop();
        }
      }
      function stop() {
        self2.state = ENDED;
        self2.timer.stop();
        delete schedules[id2];
        for (var i in schedules)
          return;
        delete node2.__transition;
      }
    }
    function interrupt(node2, name) {
      var schedules = node2.__transition, schedule2, active, empty2 = true, i;
      if (!schedules)
        return;
      name = name == null ? null : name + "";
      for (i in schedules) {
        if ((schedule2 = schedules[i]).name !== name) {
          empty2 = false;
          continue;
        }
        active = schedule2.state > STARTING && schedule2.state < ENDING;
        schedule2.state = ENDED;
        schedule2.timer.stop();
        schedule2.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group);
        delete schedules[i];
      }
      if (empty2)
        delete node2.__transition;
    }
    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }
    function tweenRemove(id2, name) {
      var tween0, tween1;
      return function() {
        var schedule2 = set$4(this, id2), tween = schedule2.tween;
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }
        schedule2.tween = tween1;
      };
    }
    function tweenFunction(id2, name, value) {
      var tween0, tween1;
      if (typeof value !== "function")
        throw new Error();
      return function() {
        var schedule2 = set$4(this, id2), tween = schedule2.tween;
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n)
            tween1.push(t);
        }
        schedule2.tween = tween1;
      };
    }
    function transition_tween(name, value) {
      var id2 = this._id;
      name += "";
      if (arguments.length < 2) {
        var tween = get$3(this.node(), id2).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }
      return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
    }
    function tweenValue(transition, name, value) {
      var id2 = transition._id;
      transition.each(function() {
        var schedule2 = set$4(this, id2);
        (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
      });
      return function(node2) {
        return get$3(node2, id2).value[name];
      };
    }
    function interpolate(a2, b) {
      var c2;
      return (typeof b === "number" ? interpolateNumber : b instanceof color$2 ? interpolateRgb : (c2 = color$2(b)) ? (b = c2, interpolateRgb) : interpolateString)(a2, b);
    }
    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }
    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant(name, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function attrConstantNS(fullname, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function attrFunction(name, interpolate2, value) {
      var string00, string10, interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null)
          return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function attrFunctionNS(fullname, interpolate2, value) {
      var string00, string10, interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null)
          return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
      return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }
    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }
    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }
    function attrTweenNS(fullname, value) {
      var t02, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
          t02 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t02;
      }
      tween._value = value;
      return tween;
    }
    function attrTween(name, value) {
      var t02, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
          t02 = (i0 = i) && attrInterpolate(name, i);
        return t02;
      }
      tween._value = value;
      return tween;
    }
    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2)
        return (key = this.tween(key)) && key._value;
      if (value == null)
        return this.tween(key, null);
      if (typeof value !== "function")
        throw new Error();
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }
    function delayFunction(id2, value) {
      return function() {
        init$1(this, id2).delay = +value.apply(this, arguments);
      };
    }
    function delayConstant(id2, value) {
      return value = +value, function() {
        init$1(this, id2).delay = value;
      };
    }
    function transition_delay(value) {
      var id2 = this._id;
      return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get$3(this.node(), id2).delay;
    }
    function durationFunction(id2, value) {
      return function() {
        set$4(this, id2).duration = +value.apply(this, arguments);
      };
    }
    function durationConstant(id2, value) {
      return value = +value, function() {
        set$4(this, id2).duration = value;
      };
    }
    function transition_duration(value) {
      var id2 = this._id;
      return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get$3(this.node(), id2).duration;
    }
    function easeConstant(id2, value) {
      if (typeof value !== "function")
        throw new Error();
      return function() {
        set$4(this, id2).ease = value;
      };
    }
    function transition_ease(value) {
      var id2 = this._id;
      return arguments.length ? this.each(easeConstant(id2, value)) : get$3(this.node(), id2).ease;
    }
    function easeVarying(id2, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function")
          throw new Error();
        set$4(this, id2).ease = v;
      };
    }
    function transition_easeVarying(value) {
      if (typeof value !== "function")
        throw new Error();
      return this.each(easeVarying(this._id, value));
    }
    function transition_filter(match2) {
      if (typeof match2 !== "function")
        match2 = matcher(match2);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
          if ((node2 = group[i]) && match2.call(node2, node2.__data__, i, group)) {
            subgroup.push(node2);
          }
        }
      }
      return new Transition(subgroups, this._parents, this._name, this._id);
    }
    function transition_merge(transition) {
      if (transition._id !== this._id)
        throw new Error();
      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
          if (node2 = group0[i] || group1[i]) {
            merge2[i] = node2;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Transition(merges, this._parents, this._name, this._id);
    }
    function start$1(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0)
          t = t.slice(0, i);
        return !t || t === "start";
      });
    }
    function onFunction(id2, name, listener) {
      var on0, on1, sit = start$1(name) ? init$1 : set$4;
      return function() {
        var schedule2 = sit(this, id2), on = schedule2.on;
        if (on !== on0)
          (on1 = (on0 = on).copy()).on(name, listener);
        schedule2.on = on1;
      };
    }
    function transition_on(name, listener) {
      var id2 = this._id;
      return arguments.length < 2 ? get$3(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
    }
    function removeFunction(id2) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition)
          if (+i !== id2)
            return;
        if (parent)
          parent.removeChild(this);
      };
    }
    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }
    function transition_select(select) {
      var name = this._name, id2 = this._id;
      if (typeof select !== "function")
        select = selector(select);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
          if ((node2 = group[i]) && (subnode = select.call(node2, node2.__data__, i, group))) {
            if ("__data__" in node2)
              subnode.__data__ = node2.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id2, i, subgroup, get$3(node2, id2));
          }
        }
      }
      return new Transition(subgroups, this._parents, name, id2);
    }
    function transition_selectAll(select) {
      var name = this._name, id2 = this._id;
      if (typeof select !== "function")
        select = selectorAll(select);
      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
          if (node2 = group[i]) {
            for (var children2 = select.call(node2, node2.__data__, i, group), child, inherit2 = get$3(node2, id2), k2 = 0, l = children2.length; k2 < l; ++k2) {
              if (child = children2[k2]) {
                schedule(child, name, id2, k2, children2, inherit2);
              }
            }
            subgroups.push(children2);
            parents.push(node2);
          }
        }
      }
      return new Transition(subgroups, parents, name, id2);
    }
    var Selection = selection.prototype.constructor;
    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }
    function styleNull(name, interpolate2) {
      var string00, string10, interpolate0;
      return function() {
        var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
      };
    }
    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }
    function styleConstant(name, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function styleFunction(name, interpolate2, value) {
      var string00, string10, interpolate0;
      return function() {
        var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
        if (value1 == null)
          string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function styleMaybeRemove(id2, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
      return function() {
        var schedule2 = set$4(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
        if (on !== on0 || listener0 !== listener)
          (on1 = (on0 = on).copy()).on(event, listener0 = listener);
        schedule2.on = on1;
      };
    }
    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
      return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
    }
    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }
    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
          t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }
    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2)
        return (key = this.tween(key)) && key._value;
      if (value == null)
        return this.tween(key, null);
      if (typeof value !== "function")
        throw new Error();
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }
    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }
    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }
    function transition_text(value) {
      return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
    }
    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }
    function textTween(value) {
      var t02, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
          t02 = (i0 = i) && textInterpolate(i);
        return t02;
      }
      tween._value = value;
      return tween;
    }
    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1)
        return (key = this.tween(key)) && key._value;
      if (value == null)
        return this.tween(key, null);
      if (typeof value !== "function")
        throw new Error();
      return this.tween(key, textTween(value));
    }
    function transition_transition() {
      var name = this._name, id0 = this._id, id1 = newId();
      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
          if (node2 = group[i]) {
            var inherit2 = get$3(node2, id0);
            schedule(node2, name, id1, i, group, {
              time: inherit2.time + inherit2.delay + inherit2.duration,
              delay: 0,
              duration: inherit2.duration,
              ease: inherit2.ease
            });
          }
        }
      }
      return new Transition(groups, this._parents, name, id1);
    }
    function transition_end() {
      var on0, on1, that = this, id2 = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = { value: reject }, end2 = { value: function() {
          if (--size === 0)
            resolve();
        } };
        that.each(function() {
          var schedule2 = set$4(this, id2), on = schedule2.on;
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end2);
          }
          schedule2.on = on1;
        });
        if (size === 0)
          resolve();
      });
    }
    var id$5 = 0;
    function Transition(groups, parents, name, id2) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id2;
    }
    function newId() {
      return ++id$5;
    }
    var selection_prototype = selection.prototype;
    Transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };
    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }
    var defaultTiming = {
      time: null,
      // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };
    function inherit$1(node2, id2) {
      var timing;
      while (!(timing = node2.__transition) || !(timing = timing[id2])) {
        if (!(node2 = node2.parentNode)) {
          throw new Error(`transition ${id2} not found`);
        }
      }
      return timing;
    }
    function selection_transition(name) {
      var id2, timing;
      if (name instanceof Transition) {
        id2 = name._id, name = name._name;
      } else {
        id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }
      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
          if (node2 = group[i]) {
            schedule(node2, name, id2, i, group, timing || inherit$1(node2, id2));
          }
        }
      }
      return new Transition(groups, this._parents, name, id2);
    }
    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;
    const pi$3 = Math.PI, tau$3 = 2 * pi$3, epsilon$1 = 1e-6, tauEpsilon = tau$3 - epsilon$1;
    function append$1(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }
    function appendRound$1(digits) {
      let d = Math.floor(digits);
      if (!(d >= 0))
        throw new Error(`invalid digits: ${digits}`);
      if (d > 15)
        return append$1;
      const k2 = 10 ** d;
      return function(strings) {
        this._ += strings[0];
        for (let i = 1, n = strings.length; i < n; ++i) {
          this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
        }
      };
    }
    class Path {
      constructor(digits) {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null;
        this._ = "";
        this._append = digits == null ? append$1 : appendRound$1(digits);
      }
      moveTo(x, y) {
        this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x, y) {
        this._append`L${this._x1 = +x},${this._y1 = +y}`;
      }
      quadraticCurveTo(x12, y12, x, y) {
        this._append`Q${+x12},${+y12},${this._x1 = +x},${this._y1 = +y}`;
      }
      bezierCurveTo(x12, y12, x2, y2, x, y) {
        this._append`C${+x12},${+y12},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
      }
      arcTo(x12, y12, x2, y2, r) {
        x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r = +r;
        if (r < 0)
          throw new Error(`negative radius: ${r}`);
        let x02 = this._x1, y02 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x02 - x12, y01 = y02 - y12, l01_2 = x01 * x01 + y01 * y01;
        if (this._x1 === null) {
          this._append`M${this._x1 = x12},${this._y1 = y12}`;
        } else if (!(l01_2 > epsilon$1))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
          this._append`L${this._x1 = x12},${this._y1 = y12}`;
        } else {
          let x20 = x2 - x02, y20 = y2 - y02, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon$1) {
            this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
          }
          this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
        }
      }
      arc(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        if (r < 0)
          throw new Error(`negative radius: ${r}`);
        let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x02 = x + dx, y02 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (this._x1 === null) {
          this._append`M${x02},${y02}`;
        } else if (Math.abs(this._x1 - x02) > epsilon$1 || Math.abs(this._y1 - y02) > epsilon$1) {
          this._append`L${x02},${y02}`;
        }
        if (!r)
          return;
        if (da < 0)
          da = da % tau$3 + tau$3;
        if (da > tauEpsilon) {
          this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x02},${this._y1 = y02}`;
        } else if (da > epsilon$1) {
          this._append`A${r},${r},0,${+(da >= pi$3)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
        }
      }
      rect(x, y, w, h) {
        this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
      }
      toString() {
        return this._;
      }
    }
    function pathRound(digits = 3) {
      return new Path(+digits);
    }
    function responseText(response) {
      if (!response.ok)
        throw new Error(response.status + " " + response.statusText);
      return response.text();
    }
    function text(input, init2) {
      return fetch(input, init2).then(responseText);
    }
    function dsvParse(parse2) {
      return function(input, init2, row) {
        if (arguments.length === 2 && typeof init2 === "function")
          row = init2, init2 = void 0;
        return text(input, init2).then(function(response) {
          return parse2(response, row);
        });
      };
    }
    function dsv(delimiter, input, init2, row) {
      if (arguments.length === 3 && typeof init2 === "function")
        row = init2, init2 = void 0;
      var format2 = dsvFormat(delimiter);
      return text(input, init2).then(function(response) {
        return format2.parse(response, row);
      });
    }
    var csv = dsvParse(csvParse);
    function responseJson(response) {
      if (!response.ok)
        throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205)
        return;
      return response.json();
    }
    function json(input, init2) {
      return fetch(input, init2).then(responseJson);
    }
    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
    }
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
        return null;
      var i, coefficient = x.slice(0, i);
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }
    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }
    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length, t = [], j = 0, g = grouping[0], length2 = 0;
        while (i > 0 && g > 0) {
          if (length2 + g + 1 > width)
            g = Math.max(1, width - length2);
          t.push(value.substring(i -= g, i + g));
          if ((length2 += g + 1) > width)
            break;
          g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
      };
    }
    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }
    var re$2 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
      if (!(match2 = re$2.exec(specifier)))
        throw new Error("invalid format: " + specifier);
      var match2;
      return new FormatSpecifier({
        fill: match2[1],
        align: match2[2],
        sign: match2[3],
        symbol: match2[4],
        zero: match2[5],
        width: match2[6],
        comma: match2[7],
        precision: match2[8] && match2[8].slice(1),
        trim: match2[9],
        type: match2[10]
      });
    }
    formatSpecifier.prototype = FormatSpecifier.prototype;
    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
      this.align = specifier.align === void 0 ? ">" : specifier.align + "";
      this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === void 0 ? void 0 : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === void 0 ? "" : specifier.type + "";
    }
    FormatSpecifier.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
    function formatTrim(s2) {
      out:
        for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
          switch (s2[i]) {
            case ".":
              i0 = i1 = i;
              break;
            case "0":
              if (i0 === 0)
                i0 = i;
              i1 = i;
              break;
            default:
              if (!+s2[i])
                break out;
              if (i0 > 0)
                i0 = 0;
              break;
          }
        }
      return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
    }
    var prefixExponent;
    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d)
        return x + "";
      var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
      return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
    }
    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d)
        return x + "";
      var coefficient = d[0], exponent2 = d[1];
      return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
    }
    const formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };
    function identity$5(x) {
      return x;
    }
    var map$2 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale$1(locale2) {
      var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$5 : formatGroup(map$2.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$5 : formatNumerals(map$2.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);
        var fill2 = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol2 = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
        if (type === "n")
          comma = true, type = "g";
        else if (!formatTypes[type])
          precision === void 0 && (precision = 12), trim = true, type = "g";
        if (zero2 || fill2 === "0" && align === "=")
          zero2 = true, fill2 = "0", align = "=";
        var prefix = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
        var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
        precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format2(value) {
          var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;
            var valueNegative = value < 0 || 1 / value < 0;
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
            if (trim)
              value = formatTrim(value);
            if (valueNegative && +value === 0 && sign2 !== "+")
              valueNegative = false;
            valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
                  valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }
          if (comma && !zero2)
            value = group(value, Infinity);
          var length2 = valuePrefix.length + value.length + valueSuffix.length, padding = length2 < width ? new Array(width - length2 + 1).join(fill2) : "";
          if (comma && zero2)
            value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
          switch (align) {
            case "<":
              value = valuePrefix + value + valueSuffix + padding;
              break;
            case "=":
              value = valuePrefix + padding + value + valueSuffix;
              break;
            case "^":
              value = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length2);
              break;
            default:
              value = padding + valuePrefix + value + valueSuffix;
              break;
          }
          return numerals(value);
        }
        format2.toString = function() {
          return specifier + "";
        };
        return format2;
      }
      function formatPrefix2(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
        return function(value2) {
          return f(k2 * value2) + prefix;
        };
      }
      return {
        format: newFormat,
        formatPrefix: formatPrefix2
      };
    }
    var locale$1;
    var format$1;
    var formatPrefix;
    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format$1 = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }
    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }
    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }
    function precisionRound(step, max2) {
      step = Math.abs(step), max2 = Math.abs(max2) - step;
      return Math.max(0, exponent(max2) - exponent(step)) + 1;
    }
    var epsilon = 1e-6;
    var epsilon2 = 1e-12;
    var pi$2 = Math.PI;
    var halfPi = pi$2 / 2;
    var quarterPi = pi$2 / 4;
    var tau$2 = pi$2 * 2;
    var degrees = 180 / pi$2;
    var radians = pi$2 / 180;
    var abs = Math.abs;
    var atan = Math.atan;
    var atan2 = Math.atan2;
    var cos$1 = Math.cos;
    var exp = Math.exp;
    var log$1 = Math.log;
    var pow$1 = Math.pow;
    var sin$1 = Math.sin;
    var sign = Math.sign || function(x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    };
    var sqrt$1 = Math.sqrt;
    var tan = Math.tan;
    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi$2 : Math.acos(x);
    }
    function asin(x) {
      return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
    }
    function noop$3() {
    }
    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }
    var streamObjectType = {
      Feature: function(object2, stream) {
        streamGeometry(object2.geometry, stream);
      },
      FeatureCollection: function(object2, stream) {
        var features = object2.features, i = -1, n = features.length;
        while (++i < n)
          streamGeometry(features[i].geometry, stream);
      }
    };
    var streamGeometryType = {
      Sphere: function(object2, stream) {
        stream.sphere();
      },
      Point: function(object2, stream) {
        object2 = object2.coordinates;
        stream.point(object2[0], object2[1], object2[2]);
      },
      MultiPoint: function(object2, stream) {
        var coordinates = object2.coordinates, i = -1, n = coordinates.length;
        while (++i < n)
          object2 = coordinates[i], stream.point(object2[0], object2[1], object2[2]);
      },
      LineString: function(object2, stream) {
        streamLine(object2.coordinates, stream, 0);
      },
      MultiLineString: function(object2, stream) {
        var coordinates = object2.coordinates, i = -1, n = coordinates.length;
        while (++i < n)
          streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object2, stream) {
        streamPolygon(object2.coordinates, stream);
      },
      MultiPolygon: function(object2, stream) {
        var coordinates = object2.coordinates, i = -1, n = coordinates.length;
        while (++i < n)
          streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object2, stream) {
        var geometries = object2.geometries, i = -1, n = geometries.length;
        while (++i < n)
          streamGeometry(geometries[i], stream);
      }
    };
    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n)
        coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }
    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n)
        streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }
    function geoStream(object2, stream) {
      if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
        streamObjectType[object2.type](object2, stream);
      } else {
        streamGeometry(object2, stream);
      }
    }
    function spherical(cartesian2) {
      return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
    }
    function cartesian(spherical2) {
      var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos$1(phi);
      return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }
    function cartesianDot(a2, b) {
      return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
    }
    function cartesianCross(a2, b) {
      return [a2[1] * b[2] - a2[2] * b[1], a2[2] * b[0] - a2[0] * b[2], a2[0] * b[1] - a2[1] * b[0]];
    }
    function cartesianAddInPlace(a2, b) {
      a2[0] += b[0], a2[1] += b[1], a2[2] += b[2];
    }
    function cartesianScale(vector, k2) {
      return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
    }
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$1(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }
    function compose(a2, b) {
      function compose2(x, y) {
        return x = a2(x, y), b(x[0], x[1]);
      }
      if (a2.invert && b.invert)
        compose2.invert = function(x, y) {
          return x = b.invert(x, y), x && a2.invert(x[0], x[1]);
        };
      return compose2;
    }
    function rotationIdentity(lambda, phi) {
      if (abs(lambda) > pi$2)
        lambda -= Math.round(lambda / tau$2) * tau$2;
      return [lambda, phi];
    }
    rotationIdentity.invert = rotationIdentity;
    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$2) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
    }
    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        lambda += deltaLambda;
        if (abs(lambda) > pi$2)
          lambda -= Math.round(lambda / tau$2) * tau$2;
        return [lambda, phi];
      };
    }
    function rotationLambda(deltaLambda) {
      var rotation2 = forwardRotationLambda(deltaLambda);
      rotation2.invert = forwardRotationLambda(-deltaLambda);
      return rotation2;
    }
    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$1(deltaPhi), sinDeltaPhi = sin$1(deltaPhi), cosDeltaGamma = cos$1(deltaGamma), sinDeltaGamma = sin$1(deltaGamma);
      function rotation2(lambda, phi) {
        var cosPhi = cos$1(phi), x = cos$1(lambda) * cosPhi, y = sin$1(lambda) * cosPhi, z = sin$1(phi), k2 = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2(y * cosDeltaGamma - k2 * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin(k2 * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }
      rotation2.invert = function(lambda, phi) {
        var cosPhi = cos$1(phi), x = cos$1(lambda) * cosPhi, y = sin$1(lambda) * cosPhi, z = sin$1(phi), k2 = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k2 * sinDeltaPhi),
          asin(k2 * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };
      return rotation2;
    }
    function rotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }
      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };
      return forward;
    }
    function circleStream(stream, radius2, delta, direction, t02, t12) {
      if (!delta)
        return;
      var cosRadius = cos$1(radius2), sinRadius = sin$1(radius2), step = direction * delta;
      if (t02 == null) {
        t02 = radius2 + direction * tau$2;
        t12 = radius2 - step / 2;
      } else {
        t02 = circleRadius(cosRadius, t02);
        t12 = circleRadius(cosRadius, t12);
        if (direction > 0 ? t02 < t12 : t02 > t12)
          t02 += direction * tau$2;
      }
      for (var point2, t = t02; direction > 0 ? t > t12 : t < t12; t -= step) {
        point2 = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
        stream.point(point2[0], point2[1]);
      }
    }
    function circleRadius(cosRadius, point2) {
      point2 = cartesian(point2), point2[0] -= cosRadius;
      cartesianNormalizeInPlace(point2);
      var radius2 = acos(-point2[1]);
      return ((-point2[2] < 0 ? -radius2 : radius2) + tau$2 - epsilon) % tau$2;
    }
    function clipBuffer() {
      var lines = [], line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$3,
        rejoin: function() {
          if (lines.length > 1)
            lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }
    function pointEqual(a2, b) {
      return abs(a2[0] - b[0]) < epsilon && abs(a2[1] - b[1]) < epsilon;
    }
    function Intersection(point2, points, other, entry) {
      this.x = point2;
      this.z = points;
      this.o = other;
      this.e = entry;
      this.v = false;
      this.n = this.p = null;
    }
    function clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream) {
      var subject = [], clip2 = [], i, n;
      segments.forEach(function(segment) {
        if ((n2 = segment.length - 1) <= 0)
          return;
        var n2, p0 = segment[0], p1 = segment[n2], x;
        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n2; ++i)
              stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          p1[0] += 2 * epsilon;
        }
        subject.push(x = new Intersection(p0, segment, null, true));
        clip2.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip2.push(x.o = new Intersection(p1, null, x, true));
      });
      if (!subject.length)
        return;
      clip2.sort(compareIntersection2);
      link(subject);
      link(clip2);
      for (i = 0, n = clip2.length; i < n; ++i) {
        clip2[i].e = startInside = !startInside;
      }
      var start2 = subject[0], points, point2;
      while (1) {
        var current = start2, isSubject = true;
        while (current.v)
          if ((current = current.n) === start2)
            return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i)
                stream.point((point2 = points[i])[0], point2[1]);
            } else {
              interpolate2(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i)
                stream.point((point2 = points[i])[0], point2[1]);
            } else {
              interpolate2(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }
    function link(array2) {
      if (!(n = array2.length))
        return;
      var n, i = 0, a2 = array2[0], b;
      while (++i < n) {
        a2.n = b = array2[i];
        b.p = a2;
        a2 = b;
      }
      a2.n = b = array2[0];
      b.p = a2;
    }
    function longitude(point2) {
      return abs(point2[0]) <= pi$2 ? point2[0] : sign(point2[0]) * ((abs(point2[0]) + pi$2) % tau$2 - pi$2);
    }
    function polygonContains(polygon, point2) {
      var lambda = longitude(point2), phi = point2[1], sinPhi = sin$1(phi), normal = [sin$1(lambda), -cos$1(lambda), 0], angle = 0, winding = 0;
      var sum = new Adder();
      if (sinPhi === 1)
        phi = halfPi + epsilon;
      else if (sinPhi === -1)
        phi = -halfPi - epsilon;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length))
          continue;
        var ring, m, point0 = ring[m - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin$1(phi0), cosPhi0 = cos$1(phi0);
        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin$1(phi1), cosPhi1 = cos$1(phi1), delta = lambda1 - lambda0, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi$2, k2 = sinPhi0 * sinPhi1;
          sum.add(atan2(k2 * sign2 * sin$1(absDelta), cosPhi0 * cosPhi1 + k2 * cos$1(absDelta)));
          angle += antimeridian ? delta + sign2 * tau$2 : delta;
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }
      return (angle < -epsilon || angle < epsilon && sum < -epsilon2) ^ winding & 1;
    }
    function clip(pointVisible, clipLine2, interpolate2, start2) {
      return function(sink) {
        var line = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
        var clip2 = {
          point: point2,
          lineStart,
          lineEnd,
          polygonStart: function() {
            clip2.point = pointRing;
            clip2.lineStart = ringStart;
            clip2.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip2.point = point2;
            clip2.lineStart = lineStart;
            clip2.lineEnd = lineEnd;
            segments = merge$1(segments);
            var startInside = polygonContains(polygon, start2);
            if (segments.length) {
              if (!polygonStarted)
                sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate2, sink);
            } else if (startInside) {
              if (!polygonStarted)
                sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate2(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted)
              sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate2(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };
        function point2(lambda, phi) {
          if (pointVisible(lambda, phi))
            sink.point(lambda, phi);
        }
        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }
        function lineStart() {
          clip2.point = pointLine;
          line.lineStart();
        }
        function lineEnd() {
          clip2.point = point2;
          line.lineEnd();
        }
        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }
        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }
        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();
          var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
          ring.pop();
          polygon.push(ring);
          ring = null;
          if (!n)
            return;
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted)
                sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i)
                sink.point((point3 = segment[i])[0], point3[1]);
              sink.lineEnd();
            }
            return;
          }
          if (n > 1 && clean & 2)
            ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
          segments.push(ringSegments.filter(validSegment));
        }
        return clip2;
      };
    }
    function validSegment(segment) {
      return segment.length > 1;
    }
    function compareIntersection(a2, b) {
      return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi - epsilon : halfPi - a2[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
    }
    const clipAntimeridian = clip(
      function() {
        return true;
      },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$2, -halfPi]
    );
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$2 : -pi$2, delta = abs(lambda1 - lambda0);
          if (abs(delta - pi$2) < epsilon) {
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$2) {
            if (abs(lambda0 - sign0) < epsilon)
              lambda0 -= sign0 * epsilon;
            if (abs(lambda1 - sign1) < epsilon)
              lambda1 -= sign1 * epsilon;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean;
        }
      };
    }
    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
      return abs(sinLambda0Lambda1) > epsilon ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1) - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
    }
    function clipAntimeridianInterpolate(from2, to, direction, stream) {
      var phi;
      if (from2 == null) {
        phi = direction * halfPi;
        stream.point(-pi$2, phi);
        stream.point(0, phi);
        stream.point(pi$2, phi);
        stream.point(pi$2, 0);
        stream.point(pi$2, -phi);
        stream.point(0, -phi);
        stream.point(-pi$2, -phi);
        stream.point(-pi$2, 0);
        stream.point(-pi$2, phi);
      } else if (abs(from2[0] - to[0]) > epsilon) {
        var lambda = from2[0] < to[0] ? pi$2 : -pi$2;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }
    function clipCircle(radius2) {
      var cr = cos$1(radius2), delta = 2 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
      function interpolate2(from2, to, direction, stream) {
        circleStream(stream, radius2, delta, direction, from2, to);
      }
      function visible(lambda, phi) {
        return cos$1(lambda) * cos$1(phi) > cr;
      }
      function clipLine2(stream) {
        var point0, c0, v0, v00, clean;
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi], point2, v = visible(lambda, phi), c2 = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi$2 : -pi$2), phi) : 0;
            if (!point0 && (v00 = v0 = v))
              stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              if (!(c2 & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c2;
          },
          lineEnd: function() {
            if (v0)
              stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | (v00 && v0) << 1;
          }
        };
      }
      function intersect(a2, b, two) {
        var pa = cartesian(a2), pb = cartesian(b);
        var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
        if (!determinant)
          return !two && a2;
        var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
        cartesianAddInPlace(A5, B2);
        var u = n1xn2, w = cartesianDot(A5, u), uu = cartesianDot(u, u), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
        if (t22 < 0)
          return;
        var t = sqrt$1(t22), q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A5);
        q = spherical(q);
        if (!two)
          return q;
        var lambda0 = a2[0], lambda1 = b[0], phi0 = a2[1], phi1 = b[1], z;
        if (lambda1 < lambda0)
          z = lambda0, lambda0 = lambda1, lambda1 = z;
        var delta2 = lambda1 - lambda0, polar = abs(delta2 - pi$2) < epsilon, meridian = polar || delta2 < epsilon;
        if (!polar && phi1 < phi0)
          z = phi0, phi0 = phi1, phi1 = z;
        if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi$2 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A5);
          return [q, spherical(q1)];
        }
      }
      function code(lambda, phi) {
        var r = smallRadius ? radius2 : pi$2 - radius2, code2 = 0;
        if (lambda < -r)
          code2 |= 1;
        else if (lambda > r)
          code2 |= 2;
        if (phi < -r)
          code2 |= 4;
        else if (phi > r)
          code2 |= 8;
        return code2;
      }
      return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius2] : [-pi$2, radius2 - pi$2]);
    }
    function clipLine(a2, b, x02, y02, x12, y12) {
      var ax = a2[0], ay = a2[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
      r = x02 - ax;
      if (!dx && r > 0)
        return;
      r /= dx;
      if (dx < 0) {
        if (r < t02)
          return;
        if (r < t12)
          t12 = r;
      } else if (dx > 0) {
        if (r > t12)
          return;
        if (r > t02)
          t02 = r;
      }
      r = x12 - ax;
      if (!dx && r < 0)
        return;
      r /= dx;
      if (dx < 0) {
        if (r > t12)
          return;
        if (r > t02)
          t02 = r;
      } else if (dx > 0) {
        if (r < t02)
          return;
        if (r < t12)
          t12 = r;
      }
      r = y02 - ay;
      if (!dy && r > 0)
        return;
      r /= dy;
      if (dy < 0) {
        if (r < t02)
          return;
        if (r < t12)
          t12 = r;
      } else if (dy > 0) {
        if (r > t12)
          return;
        if (r > t02)
          t02 = r;
      }
      r = y12 - ay;
      if (!dy && r < 0)
        return;
      r /= dy;
      if (dy < 0) {
        if (r > t12)
          return;
        if (r > t02)
          t02 = r;
      } else if (dy > 0) {
        if (r < t02)
          return;
        if (r < t12)
          t12 = r;
      }
      if (t02 > 0)
        a2[0] = ax + t02 * dx, a2[1] = ay + t02 * dy;
      if (t12 < 1)
        b[0] = ax + t12 * dx, b[1] = ay + t12 * dy;
      return true;
    }
    var clipMax = 1e9, clipMin = -clipMax;
    function clipRectangle(x02, y02, x12, y12) {
      function visible(x, y) {
        return x02 <= x && x <= x12 && y02 <= y && y <= y12;
      }
      function interpolate2(from2, to, direction, stream) {
        var a2 = 0, a1 = 0;
        if (from2 == null || (a2 = corner(from2, direction)) !== (a1 = corner(to, direction)) || comparePoint(from2, to) < 0 ^ direction > 0) {
          do
            stream.point(a2 === 0 || a2 === 3 ? x02 : x12, a2 > 1 ? y12 : y02);
          while ((a2 = (a2 + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }
      function corner(p, direction) {
        return abs(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
      }
      function compareIntersection2(a2, b) {
        return comparePoint(a2.x, b.x);
      }
      function comparePoint(a2, b) {
        var ca = corner(a2, 1), cb = corner(b, 1);
        return ca !== cb ? ca - cb : ca === 0 ? b[1] - a2[1] : ca === 1 ? a2[0] - b[0] : ca === 2 ? a2[1] - b[1] : b[0] - a2[0];
      }
      return function(stream) {
        var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
        var clipStream = {
          point: point2,
          lineStart,
          lineEnd,
          polygonStart,
          polygonEnd
        };
        function point2(x, y) {
          if (visible(x, y))
            activeStream.point(x, y);
        }
        function polygonInside() {
          var winding = 0;
          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring2 = polygon[i], j = 1, m = ring2.length, point3 = ring2[0], a0, a1, b0 = point3[0], b1 = point3[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point3 = ring2[j], b0 = point3[0], b1 = point3[1];
              if (a1 <= y12) {
                if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0))
                  ++winding;
              } else {
                if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0))
                  --winding;
              }
            }
          }
          return winding;
        }
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }
        function polygonEnd() {
          var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge$1(segments)).length;
          if (cleanInside || visible2) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate2(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible2) {
              clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }
        function lineStart() {
          clipStream.point = linePoint;
          if (polygon)
            polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_)
              bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point2;
          if (v_)
            activeStream.lineEnd();
        }
        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon)
            ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_)
              activeStream.point(x, y);
            else {
              var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a2, b, x02, y02, x12, y12)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a2[0], a2[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v)
                  activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }
        return clipStream;
      };
    }
    const identity$4 = (x) => x;
    var areaSum = new Adder(), areaRingSum = new Adder(), x00$2, y00$2, x0$3, y0$3;
    var areaStream = {
      point: noop$3,
      lineStart: noop$3,
      lineEnd: noop$3,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$3;
        areaSum.add(abs(areaRingSum));
        areaRingSum = new Adder();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum = new Adder();
        return area;
      }
    };
    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }
    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }
    function areaPoint(x, y) {
      areaRingSum.add(y0$3 * x - x0$3 * y);
      x0$3 = x, y0$3 = y;
    }
    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }
    const pathArea = areaStream;
    var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$3,
      lineEnd: noop$3,
      polygonStart: noop$3,
      polygonEnd: noop$3,
      result: function() {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };
    function boundsPoint(x, y) {
      if (x < x0$2)
        x0$2 = x;
      if (x > x1)
        x1 = x;
      if (y < y0$2)
        y0$2 = y;
      if (y > y1)
        y1 = y;
    }
    const boundsStream$1 = boundsStream;
    var X0 = 0, Y0 = 0, Z0 = 0, X1 = 0, Y1 = 0, Z1 = 0, X2 = 0, Y2 = 0, Z2 = 0, x00$1, y00$1, x0$1, y0$1;
    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
        X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };
    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }
    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }
    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x, y0$1 = y);
    }
    function centroidPointLine(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$1(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x, y0$1 = y);
    }
    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }
    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }
    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }
    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x, y00$1 = y0$1 = y);
    }
    function centroidPointRing(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$1(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      z = y0$1 * x - x0$1 * y;
      X2 += z * (x0$1 + x);
      Y2 += z * (y0$1 + y);
      Z2 += z * 3;
      centroidPoint(x0$1 = x, y0$1 = y);
    }
    const pathCentroid = centroidStream;
    function PathContext(context) {
      this._context = context;
    }
    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$2);
            break;
          }
        }
      },
      result: noop$3
    };
    var lengthSum = new Adder(), lengthRing, x00, y00, x0, y0;
    var lengthStream = {
      point: noop$3,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing)
          lengthPoint(x00, y00);
        lengthStream.point = noop$3;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length2 = +lengthSum;
        lengthSum = new Adder();
        return length2;
      }
    };
    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x, y00 = y0 = y;
    }
    function lengthPoint(x, y) {
      x0 -= x, y0 -= y;
      lengthSum.add(sqrt$1(x0 * x0 + y0 * y0));
      x0 = x, y0 = y;
    }
    const pathMeasure = lengthStream;
    let cacheDigits, cacheAppend, cacheRadius, cacheCircle;
    class PathString {
      constructor(digits) {
        this._append = digits == null ? append : appendRound(digits);
        this._radius = 4.5;
        this._ = "";
      }
      pointRadius(_) {
        this._radius = +_;
        return this;
      }
      polygonStart() {
        this._line = 0;
      }
      polygonEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line === 0)
          this._ += "Z";
        this._point = NaN;
      }
      point(x, y) {
        switch (this._point) {
          case 0: {
            this._append`M${x},${y}`;
            this._point = 1;
            break;
          }
          case 1: {
            this._append`L${x},${y}`;
            break;
          }
          default: {
            this._append`M${x},${y}`;
            if (this._radius !== cacheRadius || this._append !== cacheAppend) {
              const r = this._radius;
              const s2 = this._;
              this._ = "";
              this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
              cacheRadius = r;
              cacheAppend = this._append;
              cacheCircle = this._;
              this._ = s2;
            }
            this._ += cacheCircle;
            break;
          }
        }
      }
      result() {
        const result = this._;
        this._ = "";
        return result.length ? result : null;
      }
    }
    function append(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }
    function appendRound(digits) {
      const d = Math.floor(digits);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${digits}`);
      if (d > 15)
        return append;
      if (d !== cacheDigits) {
        const k2 = 10 ** d;
        cacheDigits = d;
        cacheAppend = function append2(strings) {
          let i = 1;
          this._ += strings[0];
          for (const j = strings.length; i < j; ++i) {
            this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
          }
        };
      }
      return cacheAppend;
    }
    function geoPath(projection2, context) {
      let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
      function path(object2) {
        if (object2) {
          if (typeof pointRadius === "function")
            contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object2, projectionStream(contextStream));
        }
        return contextStream.result();
      }
      path.area = function(object2) {
        geoStream(object2, projectionStream(pathArea));
        return pathArea.result();
      };
      path.measure = function(object2) {
        geoStream(object2, projectionStream(pathMeasure));
        return pathMeasure.result();
      };
      path.bounds = function(object2) {
        geoStream(object2, projectionStream(boundsStream$1));
        return boundsStream$1.result();
      };
      path.centroid = function(object2) {
        geoStream(object2, projectionStream(pathCentroid));
        return pathCentroid.result();
      };
      path.projection = function(_) {
        if (!arguments.length)
          return projection2;
        projectionStream = _ == null ? (projection2 = null, identity$4) : (projection2 = _).stream;
        return path;
      };
      path.context = function(_) {
        if (!arguments.length)
          return context;
        contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);
        if (typeof pointRadius !== "function")
          contextStream.pointRadius(pointRadius);
        return path;
      };
      path.pointRadius = function(_) {
        if (!arguments.length)
          return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };
      path.digits = function(_) {
        if (!arguments.length)
          return digits;
        if (_ == null)
          digits = null;
        else {
          const d = Math.floor(_);
          if (!(d >= 0))
            throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        if (context === null)
          contextStream = new PathString(digits);
        return path;
      };
      return path.projection(projection2).digits(digits).context(context);
    }
    function geoTransform(methods) {
      return {
        stream: transformer$2(methods)
      };
    }
    function transformer$2(methods) {
      return function(stream) {
        var s2 = new TransformStream();
        for (var key in methods)
          s2[key] = methods[key];
        s2.stream = stream;
        return s2;
      };
    }
    function TransformStream() {
    }
    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) {
        this.stream.point(x, y);
      },
      sphere: function() {
        this.stream.sphere();
      },
      lineStart: function() {
        this.stream.lineStart();
      },
      lineEnd: function() {
        this.stream.lineEnd();
      },
      polygonStart: function() {
        this.stream.polygonStart();
      },
      polygonEnd: function() {
        this.stream.polygonEnd();
      }
    };
    function fit(projection2, fitBounds, object2) {
      var clip2 = projection2.clipExtent && projection2.clipExtent();
      projection2.scale(150).translate([0, 0]);
      if (clip2 != null)
        projection2.clipExtent(null);
      geoStream(object2, projection2.stream(boundsStream$1));
      fitBounds(boundsStream$1.result());
      if (clip2 != null)
        projection2.clipExtent(clip2);
      return projection2;
    }
    function fitExtent(projection2, extent2, object2) {
      return fit(projection2, function(b) {
        var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
        projection2.scale(150 * k2).translate([x, y]);
      }, object2);
    }
    function fitSize(projection2, size, object2) {
      return fitExtent(projection2, [[0, 0], size], object2);
    }
    function fitWidth(projection2, width, object2) {
      return fit(projection2, function(b) {
        var w = +width, k2 = w / (b[1][0] - b[0][0]), x = (w - k2 * (b[1][0] + b[0][0])) / 2, y = -k2 * b[0][1];
        projection2.scale(150 * k2).translate([x, y]);
      }, object2);
    }
    function fitHeight(projection2, height, object2) {
      return fit(projection2, function(b) {
        var h = +height, k2 = h / (b[1][1] - b[0][1]), x = -k2 * b[0][0], y = (h - k2 * (b[1][1] + b[0][1])) / 2;
        projection2.scale(150 * k2).translate([x, y]);
      }, object2);
    }
    var maxDepth = 16, cosMinDistance = cos$1(30 * radians);
    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }
    function resampleNone(project) {
      return transformer$2({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }
    function resample$1(project, delta2) {
      function resampleLineTo(x02, y02, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
        var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a2 = a0 + a1, b = b0 + b1, c2 = c0 + c1, m = sqrt$1(a2 * a2 + b * b + c2 * c2), phi2 = asin(c2 /= m), lambda2 = abs(abs(c2) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a2), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
            resampleLineTo(x02, y02, lambda0, a0, b0, c0, x2, y2, lambda2, a2 /= m, b /= m, c2, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a2, b, c2, x12, y12, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x002, y002, a00, b00, c00, lambda0, x02, y02, a0, b0, c0;
        var resampleStream = {
          point: point2,
          lineStart,
          lineEnd,
          polygonStart: function() {
            stream.polygonStart();
            resampleStream.lineStart = ringStart;
          },
          polygonEnd: function() {
            stream.polygonEnd();
            resampleStream.lineStart = lineStart;
          }
        };
        function point2(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }
        function lineStart() {
          x02 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }
        function linePoint(lambda, phi) {
          var c2 = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x02, y02, lambda0, a0, b0, c0, x02 = p[0], y02 = p[1], lambda0 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth, stream);
          stream.point(x02, y02);
        }
        function lineEnd() {
          resampleStream.point = point2;
          stream.lineEnd();
        }
        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }
        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }
        function ringEnd() {
          resampleLineTo(x02, y02, lambda0, a0, b0, c0, x002, y002, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }
        return resampleStream;
      };
    }
    var transformRadians = transformer$2({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });
    function transformRotate(rotate) {
      return transformer$2({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }
    function scaleTranslate(k2, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx;
        y *= sy;
        return [dx + k2 * x, dy - k2 * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k2 * sx, (dy - y) / k2 * sy];
      };
      return transform;
    }
    function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
      if (!alpha)
        return scaleTranslate(k2, dx, dy, sx, sy);
      var cosAlpha = cos$1(alpha), sinAlpha = sin$1(alpha), a2 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
      function transform(x, y) {
        x *= sx;
        y *= sy;
        return [a2 * x - b * y + dx, dy - b * x - a2 * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }
    function projection(project) {
      return projectionMutator(function() {
        return project;
      })();
    }
    function projectionMutator(projectAt) {
      var project, k2 = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity$4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
      function projection2(point2) {
        return projectRotateTransform(point2[0] * radians, point2[1] * radians);
      }
      function invert(point2) {
        point2 = projectRotateTransform.invert(point2[0], point2[1]);
        return point2 && [point2[0] * degrees, point2[1] * degrees];
      }
      projection2.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };
      projection2.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
      };
      projection2.postclip = function(_) {
        return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset()) : postclip;
      };
      projection2.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };
      projection2.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity$4) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
      };
      projection2.scale = function(_) {
        return arguments.length ? (k2 = +_, recenter()) : k2;
      };
      projection2.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };
      projection2.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };
      projection2.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };
      projection2.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };
      projection2.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };
      projection2.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };
      projection2.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$1(delta2);
      };
      projection2.fitExtent = function(extent2, object2) {
        return fitExtent(projection2, extent2, object2);
      };
      projection2.fitSize = function(size, object2) {
        return fitSize(projection2, size, object2);
      };
      projection2.fitWidth = function(width, object2) {
        return fitWidth(projection2, width, object2);
      };
      projection2.fitHeight = function(height, object2) {
        return fitHeight(projection2, height, object2);
      };
      function recenter() {
        var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform = scaleTranslateRotate(k2, x - center2[0], y - center2[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }
      function reset() {
        cache = cacheStream = null;
        return projection2;
      }
      return function() {
        project = projectAt.apply(this, arguments);
        projection2.invert = project.invert && invert;
        return recenter();
      };
    }
    function conicProjection$1(projectAt) {
      var phi0 = 0, phi1 = pi$2 / 3, m = projectionMutator(projectAt), p = m(phi0, phi1);
      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };
      return p;
    }
    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$1(phi0);
      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
      }
      forward.invert = function(x, y) {
        return [x / cosPhi0, asin(y * cosPhi0)];
      };
      return forward;
    }
    function conicEqualAreaRaw(y02, y12) {
      var sy0 = sin$1(y02), n = (sy0 + sin$1(y12)) / 2;
      if (abs(n) < epsilon)
        return cylindricalEqualAreaRaw(y02);
      var c2 = 1 + sy0 * (2 * n - sy0), r0 = sqrt$1(c2) / n;
      function project(x, y) {
        var r = sqrt$1(c2 - 2 * n * sin$1(y)) / n;
        return [r * sin$1(x *= n), r0 - r * cos$1(x)];
      }
      project.invert = function(x, y) {
        var r0y = r0 - y, l = atan2(x, abs(r0y)) * sign(r0y);
        if (r0y * n < 0)
          l -= pi$2 * sign(x) * sign(r0y);
        return [l / n, asin((c2 - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };
      return project;
    }
    function geoConicEqualArea() {
      return conicProjection$1(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
    }
    function geoAlbers() {
      return geoConicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
    }
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) {
          var i = -1;
          while (++i < n)
            streams[i].point(x, y);
        },
        sphere: function() {
          var i = -1;
          while (++i < n)
            streams[i].sphere();
        },
        lineStart: function() {
          var i = -1;
          while (++i < n)
            streams[i].lineStart();
        },
        lineEnd: function() {
          var i = -1;
          while (++i < n)
            streams[i].lineEnd();
        },
        polygonStart: function() {
          var i = -1;
          while (++i < n)
            streams[i].polygonStart();
        },
        polygonEnd: function() {
          var i = -1;
          while (++i < n)
            streams[i].polygonEnd();
        }
      };
    }
    function geoAlbersUsa() {
      var cache, cacheStream, lower48 = geoAlbers(), lower48Point, alaska = geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point2, pointStream = { point: function(x, y) {
        point2 = [x, y];
      } };
      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point2 = null, (lower48Point.point(x, y), point2) || (alaskaPoint.point(x, y), point2) || (hawaiiPoint.point(x, y), point2);
      }
      albersUsa.invert = function(coordinates) {
        var k2 = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k2, y = (coordinates[1] - t[1]) / k2;
        return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
      };
      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };
      albersUsa.precision = function(_) {
        if (!arguments.length)
          return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };
      albersUsa.scale = function(_) {
        if (!arguments.length)
          return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };
      albersUsa.translate = function(_) {
        if (!arguments.length)
          return lower48.translate();
        var k2 = lower48.scale(), x = +_[0], y = +_[1];
        lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k2, y - 0.238 * k2], [x + 0.455 * k2, y + 0.238 * k2]]).stream(pointStream);
        alaskaPoint = alaska.translate([x - 0.307 * k2, y + 0.201 * k2]).clipExtent([[x - 0.425 * k2 + epsilon, y + 0.12 * k2 + epsilon], [x - 0.214 * k2 - epsilon, y + 0.234 * k2 - epsilon]]).stream(pointStream);
        hawaiiPoint = hawaii.translate([x - 0.205 * k2, y + 0.212 * k2]).clipExtent([[x - 0.214 * k2 + epsilon, y + 0.166 * k2 + epsilon], [x - 0.115 * k2 - epsilon, y + 0.234 * k2 - epsilon]]).stream(pointStream);
        return reset();
      };
      albersUsa.fitExtent = function(extent2, object2) {
        return fitExtent(albersUsa, extent2, object2);
      };
      albersUsa.fitSize = function(size, object2) {
        return fitSize(albersUsa, size, object2);
      };
      albersUsa.fitWidth = function(width, object2) {
        return fitWidth(albersUsa, width, object2);
      };
      albersUsa.fitHeight = function(height, object2) {
        return fitHeight(albersUsa, height, object2);
      };
      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }
      return albersUsa.scale(1070);
    }
    function azimuthalRaw(scale2) {
      return function(x, y) {
        var cx = cos$1(x), cy = cos$1(y), k2 = scale2(cx * cy);
        if (k2 === Infinity)
          return [2, 0];
        return [
          k2 * cy * sin$1(x),
          k2 * sin$1(y)
        ];
      };
    }
    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$1(x * x + y * y), c2 = angle(z), sc = sin$1(c2), cc = cos$1(c2);
        return [
          atan2(x * sc, z * cc),
          asin(z && y * sc / z)
        ];
      };
    }
    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$1(2 / (1 + cxcy));
    });
    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin(z / 2);
    });
    function geoAzimuthalEqualArea() {
      return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
    }
    var azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
      return (c2 = acos(c2)) && c2 / sin$1(c2);
    });
    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });
    function geoAzimuthalEquidistant() {
      return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
    }
    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan((halfPi + phi) / 2))];
    }
    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan(exp(y)) - halfPi];
    };
    function geoMercator() {
      return mercatorProjection(mercatorRaw).scale(961 / tau$2);
    }
    function mercatorProjection(project) {
      var m = projection(project), center2 = m.center, scale2 = m.scale, translate = m.translate, clipExtent = m.clipExtent, x02 = null, y02, x12, y12;
      m.scale = function(_) {
        return arguments.length ? (scale2(_), reclip()) : scale2();
      };
      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };
      m.center = function(_) {
        return arguments.length ? (center2(_), reclip()) : center2();
      };
      m.clipExtent = function(_) {
        return arguments.length ? (_ == null ? x02 = y02 = x12 = y12 = null : (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
      };
      function reclip() {
        var k2 = pi$2 * scale2(), t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x02 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x02), y02], [Math.min(t[0] + k2, x12), y12]] : [[x02, Math.max(t[1] - k2, y02)], [x12, Math.min(t[1] + k2, y12)]]);
      }
      return reclip();
    }
    function tany(y) {
      return tan((halfPi + y) / 2);
    }
    function conicConformalRaw(y02, y12) {
      var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : log$1(cy0 / cos$1(y12)) / log$1(tany(y12) / tany(y02)), f = cy0 * pow$1(tany(y02), n) / n;
      if (!n)
        return mercatorRaw;
      function project(x, y) {
        if (f > 0) {
          if (y < -halfPi + epsilon)
            y = -halfPi + epsilon;
        } else {
          if (y > halfPi - epsilon)
            y = halfPi - epsilon;
        }
        var r = f / pow$1(tany(y), n);
        return [r * sin$1(n * x), f - r * cos$1(n * x)];
      }
      project.invert = function(x, y) {
        var fy = f - y, r = sign(n) * sqrt$1(x * x + fy * fy), l = atan2(x, abs(fy)) * sign(fy);
        if (fy * n < 0)
          l -= pi$2 * sign(x) * sign(fy);
        return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi];
      };
      return project;
    }
    function geoConicConformal() {
      return conicProjection$1(conicConformalRaw).scale(109.5).parallels([30, 30]);
    }
    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }
    equirectangularRaw.invert = equirectangularRaw;
    function geoEquirectangular() {
      return projection(equirectangularRaw).scale(152.63);
    }
    function conicEquidistantRaw(y02, y12) {
      var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : (cy0 - cos$1(y12)) / (y12 - y02), g = cy0 / n + y02;
      if (abs(n) < epsilon)
        return equirectangularRaw;
      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$1(nx), g - gy * cos$1(nx)];
      }
      project.invert = function(x, y) {
        var gy = g - y, l = atan2(x, abs(gy)) * sign(gy);
        if (gy * n < 0)
          l -= pi$2 * sign(x) * sign(gy);
        return [l / n, g - sign(n) * sqrt$1(x * x + gy * gy)];
      };
      return project;
    }
    function geoConicEquidistant() {
      return conicProjection$1(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
    }
    var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt$1(3) / 2, iterations = 12;
    function equalEarthRaw(lambda, phi) {
      var l = asin(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }
    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs(delta) < epsilon2)
          break;
      }
      return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
        asin(sin$1(l) / M)
      ];
    };
    function geoEqualEarth() {
      return projection(equalEarthRaw).scale(177.158);
    }
    function gnomonicRaw(x, y) {
      var cy = cos$1(y), k2 = cos$1(x) * cy;
      return [cy * sin$1(x) / k2, sin$1(y) / k2];
    }
    gnomonicRaw.invert = azimuthalInvert(atan);
    function geoGnomonic() {
      return projection(gnomonicRaw).scale(144.049).clipAngle(60);
    }
    function orthographicRaw(x, y) {
      return [cos$1(y) * sin$1(x), sin$1(y)];
    }
    orthographicRaw.invert = azimuthalInvert(asin);
    function geoOrthographic() {
      return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
    }
    function stereographicRaw(x, y) {
      var cy = cos$1(y), k2 = 1 + cos$1(x) * cy;
      return [cy * sin$1(x) / k2, sin$1(y) / k2];
    }
    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });
    function geoStereographic() {
      return projection(stereographicRaw).scale(250).clipAngle(142);
    }
    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan((halfPi + phi) / 2)), -lambda];
    }
    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan(exp(x)) - halfPi];
    };
    function geoTransverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw), center2 = m.center, rotate = m.rotate;
      m.center = function(_) {
        return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);
      };
      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };
      return rotate([0, 0, 90]).scale(159.155);
    }
    function initRange(domain, range2) {
      switch (arguments.length) {
        case 0:
          break;
        case 1:
          this.range(domain);
          break;
        default:
          this.range(range2).domain(domain);
          break;
      }
      return this;
    }
    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0:
          break;
        case 1: {
          if (typeof domain === "function")
            this.interpolator(domain);
          else
            this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function")
            this.interpolator(interpolator);
          else
            this.range(interpolator);
          break;
        }
      }
      return this;
    }
    const implicit = Symbol("implicit");
    function ordinal() {
      var index = new InternMap(), domain = [], range2 = [], unknown = implicit;
      function scale2(d) {
        let i = index.get(d);
        if (i === void 0) {
          if (unknown !== implicit)
            return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range2[i % range2.length];
      }
      scale2.domain = function(_) {
        if (!arguments.length)
          return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value))
            continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale2;
      };
      scale2.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), scale2) : range2.slice();
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      scale2.copy = function() {
        return ordinal(domain, range2).unknown(unknown);
      };
      initRange.apply(scale2, arguments);
      return scale2;
    }
    function band() {
      var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange2 = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
      delete scale2.unknown;
      function rescale() {
        var n = domain().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
        step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round2)
          step = Math.floor(step);
        start2 += (stop - start2 - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round2)
          start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
        var values2 = range(n).map(function(i) {
          return start2 + step * i;
        });
        return ordinalRange2(reverse2 ? values2.reverse() : values2);
      }
      scale2.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };
      scale2.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };
      scale2.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
      };
      scale2.bandwidth = function() {
        return bandwidth;
      };
      scale2.step = function() {
        return step;
      };
      scale2.round = function(_) {
        return arguments.length ? (round2 = !!_, rescale()) : round2;
      };
      scale2.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };
      scale2.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };
      scale2.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };
      scale2.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };
      scale2.copy = function() {
        return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
      };
      return initRange.apply(rescale(), arguments);
    }
    function pointish(scale2) {
      var copy2 = scale2.copy;
      scale2.padding = scale2.paddingOuter;
      delete scale2.paddingInner;
      delete scale2.paddingOuter;
      scale2.copy = function() {
        return pointish(copy2());
      };
      return scale2;
    }
    function point() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }
    function constants(x) {
      return function() {
        return x;
      };
    }
    function number$1(x) {
      return +x;
    }
    var unit$2 = [0, 1];
    function identity$3(x) {
      return x;
    }
    function normalize$3(a2, b) {
      return (b -= a2 = +a2) ? function(x) {
        return (x - a2) / b;
      } : constants(isNaN(b) ? NaN : 0.5);
    }
    function clamper(a2, b) {
      var t;
      if (a2 > b)
        t = a2, a2 = b, b = t;
      return function(x) {
        return Math.max(a2, Math.min(b, x));
      };
    }
    function bimap(domain, range2, interpolate2) {
      var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
      if (d1 < d0)
        d0 = normalize$3(d1, d0), r0 = interpolate2(r1, r0);
      else
        d0 = normalize$3(d0, d1), r0 = interpolate2(r0, r1);
      return function(x) {
        return r0(d0(x));
      };
    }
    function polymap(domain, range2, interpolate2) {
      var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range2 = range2.slice().reverse();
      }
      while (++i < j) {
        d[i] = normalize$3(domain[i], domain[i + 1]);
        r[i] = interpolate2(range2[i], range2[i + 1]);
      }
      return function(x) {
        var i2 = bisect(domain, x, 1, j) - 1;
        return r[i2](d[i2](x));
      };
    }
    function copy$1(source, target) {
      return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
    }
    function transformer$1() {
      var domain = unit$2, range2 = unit$2, interpolate2 = interpolate$1, transform, untransform, unknown, clamp = identity$3, piecewise2, output, input;
      function rescale() {
        var n = Math.min(domain.length, range2.length);
        if (clamp !== identity$3)
          clamp = clamper(domain[0], domain[n - 1]);
        piecewise2 = n > 2 ? polymap : bimap;
        output = input = null;
        return scale2;
      }
      function scale2(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise2(domain.map(transform), range2, interpolate2)))(transform(clamp(x)));
      }
      scale2.invert = function(y) {
        return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform), interpolateNumber)))(y)));
      };
      scale2.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };
      scale2.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
      };
      scale2.rangeRound = function(_) {
        return range2 = Array.from(_), interpolate2 = interpolateRound, rescale();
      };
      scale2.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
      };
      scale2.interpolate = function(_) {
        return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }
    function continuous() {
      return transformer$1()(identity$3, identity$3);
    }
    function tickFormat(start2, stop, count, specifier) {
      var step = tickStep(start2, stop, count), precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start2), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
            specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop)))))
            specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
            specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format$1(specifier);
    }
    function linearish(scale2) {
      var domain = scale2.domain;
      scale2.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };
      scale2.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };
      scale2.nice = function(count) {
        if (count == null)
          count = 10;
        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start2 = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;
        if (stop < start2) {
          step = start2, start2 = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        while (maxIter-- > 0) {
          step = tickIncrement(start2, stop, count);
          if (step === prestep) {
            d[i0] = start2;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start2 = Math.floor(start2 / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start2 = Math.ceil(start2 * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }
        return scale2;
      };
      return scale2;
    }
    function linear() {
      var scale2 = continuous();
      scale2.copy = function() {
        return copy$1(scale2, linear());
      };
      initRange.apply(scale2, arguments);
      return linearish(scale2);
    }
    function identity$2(domain) {
      var unknown;
      function scale2(x) {
        return x == null || isNaN(x = +x) ? unknown : x;
      }
      scale2.invert = scale2;
      scale2.domain = scale2.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), scale2) : domain.slice();
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      scale2.copy = function() {
        return identity$2(domain).unknown(unknown);
      };
      domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
      return linearish(scale2);
    }
    function nice(domain, interval2) {
      domain = domain.slice();
      var i0 = 0, i1 = domain.length - 1, x02 = domain[i0], x12 = domain[i1], t;
      if (x12 < x02) {
        t = i0, i0 = i1, i1 = t;
        t = x02, x02 = x12, x12 = t;
      }
      domain[i0] = interval2.floor(x02);
      domain[i1] = interval2.ceil(x12);
      return domain;
    }
    function transformLog$2(x) {
      return Math.log(x);
    }
    function transformExp(x) {
      return Math.exp(x);
    }
    function transformLogn(x) {
      return -Math.log(-x);
    }
    function transformExpn(x) {
      return -Math.exp(-x);
    }
    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }
    function powp(base) {
      return base === 10 ? pow10 : base === Math.E ? Math.exp : (x) => Math.pow(base, x);
    }
    function logp(base) {
      return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x) => Math.log(x) / base);
    }
    function reflect(f) {
      return (x, k2) => -f(-x, k2);
    }
    function loggish(transform) {
      const scale2 = transform(transformLog$2, transformExp);
      const domain = scale2.domain;
      let base = 10;
      let logs;
      let pows;
      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog$2, transformExp);
        }
        return scale2;
      }
      scale2.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };
      scale2.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };
      scale2.ticks = (count) => {
        const d = domain();
        let u = d[0];
        let v = d[d.length - 1];
        const r = v < u;
        if (r)
          [u, v] = [v, u];
        let i = logs(u);
        let j = logs(v);
        let k2;
        let t;
        const n = count == null ? 10 : +count;
        let z = [];
        if (!(base % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u > 0)
            for (; i <= j; ++i) {
              for (k2 = 1; k2 < base; ++k2) {
                t = i < 0 ? k2 / pows(-i) : k2 * pows(i);
                if (t < u)
                  continue;
                if (t > v)
                  break;
                z.push(t);
              }
            }
          else
            for (; i <= j; ++i) {
              for (k2 = base - 1; k2 >= 1; --k2) {
                t = i > 0 ? k2 / pows(-i) : k2 * pows(i);
                if (t < u)
                  continue;
                if (t > v)
                  break;
                z.push(t);
              }
            }
          if (z.length * 2 < n)
            z = ticks(u, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }
        return r ? z.reverse() : z;
      };
      scale2.tickFormat = (count, specifier) => {
        if (count == null)
          count = 10;
        if (specifier == null)
          specifier = base === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
          if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
            specifier.trim = true;
          specifier = format$1(specifier);
        }
        if (count === Infinity)
          return specifier;
        const k2 = Math.max(1, base * count / scale2.ticks().length);
        return (d) => {
          let i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5)
            i *= base;
          return i <= k2 ? specifier(d) : "";
        };
      };
      scale2.nice = () => {
        return domain(nice(domain(), {
          floor: (x) => pows(Math.floor(logs(x))),
          ceil: (x) => pows(Math.ceil(logs(x)))
        }));
      };
      return scale2;
    }
    function log() {
      const scale2 = loggish(transformer$1()).domain([1, 10]);
      scale2.copy = () => copy$1(scale2, log()).base(scale2.base());
      initRange.apply(scale2, arguments);
      return scale2;
    }
    function transformSymlog$2(c2) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c2));
      };
    }
    function transformSymexp(c2) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c2;
      };
    }
    function symlogish(transform) {
      var c2 = 1, scale2 = transform(transformSymlog$2(c2), transformSymexp(c2));
      scale2.constant = function(_) {
        return arguments.length ? transform(transformSymlog$2(c2 = +_), transformSymexp(c2)) : c2;
      };
      return linearish(scale2);
    }
    function symlog() {
      var scale2 = symlogish(transformer$1());
      scale2.copy = function() {
        return copy$1(scale2, symlog()).constant(scale2.constant());
      };
      return initRange.apply(scale2, arguments);
    }
    function transformPow$2(exponent2) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent2) : Math.pow(x, exponent2);
      };
    }
    function transformSqrt$2(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }
    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }
    function powish(transform) {
      var scale2 = transform(identity$3, identity$3), exponent2 = 1;
      function rescale() {
        return exponent2 === 1 ? transform(identity$3, identity$3) : exponent2 === 0.5 ? transform(transformSqrt$2, transformSquare) : transform(transformPow$2(exponent2), transformPow$2(1 / exponent2));
      }
      scale2.exponent = function(_) {
        return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
      };
      return linearish(scale2);
    }
    function pow() {
      var scale2 = powish(transformer$1());
      scale2.copy = function() {
        return copy$1(scale2, pow()).exponent(scale2.exponent());
      };
      initRange.apply(scale2, arguments);
      return scale2;
    }
    function quantile() {
      var domain = [], range2 = [], thresholds = [], unknown;
      function rescale() {
        var i = 0, n = Math.max(1, range2.length);
        thresholds = new Array(n - 1);
        while (++i < n)
          thresholds[i - 1] = quantileSorted(domain, i / n);
        return scale2;
      }
      function scale2(x) {
        return x == null || isNaN(x = +x) ? unknown : range2[bisect(thresholds, x)];
      }
      scale2.invertExtent = function(y) {
        var i = range2.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };
      scale2.domain = function(_) {
        if (!arguments.length)
          return domain.slice();
        domain = [];
        for (let d of _)
          if (d != null && !isNaN(d = +d))
            domain.push(d);
        domain.sort(ascending$1);
        return rescale();
      };
      scale2.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      scale2.quantiles = function() {
        return thresholds.slice();
      };
      scale2.copy = function() {
        return quantile().domain(domain).range(range2).unknown(unknown);
      };
      return initRange.apply(scale2, arguments);
    }
    function threshold() {
      var domain = [0.5], range2 = [0, 1], unknown, n = 1;
      function scale2(x) {
        return x != null && x <= x ? range2[bisect(domain, x, 0, n)] : unknown;
      }
      scale2.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range2.length - 1), scale2) : domain.slice();
      };
      scale2.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), n = Math.min(domain.length, range2.length - 1), scale2) : range2.slice();
      };
      scale2.invertExtent = function(y) {
        var i = range2.indexOf(y);
        return [domain[i - 1], domain[i]];
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      scale2.copy = function() {
        return threshold().domain(domain).range(range2).unknown(unknown);
      };
      return initRange.apply(scale2, arguments);
    }
    const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
    function timeInterval(floori, offseti, count, field) {
      function interval2(date2) {
        return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
      }
      interval2.floor = (date2) => {
        return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
      };
      interval2.ceil = (date2) => {
        return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
      };
      interval2.round = (date2) => {
        const d0 = interval2(date2), d1 = interval2.ceil(date2);
        return date2 - d0 < d1 - date2 ? d0 : d1;
      };
      interval2.offset = (date2, step) => {
        return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
      };
      interval2.range = (start2, stop, step) => {
        const range2 = [];
        start2 = interval2.ceil(start2);
        step = step == null ? 1 : Math.floor(step);
        if (!(start2 < stop) || !(step > 0))
          return range2;
        let previous;
        do
          range2.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
        while (previous < start2 && start2 < stop);
        return range2;
      };
      interval2.filter = (test2) => {
        return timeInterval((date2) => {
          if (date2 >= date2)
            while (floori(date2), !test2(date2))
              date2.setTime(date2 - 1);
        }, (date2, step) => {
          if (date2 >= date2) {
            if (step < 0)
              while (++step <= 0) {
                while (offseti(date2, -1), !test2(date2)) {
                }
              }
            else
              while (--step >= 0) {
                while (offseti(date2, 1), !test2(date2)) {
                }
              }
          }
        });
      };
      if (count) {
        interval2.count = (start2, end2) => {
          t0.setTime(+start2), t1.setTime(+end2);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };
        interval2.every = (step) => {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? (d) => field(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
        };
      }
      return interval2;
    }
    const millisecond = timeInterval(() => {
    }, (date2, step) => {
      date2.setTime(+date2 + step);
    }, (start2, end2) => {
      return end2 - start2;
    });
    millisecond.every = (k2) => {
      k2 = Math.floor(k2);
      if (!isFinite(k2) || !(k2 > 0))
        return null;
      if (!(k2 > 1))
        return millisecond;
      return timeInterval((date2) => {
        date2.setTime(Math.floor(date2 / k2) * k2);
      }, (date2, step) => {
        date2.setTime(+date2 + step * k2);
      }, (start2, end2) => {
        return (end2 - start2) / k2;
      });
    };
    millisecond.range;
    const durationSecond = 1e3;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;
    const second = timeInterval((date2) => {
      date2.setTime(date2 - date2.getMilliseconds());
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationSecond);
    }, (start2, end2) => {
      return (end2 - start2) / durationSecond;
    }, (date2) => {
      return date2.getUTCSeconds();
    });
    second.range;
    const timeMinute = timeInterval((date2) => {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationMinute);
    }, (start2, end2) => {
      return (end2 - start2) / durationMinute;
    }, (date2) => {
      return date2.getMinutes();
    });
    timeMinute.range;
    const utcMinute = timeInterval((date2) => {
      date2.setUTCSeconds(0, 0);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationMinute);
    }, (start2, end2) => {
      return (end2 - start2) / durationMinute;
    }, (date2) => {
      return date2.getUTCMinutes();
    });
    utcMinute.range;
    const timeHour = timeInterval((date2) => {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationHour);
    }, (start2, end2) => {
      return (end2 - start2) / durationHour;
    }, (date2) => {
      return date2.getHours();
    });
    timeHour.range;
    const utcHour = timeInterval((date2) => {
      date2.setUTCMinutes(0, 0, 0);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationHour);
    }, (start2, end2) => {
      return (end2 - start2) / durationHour;
    }, (date2) => {
      return date2.getUTCHours();
    });
    utcHour.range;
    const timeDay = timeInterval(
      (date2) => date2.setHours(0, 0, 0, 0),
      (date2, step) => date2.setDate(date2.getDate() + step),
      (start2, end2) => (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
      (date2) => date2.getDate() - 1
    );
    timeDay.range;
    const utcDay = timeInterval((date2) => {
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, (start2, end2) => {
      return (end2 - start2) / durationDay;
    }, (date2) => {
      return date2.getUTCDate() - 1;
    });
    utcDay.range;
    const unixDay = timeInterval((date2) => {
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, (start2, end2) => {
      return (end2 - start2) / durationDay;
    }, (date2) => {
      return Math.floor(date2 / durationDay);
    });
    unixDay.range;
    function timeWeekday(i) {
      return timeInterval((date2) => {
        date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
        date2.setHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setDate(date2.getDate() + step * 7);
      }, (start2, end2) => {
        return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }
    const timeSunday = timeWeekday(0);
    const timeMonday = timeWeekday(1);
    const timeTuesday = timeWeekday(2);
    const timeWednesday = timeWeekday(3);
    const timeThursday = timeWeekday(4);
    const timeFriday = timeWeekday(5);
    const timeSaturday = timeWeekday(6);
    timeSunday.range;
    timeMonday.range;
    timeTuesday.range;
    timeWednesday.range;
    timeThursday.range;
    timeFriday.range;
    timeSaturday.range;
    function utcWeekday(i) {
      return timeInterval((date2) => {
        date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
        date2.setUTCHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setUTCDate(date2.getUTCDate() + step * 7);
      }, (start2, end2) => {
        return (end2 - start2) / durationWeek;
      });
    }
    const utcSunday = utcWeekday(0);
    const utcMonday = utcWeekday(1);
    const utcTuesday = utcWeekday(2);
    const utcWednesday = utcWeekday(3);
    const utcThursday = utcWeekday(4);
    const utcFriday = utcWeekday(5);
    const utcSaturday = utcWeekday(6);
    utcSunday.range;
    utcMonday.range;
    utcTuesday.range;
    utcWednesday.range;
    utcThursday.range;
    utcFriday.range;
    utcSaturday.range;
    const timeMonth = timeInterval((date2) => {
      date2.setDate(1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setMonth(date2.getMonth() + step);
    }, (start2, end2) => {
      return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
    }, (date2) => {
      return date2.getMonth();
    });
    timeMonth.range;
    const utcMonth = timeInterval((date2) => {
      date2.setUTCDate(1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCMonth(date2.getUTCMonth() + step);
    }, (start2, end2) => {
      return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
    }, (date2) => {
      return date2.getUTCMonth();
    });
    utcMonth.range;
    const timeYear = timeInterval((date2) => {
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setFullYear(date2.getFullYear() + step);
    }, (start2, end2) => {
      return end2.getFullYear() - start2.getFullYear();
    }, (date2) => {
      return date2.getFullYear();
    });
    timeYear.every = (k2) => {
      return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
        date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
        date2.setMonth(0, 1);
        date2.setHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setFullYear(date2.getFullYear() + step * k2);
      });
    };
    timeYear.range;
    const utcYear = timeInterval((date2) => {
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step);
    }, (start2, end2) => {
      return end2.getUTCFullYear() - start2.getUTCFullYear();
    }, (date2) => {
      return date2.getUTCFullYear();
    });
    utcYear.every = (k2) => {
      return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
        date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
        date2.setUTCMonth(0, 1);
        date2.setUTCHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
      });
    };
    utcYear.range;
    function ticker(year, month, week, day, hour, minute) {
      const tickIntervals = [
        [second, 1, durationSecond],
        [second, 5, 5 * durationSecond],
        [second, 15, 15 * durationSecond],
        [second, 30, 30 * durationSecond],
        [minute, 1, durationMinute],
        [minute, 5, 5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [hour, 1, durationHour],
        [hour, 3, 3 * durationHour],
        [hour, 6, 6 * durationHour],
        [hour, 12, 12 * durationHour],
        [day, 1, durationDay],
        [day, 2, 2 * durationDay],
        [week, 1, durationWeek],
        [month, 1, durationMonth],
        [month, 3, 3 * durationMonth],
        [year, 1, durationYear]
      ];
      function ticks2(start2, stop, count) {
        const reverse2 = stop < start2;
        if (reverse2)
          [start2, stop] = [stop, start2];
        const interval2 = count && typeof count.range === "function" ? count : tickInterval(start2, stop, count);
        const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
        return reverse2 ? ticks3.reverse() : ticks3;
      }
      function tickInterval(start2, stop, count) {
        const target = Math.abs(stop - start2) / count;
        const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
        if (i === tickIntervals.length)
          return year.every(tickStep(start2 / durationYear, stop / durationYear, count));
        if (i === 0)
          return millisecond.every(Math.max(tickStep(start2, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }
      return [ticks2, tickInterval];
    }
    const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
    const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date2.setFullYear(d.y);
        return date2;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }
    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date2.setUTCFullYear(d.y);
        return date2;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }
    function newDate(y, m, d) {
      return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
    }
    function formatLocale(locale2) {
      var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
      var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear$1,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };
      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };
      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);
      function newFormat(specifier, formats2) {
        return function(date2) {
          var string2 = [], i = -1, j = 0, n = specifier.length, c2, pad2, format2;
          if (!(date2 instanceof Date))
            date2 = /* @__PURE__ */ new Date(+date2);
          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string2.push(specifier.slice(j, i));
              if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null)
                c2 = specifier.charAt(++i);
              else
                pad2 = c2 === "e" ? " " : "0";
              if (format2 = formats2[c2])
                c2 = format2(date2, pad2);
              string2.push(c2);
              j = i + 1;
            }
          }
          string2.push(specifier.slice(j, i));
          return string2.join("");
        };
      }
      function newParse(specifier, Z) {
        return function(string2) {
          var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += "", 0), week, day;
          if (i != string2.length)
            return null;
          if ("Q" in d)
            return new Date(d.Q);
          if ("s" in d)
            return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
          if (Z && !("Z" in d))
            d.Z = 0;
          if ("p" in d)
            d.H = d.H % 12 + d.p * 12;
          if (d.m === void 0)
            d.m = "q" in d ? d.q : 0;
          if ("V" in d) {
            if (d.V < 1 || d.V > 53)
              return null;
            if (!("w" in d))
              d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
              week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
              week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
              week = timeDay.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d))
              d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }
          return localDate(d);
        };
      }
      function parseSpecifier(d, specifier, string2, j) {
        var i = 0, n = specifier.length, m = string2.length, c2, parse2;
        while (i < n) {
          if (j >= m)
            return -1;
          c2 = specifier.charCodeAt(i++);
          if (c2 === 37) {
            c2 = specifier.charAt(i++);
            parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
            if (!parse2 || (j = parse2(d, string2, j)) < 0)
              return -1;
          } else if (c2 != string2.charCodeAt(j++)) {
            return -1;
          }
        }
        return j;
      }
      function parsePeriod(d, string2, i) {
        var n = periodRe.exec(string2.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseShortWeekday(d, string2, i) {
        var n = shortWeekdayRe.exec(string2.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseWeekday(d, string2, i) {
        var n = weekdayRe.exec(string2.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseShortMonth(d, string2, i) {
        var n = shortMonthRe.exec(string2.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseMonth(d, string2, i) {
        var n = monthRe.exec(string2.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseLocaleDateTime(d, string2, i) {
        return parseSpecifier(d, locale_dateTime, string2, i);
      }
      function parseLocaleDate(d, string2, i) {
        return parseSpecifier(d, locale_date, string2, i);
      }
      function parseLocaleTime(d, string2, i) {
        return parseSpecifier(d, locale_time, string2, i);
      }
      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }
      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }
      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }
      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }
      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }
      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }
      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }
      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }
      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }
      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }
      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }
      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }
      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() {
            return specifier;
          };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() {
            return specifier;
          };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() {
            return specifier;
          };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() {
            return specifier;
          };
          return p;
        }
      };
    }
    var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
    function pad$1(value, fill2, width) {
      var sign2 = value < 0 ? "-" : "", string2 = (sign2 ? -value : value) + "", length2 = string2.length;
      return sign2 + (length2 < width ? new Array(width - length2 + 1).join(fill2) + string2 : string2);
    }
    function requote(s2) {
      return s2.replace(requoteRe, "\\$&");
    }
    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }
    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }
    function parseWeekdayNumberSunday(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }
    function parseWeekdayNumberMonday(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberSunday(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberISO(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberMonday(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }
    function parseFullYear(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }
    function parseYear(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
    }
    function parseZone(d, string2, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }
    function parseQuarter(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }
    function parseMonthNumber(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }
    function parseDayOfMonth(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }
    function parseDayOfYear(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }
    function parseHour24(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }
    function parseMinutes(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }
    function parseSeconds(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }
    function parseMilliseconds(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }
    function parseMicroseconds(d, string2, i) {
      var n = numberRe.exec(string2.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
    }
    function parseLiteralPercent(d, string2, i) {
      var n = percentRe.exec(string2.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }
    function parseUnixTimestamp(d, string2, i) {
      var n = numberRe.exec(string2.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }
    function parseUnixTimestampSeconds(d, string2, i) {
      var n = numberRe.exec(string2.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }
    function formatDayOfMonth(d, p) {
      return pad$1(d.getDate(), p, 2);
    }
    function formatHour24(d, p) {
      return pad$1(d.getHours(), p, 2);
    }
    function formatHour12(d, p) {
      return pad$1(d.getHours() % 12 || 12, p, 2);
    }
    function formatDayOfYear(d, p) {
      return pad$1(1 + timeDay.count(timeYear(d), d), p, 3);
    }
    function formatMilliseconds(d, p) {
      return pad$1(d.getMilliseconds(), p, 3);
    }
    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }
    function formatMonthNumber(d, p) {
      return pad$1(d.getMonth() + 1, p, 2);
    }
    function formatMinutes(d, p) {
      return pad$1(d.getMinutes(), p, 2);
    }
    function formatSeconds(d, p) {
      return pad$1(d.getSeconds(), p, 2);
    }
    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }
    function formatWeekNumberSunday(d, p) {
      return pad$1(timeSunday.count(timeYear(d) - 1, d), p, 2);
    }
    function dISO(d) {
      var day = d.getDay();
      return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
    }
    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad$1(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
    }
    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }
    function formatWeekNumberMonday(d, p) {
      return pad$1(timeMonday.count(timeYear(d) - 1, d), p, 2);
    }
    function formatYear$1(d, p) {
      return pad$1(d.getFullYear() % 100, p, 2);
    }
    function formatYearISO(d, p) {
      d = dISO(d);
      return pad$1(d.getFullYear() % 100, p, 2);
    }
    function formatFullYear(d, p) {
      return pad$1(d.getFullYear() % 1e4, p, 4);
    }
    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
      return pad$1(d.getFullYear() % 1e4, p, 4);
    }
    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+")) + pad$1(z / 60 | 0, "0", 2) + pad$1(z % 60, "0", 2);
    }
    function formatUTCDayOfMonth(d, p) {
      return pad$1(d.getUTCDate(), p, 2);
    }
    function formatUTCHour24(d, p) {
      return pad$1(d.getUTCHours(), p, 2);
    }
    function formatUTCHour12(d, p) {
      return pad$1(d.getUTCHours() % 12 || 12, p, 2);
    }
    function formatUTCDayOfYear(d, p) {
      return pad$1(1 + utcDay.count(utcYear(d), d), p, 3);
    }
    function formatUTCMilliseconds(d, p) {
      return pad$1(d.getUTCMilliseconds(), p, 3);
    }
    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }
    function formatUTCMonthNumber(d, p) {
      return pad$1(d.getUTCMonth() + 1, p, 2);
    }
    function formatUTCMinutes(d, p) {
      return pad$1(d.getUTCMinutes(), p, 2);
    }
    function formatUTCSeconds(d, p) {
      return pad$1(d.getUTCSeconds(), p, 2);
    }
    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }
    function formatUTCWeekNumberSunday(d, p) {
      return pad$1(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }
    function UTCdISO(d) {
      var day = d.getUTCDay();
      return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    }
    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad$1(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }
    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }
    function formatUTCWeekNumberMonday(d, p) {
      return pad$1(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }
    function formatUTCYear(d, p) {
      return pad$1(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad$1(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCFullYear(d, p) {
      return pad$1(d.getUTCFullYear() % 1e4, p, 4);
    }
    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
      return pad$1(d.getUTCFullYear() % 1e4, p, 4);
    }
    function formatUTCZone() {
      return "+0000";
    }
    function formatLiteralPercent() {
      return "%";
    }
    function formatUnixTimestamp(d) {
      return +d;
    }
    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1e3);
    }
    var locale;
    var timeFormat;
    var utcFormat;
    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      locale.parse;
      utcFormat = locale.utcFormat;
      locale.utcParse;
      return locale;
    }
    function date(t) {
      return new Date(t);
    }
    function number(t) {
      return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
    }
    function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
      var scale2 = continuous(), invert = scale2.invert, domain = scale2.domain;
      var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
      function tickFormat2(date2) {
        return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
      }
      scale2.invert = function(y) {
        return new Date(invert(y));
      };
      scale2.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };
      scale2.ticks = function(interval2) {
        var d = domain();
        return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
      };
      scale2.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat2 : format2(specifier);
      };
      scale2.nice = function(interval2) {
        var d = domain();
        if (!interval2 || typeof interval2.range !== "function")
          interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
        return interval2 ? domain(nice(d, interval2)) : scale2;
      };
      scale2.copy = function() {
        return copy$1(scale2, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
      };
      return scale2;
    }
    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
    }
    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
    }
    function copy(source, target) {
      return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
    }
    function transformer() {
      var x02 = 0, x12 = 0.5, x2 = 1, s2 = 1, t02, t12, t22, k10, k21, interpolator = identity$3, transform, clamp = false, unknown;
      function scale2(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t12) * (s2 * x < s2 * t12 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }
      scale2.domain = function(_) {
        return arguments.length ? ([x02, x12, x2] = _, t02 = transform(x02 = +x02), t12 = transform(x12 = +x12), t22 = transform(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s2 = t12 < t02 ? -1 : 1, scale2) : [x02, x12, x2];
      };
      scale2.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale2) : clamp;
      };
      scale2.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale2) : interpolator;
      };
      function range2(interpolate2) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale2) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }
      scale2.range = range2(interpolate$1);
      scale2.rangeRound = range2(interpolateRound);
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      return function(t) {
        transform = t, t02 = t(x02), t12 = t(x12), t22 = t(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s2 = t12 < t02 ? -1 : 1;
        return scale2;
      };
    }
    function diverging() {
      var scale2 = linearish(transformer()(identity$3));
      scale2.copy = function() {
        return copy(scale2, diverging());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function divergingLog() {
      var scale2 = loggish(transformer()).domain([0.1, 1, 10]);
      scale2.copy = function() {
        return copy(scale2, divergingLog()).base(scale2.base());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function divergingSymlog() {
      var scale2 = symlogish(transformer());
      scale2.copy = function() {
        return copy(scale2, divergingSymlog()).constant(scale2.constant());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function divergingPow() {
      var scale2 = powish(transformer());
      scale2.copy = function() {
        return copy(scale2, divergingPow()).exponent(scale2.exponent());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors2 = new Array(n), i = 0;
      while (i < n)
        colors2[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors2;
    }
    const schemeCategory10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
    const schemeAccent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
    const schemeDark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
    const schemePaired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
    const schemePastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
    const schemePastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");
    const schemeSet1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
    const schemeSet2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
    const schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
    const schemeTableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
    const ramp$1 = (scheme2) => rgbBasis(scheme2[scheme2.length - 1]);
    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);
    const interpolateBrBG = ramp$1(scheme$q);
    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);
    const interpolatePRGn = ramp$1(scheme$p);
    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);
    const interpolatePiYG = ramp$1(scheme$o);
    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);
    const interpolatePuOr = ramp$1(scheme$n);
    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);
    const interpolateRdBu = ramp$1(scheme$m);
    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);
    const interpolateRdGy = ramp$1(scheme$l);
    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);
    const interpolateRdYlBu = ramp$1(scheme$k);
    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);
    const interpolateRdYlGn = ramp$1(scheme$j);
    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);
    const interpolateSpectral = ramp$1(scheme$i);
    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);
    const interpolateBuGn = ramp$1(scheme$h);
    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);
    const interpolateBuPu = ramp$1(scheme$g);
    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);
    const interpolateGnBu = ramp$1(scheme$f);
    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);
    const interpolateOrRd = ramp$1(scheme$e);
    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);
    const interpolatePuBuGn = ramp$1(scheme$d);
    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);
    const interpolatePuBu = ramp$1(scheme$c);
    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);
    const interpolatePuRd = ramp$1(scheme$b);
    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);
    const interpolateRdPu = ramp$1(scheme$a);
    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);
    const interpolateYlGnBu = ramp$1(scheme$9);
    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);
    const interpolateYlGn = ramp$1(scheme$8);
    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);
    const interpolateYlOrBr = ramp$1(scheme$7);
    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);
    const interpolateYlOrRd = ramp$1(scheme$6);
    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);
    const interpolateBlues = ramp$1(scheme$5);
    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);
    const interpolateGreens = ramp$1(scheme$4);
    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);
    const interpolateGreys = ramp$1(scheme$3);
    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);
    const interpolatePurples = ramp$1(scheme$2);
    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);
    const interpolateReds = ramp$1(scheme$1);
    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);
    const interpolateOranges = ramp$1(scheme);
    function interpolateCividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
    }
    const interpolateCubehelixDefault = cubehelixLong(cubehelix$1(300, 0.5, 0), cubehelix$1(-240, 0.5, 1));
    var warm = cubehelixLong(cubehelix$1(-100, 0.75, 0.35), cubehelix$1(80, 1.5, 0.8));
    var cool = cubehelixLong(cubehelix$1(260, 0.75, 0.35), cubehelix$1(80, 1.5, 0.8));
    var c$2 = cubehelix$1();
    function interpolateRainbow(t) {
      if (t < 0 || t > 1)
        t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }
    var c$1 = rgb(), pi_1_3 = Math.PI / 3, pi_2_3 = Math.PI * 2 / 3;
    function interpolateSinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }
    function interpolateTurbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
    }
    function ramp(range2) {
      var n = range2.length;
      return function(t) {
        return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }
    const interpolateViridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
    const cos = Math.cos;
    const min$5 = Math.min;
    const sin = Math.sin;
    const sqrt = Math.sqrt;
    const pi$1 = Math.PI;
    const tau$1 = 2 * pi$1;
    const sqrt3$4 = sqrt(3);
    const symbolAsterisk = {
      draw(context, size) {
        const r = sqrt(size + min$5(size / 28, 0.75)) * 0.59436;
        const t = r / 2;
        const u = t * sqrt3$4;
        context.moveTo(0, r);
        context.lineTo(0, -r);
        context.moveTo(-u, -t);
        context.lineTo(u, t);
        context.moveTo(-u, t);
        context.lineTo(u, -t);
      }
    };
    const symbolCircle = {
      draw(context, size) {
        const r = sqrt(size / pi$1);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau$1);
      }
    };
    const symbolCross = {
      draw(context, size) {
        const r = sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };
    const tan30 = sqrt(1 / 3);
    const tan30_2 = tan30 * 2;
    const symbolDiamond = {
      draw(context, size) {
        const y = sqrt(size / tan30_2);
        const x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };
    const symbolDiamond2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.62625;
        context.moveTo(0, -r);
        context.lineTo(r, 0);
        context.lineTo(0, r);
        context.lineTo(-r, 0);
        context.closePath();
      }
    };
    const symbolPlus = {
      draw(context, size) {
        const r = sqrt(size - min$5(size / 7, 2)) * 0.87559;
        context.moveTo(-r, 0);
        context.lineTo(r, 0);
        context.moveTo(0, r);
        context.lineTo(0, -r);
      }
    };
    const symbolSquare = {
      draw(context, size) {
        const w = sqrt(size);
        const x = -w / 2;
        context.rect(x, x, w, w);
      }
    };
    const symbolSquare2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.4431;
        context.moveTo(r, r);
        context.lineTo(r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, r);
        context.closePath();
      }
    };
    const ka = 0.8908130915292852;
    const kr = sin(pi$1 / 10) / sin(7 * pi$1 / 10);
    const kx = sin(tau$1 / 10) * kr;
    const ky = -cos(tau$1 / 10) * kr;
    const symbolStar = {
      draw(context, size) {
        const r = sqrt(size * ka);
        const x = kx * r;
        const y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (let i = 1; i < 5; ++i) {
          const a2 = tau$1 * i / 5;
          const c2 = cos(a2);
          const s2 = sin(a2);
          context.lineTo(s2 * r, -c2 * r);
          context.lineTo(c2 * x - s2 * y, s2 * x + c2 * y);
        }
        context.closePath();
      }
    };
    const sqrt3$3 = sqrt(3);
    const symbolTriangle = {
      draw(context, size) {
        const y = -sqrt(size / (sqrt3$3 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3$3 * y, -y);
        context.lineTo(sqrt3$3 * y, -y);
        context.closePath();
      }
    };
    const sqrt3$2 = sqrt(3);
    const symbolTriangle2 = {
      draw(context, size) {
        const s2 = sqrt(size) * 0.6824;
        const t = s2 / 2;
        const u = s2 * sqrt3$2 / 2;
        context.moveTo(0, -s2);
        context.lineTo(u, t);
        context.lineTo(-u, t);
        context.closePath();
      }
    };
    const c = -0.5;
    const s = sqrt(3) / 2;
    const k = 1 / sqrt(12);
    const a = (k / 2 + 1) * 3;
    const symbolWye = {
      draw(context, size) {
        const r = sqrt(size / a);
        const x02 = r / 2, y02 = r * k;
        const x12 = x02, y12 = r * k + r;
        const x2 = -x12, y2 = y12;
        context.moveTo(x02, y02);
        context.lineTo(x12, y12);
        context.lineTo(x2, y2);
        context.lineTo(c * x02 - s * y02, s * x02 + c * y02);
        context.lineTo(c * x12 - s * y12, s * x12 + c * y12);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x02 + s * y02, c * y02 - s * x02);
        context.lineTo(c * x12 + s * y12, c * y12 - s * x12);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };
    const symbolTimes = {
      draw(context, size) {
        const r = sqrt(size - min$5(size / 6, 1.7)) * 0.6189;
        context.moveTo(-r, -r);
        context.lineTo(r, r);
        context.moveTo(-r, r);
        context.lineTo(r, -r);
      }
    };
    const symbolsFill = [
      symbolCircle,
      symbolCross,
      symbolDiamond,
      symbolSquare,
      symbolStar,
      symbolTriangle,
      symbolWye
    ];
    const symbolsStroke = [
      symbolCircle,
      symbolPlus,
      symbolTimes,
      symbolTriangle2,
      symbolAsterisk,
      symbolSquare2,
      symbolDiamond2
    ];
    function Transform(k2, x, y) {
      this.k = k2;
      this.x = x;
      this.y = y;
    }
    Transform.prototype = {
      constructor: Transform,
      scale: function(k2) {
        return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point2) {
        return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };
    Transform.prototype;
    function _iterableToArrayLimit(arr, i) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i) {
            if (Object(_i) !== _i)
              return;
            _n = false;
          } else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
              ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _regeneratorRuntime() {
      _regeneratorRuntime = function() {
        return exports2;
      };
      var exports2 = {}, Op = Object.prototype, hasOwn2 = Op.hasOwnProperty, defineProperty2 = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty2(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype2 = {};
      define2(IteratorPrototype2, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values2([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype2 = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype2);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method2) {
          define2(prototype, method2, function(arg) {
            return this._invoke(method2, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method2, arg, resolve, reject) {
          var record = tryCatch(generator[method2], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == typeof value && hasOwn2.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty2(this, "_invoke", {
          value: function(method2, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method2, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method2, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method2)
              throw arg;
            return doneResult();
          }
          for (context.method = method2, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method2 = delegate.iterator[methodName];
        if (void 0 === method2)
          return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method2, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values2(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; )
                if (hasOwn2.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty2(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
        return this;
      }), define2(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(val) {
        var object2 = Object(val), keys2 = [];
        for (var key in object2)
          keys2.push(key);
        return keys2.reverse(), function next() {
          for (; keys2.length; ) {
            var key2 = keys2.pop();
            if (key2 in object2)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports2.values = values2, Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn2.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn2.call(entry, "catchLoc"), hasFinally = hasOwn2.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        catch: function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values2(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports2;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _classCallCheck$2(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
      }
    }
    function _createClass$2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties$2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties$2(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey$2(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
    }
    function _toConsumableArray$1(arr) {
      return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
    }
    function _arrayWithoutHoles$1(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray$1(arr);
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterableToArray$1(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread$1() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toPrimitive$2(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey$2(arg) {
      var key = _toPrimitive$2(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    var commonjsGlobal$2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var check$2 = function(it) {
      return it && it.Math === Math && it;
    };
    var global$n = (
      // eslint-disable-next-line es/no-global-this -- safe
      check$2(typeof globalThis == "object" && globalThis) || check$2(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      check$2(typeof self == "object" && self) || check$2(typeof commonjsGlobal$2 == "object" && commonjsGlobal$2) || check$2(typeof commonjsGlobal$2 == "object" && commonjsGlobal$2) || // eslint-disable-next-line no-new-func -- fallback
      function() {
        return this;
      }() || Function("return this")()
    );
    var shared$4$1 = { exports: {} };
    var global$m = global$n;
    var defineProperty$9 = Object.defineProperty;
    var defineGlobalProperty$3$2 = function(key, value) {
      try {
        defineProperty$9(global$m, key, { value, configurable: true, writable: true });
      } catch (error) {
        global$m[key] = value;
      }
      return value;
    };
    var global$l = global$n;
    var defineGlobalProperty$2$2 = defineGlobalProperty$3$2;
    var SHARED$2 = "__core-js_shared__";
    var store$3$2 = global$l[SHARED$2] || defineGlobalProperty$2$2(SHARED$2, {});
    var sharedStore$2 = store$3$2;
    var store$2$2 = sharedStore$2;
    (shared$4$1.exports = function(key, value) {
      return store$2$2[key] || (store$2$2[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.34.0",
      mode: "global",
      copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.34.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
    var sharedExports$2 = shared$4$1.exports;
    var fails$u = function(exec2) {
      try {
        return !!exec2();
      } catch (error) {
        return true;
      }
    };
    var fails$t = fails$u;
    var functionBindNative$2 = !fails$t(function() {
      var test2 = (function() {
      }).bind();
      return typeof test2 != "function" || test2.hasOwnProperty("prototype");
    });
    var NATIVE_BIND$3$2 = functionBindNative$2;
    var FunctionPrototype$3$2 = Function.prototype;
    var call$j = FunctionPrototype$3$2.call;
    var uncurryThisWithBind$2 = NATIVE_BIND$3$2 && FunctionPrototype$3$2.bind.bind(call$j, call$j);
    var functionUncurryThis$2 = NATIVE_BIND$3$2 ? uncurryThisWithBind$2 : function(fn) {
      return function() {
        return call$j.apply(fn, arguments);
      };
    };
    var isNullOrUndefined$8 = function(it) {
      return it === null || it === void 0;
    };
    var isNullOrUndefined$7$1 = isNullOrUndefined$8;
    var $TypeError$g = TypeError;
    var requireObjectCoercible$7 = function(it) {
      if (isNullOrUndefined$7$1(it))
        throw new $TypeError$g("Can't call method on " + it);
      return it;
    };
    var requireObjectCoercible$6 = requireObjectCoercible$7;
    var $Object$4$1 = Object;
    var toObject$a = function(argument) {
      return $Object$4$1(requireObjectCoercible$6(argument));
    };
    var uncurryThis$u = functionUncurryThis$2;
    var toObject$9 = toObject$a;
    var hasOwnProperty$d = uncurryThis$u({}.hasOwnProperty);
    var hasOwnProperty_1$2 = Object.hasOwn || function hasOwn2(it, key) {
      return hasOwnProperty$d(toObject$9(it), key);
    };
    var uncurryThis$t = functionUncurryThis$2;
    var id$2$1 = 0;
    var postfix$2 = Math.random();
    var toString$c = uncurryThis$t(1 .toString);
    var uid$3$1 = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$c(++id$2$1 + postfix$2, 36);
    };
    var engineUserAgent$2 = typeof navigator != "undefined" && String(navigator.userAgent) || "";
    var global$k = global$n;
    var userAgent$5 = engineUserAgent$2;
    var process$3$2 = global$k.process;
    var Deno$1$2 = global$k.Deno;
    var versions$2 = process$3$2 && process$3$2.versions || Deno$1$2 && Deno$1$2.version;
    var v8$2 = versions$2 && versions$2.v8;
    var match$2, version$2;
    if (v8$2) {
      match$2 = v8$2.split(".");
      version$2 = match$2[0] > 0 && match$2[0] < 4 ? 1 : +(match$2[0] + match$2[1]);
    }
    if (!version$2 && userAgent$5) {
      match$2 = userAgent$5.match(/Edge\/(\d+)/);
      if (!match$2 || match$2[1] >= 74) {
        match$2 = userAgent$5.match(/Chrome\/(\d+)/);
        if (match$2)
          version$2 = +match$2[1];
      }
    }
    var engineV8Version$2 = version$2;
    var V8_VERSION$3$1 = engineV8Version$2;
    var fails$s = fails$u;
    var global$j$1 = global$n;
    var $String$5$1 = global$j$1.String;
    var symbolConstructorDetection$2 = !!Object.getOwnPropertySymbols && !fails$s(function() {
      var symbol2 = Symbol("symbol detection");
      return !$String$5$1(symbol2) || !(Object(symbol2) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION$3$1 && V8_VERSION$3$1 < 41;
    });
    var NATIVE_SYMBOL$1$2 = symbolConstructorDetection$2;
    var useSymbolAsUid$2 = NATIVE_SYMBOL$1$2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
    var global$i$1 = global$n;
    var shared$3$2 = sharedExports$2;
    var hasOwn$b$1 = hasOwnProperty_1$2;
    var uid$2$2 = uid$3$1;
    var NATIVE_SYMBOL$3 = symbolConstructorDetection$2;
    var USE_SYMBOL_AS_UID$1$2 = useSymbolAsUid$2;
    var Symbol$3 = global$i$1.Symbol;
    var WellKnownSymbolsStore$2 = shared$3$2("wks");
    var createWellKnownSymbol$2 = USE_SYMBOL_AS_UID$1$2 ? Symbol$3["for"] || Symbol$3 : Symbol$3 && Symbol$3.withoutSetter || uid$2$2;
    var wellKnownSymbol$m = function(name) {
      if (!hasOwn$b$1(WellKnownSymbolsStore$2, name)) {
        WellKnownSymbolsStore$2[name] = NATIVE_SYMBOL$3 && hasOwn$b$1(Symbol$3, name) ? Symbol$3[name] : createWellKnownSymbol$2("Symbol." + name);
      }
      return WellKnownSymbolsStore$2[name];
    };
    var wellKnownSymbol$l = wellKnownSymbol$m;
    var TO_STRING_TAG$2$2 = wellKnownSymbol$l("toStringTag");
    var test$1$1 = {};
    test$1$1[TO_STRING_TAG$2$2] = "z";
    var toStringTagSupport$2 = String(test$1$1) === "[object z]";
    var documentAll$2$2 = typeof document == "object" && document.all;
    var IS_HTMLDDA$2 = typeof documentAll$2$2 == "undefined" && documentAll$2$2 !== void 0;
    var documentAll_1$2 = {
      all: documentAll$2$2,
      IS_HTMLDDA: IS_HTMLDDA$2
    };
    var $documentAll$1$2 = documentAll_1$2;
    var documentAll$1$2 = $documentAll$1$2.all;
    var isCallable$o = $documentAll$1$2.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll$1$2;
    } : function(argument) {
      return typeof argument == "function";
    };
    var objectDefineProperty$2 = {};
    var fails$r = fails$u;
    var descriptors$2 = !fails$r(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
    var isCallable$n$1 = isCallable$o;
    var $documentAll$3 = documentAll_1$2;
    var documentAll$4 = $documentAll$3.all;
    var isObject$j = $documentAll$3.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable$n$1(it) || it === documentAll$4;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable$n$1(it);
    };
    var global$h$2 = global$n;
    var isObject$i = isObject$j;
    var document$3$2 = global$h$2.document;
    var EXISTS$1$2 = isObject$i(document$3$2) && isObject$i(document$3$2.createElement);
    var documentCreateElement$2$1 = function(it) {
      return EXISTS$1$2 ? document$3$2.createElement(it) : {};
    };
    var DESCRIPTORS$d = descriptors$2;
    var fails$q = fails$u;
    var createElement$1$2 = documentCreateElement$2$1;
    var ie8DomDefine$2 = !DESCRIPTORS$d && !fails$q(function() {
      return Object.defineProperty(createElement$1$2("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
    var DESCRIPTORS$c$1 = descriptors$2;
    var fails$p = fails$u;
    var v8PrototypeDefineBug$2 = DESCRIPTORS$c$1 && fails$p(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
    var isObject$h = isObject$j;
    var $String$4$2 = String;
    var $TypeError$f = TypeError;
    var anObject$f = function(argument) {
      if (isObject$h(argument))
        return argument;
      throw new $TypeError$f($String$4$2(argument) + " is not an object");
    };
    var NATIVE_BIND$2$2 = functionBindNative$2;
    var call$i = Function.prototype.call;
    var functionCall$2 = NATIVE_BIND$2$2 ? call$i.bind(call$i) : function() {
      return call$i.apply(call$i, arguments);
    };
    var global$g$2 = global$n;
    var isCallable$m$1 = isCallable$o;
    var aFunction$2 = function(argument) {
      return isCallable$m$1(argument) ? argument : void 0;
    };
    var getBuiltIn$7$2 = function(namespace2, method2) {
      return arguments.length < 2 ? aFunction$2(global$g$2[namespace2]) : global$g$2[namespace2] && global$g$2[namespace2][method2];
    };
    var uncurryThis$s = functionUncurryThis$2;
    var objectIsPrototypeOf$2 = uncurryThis$s({}.isPrototypeOf);
    var getBuiltIn$6$2 = getBuiltIn$7$2;
    var isCallable$l$1 = isCallable$o;
    var isPrototypeOf$2$2 = objectIsPrototypeOf$2;
    var USE_SYMBOL_AS_UID$3 = useSymbolAsUid$2;
    var $Object$3$2 = Object;
    var isSymbol$3$1 = USE_SYMBOL_AS_UID$3 ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn$6$2("Symbol");
      return isCallable$l$1($Symbol) && isPrototypeOf$2$2($Symbol.prototype, $Object$3$2(it));
    };
    var $String$3$2 = String;
    var tryToString$5$1 = function(argument) {
      try {
        return $String$3$2(argument);
      } catch (error) {
        return "Object";
      }
    };
    var isCallable$k$1 = isCallable$o;
    var tryToString$4$2 = tryToString$5$1;
    var $TypeError$e$1 = TypeError;
    var aCallable$a = function(argument) {
      if (isCallable$k$1(argument))
        return argument;
      throw new $TypeError$e$1(tryToString$4$2(argument) + " is not a function");
    };
    var aCallable$9$1 = aCallable$a;
    var isNullOrUndefined$6$1 = isNullOrUndefined$8;
    var getMethod$4$1 = function(V, P) {
      var func = V[P];
      return isNullOrUndefined$6$1(func) ? void 0 : aCallable$9$1(func);
    };
    var call$h = functionCall$2;
    var isCallable$j$1 = isCallable$o;
    var isObject$g$1 = isObject$j;
    var $TypeError$d$1 = TypeError;
    var ordinaryToPrimitive$1$2 = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable$j$1(fn = input.toString) && !isObject$g$1(val = call$h(fn, input)))
        return val;
      if (isCallable$j$1(fn = input.valueOf) && !isObject$g$1(val = call$h(fn, input)))
        return val;
      if (pref !== "string" && isCallable$j$1(fn = input.toString) && !isObject$g$1(val = call$h(fn, input)))
        return val;
      throw new $TypeError$d$1("Can't convert object to primitive value");
    };
    var call$g = functionCall$2;
    var isObject$f$1 = isObject$j;
    var isSymbol$2$2 = isSymbol$3$1;
    var getMethod$3$2 = getMethod$4$1;
    var ordinaryToPrimitive$3 = ordinaryToPrimitive$1$2;
    var wellKnownSymbol$k = wellKnownSymbol$m;
    var $TypeError$c$2 = TypeError;
    var TO_PRIMITIVE$2 = wellKnownSymbol$k("toPrimitive");
    var toPrimitive$1$2 = function(input, pref) {
      if (!isObject$f$1(input) || isSymbol$2$2(input))
        return input;
      var exoticToPrim = getMethod$3$2(input, TO_PRIMITIVE$2);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call$g(exoticToPrim, input, pref);
        if (!isObject$f$1(result) || isSymbol$2$2(result))
          return result;
        throw new $TypeError$c$2("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive$3(input, pref);
    };
    var toPrimitive$3 = toPrimitive$1$2;
    var isSymbol$1$2 = isSymbol$3$1;
    var toPropertyKey$3$1 = function(argument) {
      var key = toPrimitive$3(argument, "string");
      return isSymbol$1$2(key) ? key : key + "";
    };
    var DESCRIPTORS$b$1 = descriptors$2;
    var IE8_DOM_DEFINE$1$2 = ie8DomDefine$2;
    var V8_PROTOTYPE_DEFINE_BUG$1$1 = v8PrototypeDefineBug$2;
    var anObject$e = anObject$f;
    var toPropertyKey$2$2 = toPropertyKey$3$1;
    var $TypeError$b$2 = TypeError;
    var $defineProperty$2 = Object.defineProperty;
    var $getOwnPropertyDescriptor$1$2 = Object.getOwnPropertyDescriptor;
    var ENUMERABLE$2 = "enumerable";
    var CONFIGURABLE$1$2 = "configurable";
    var WRITABLE$2 = "writable";
    objectDefineProperty$2.f = DESCRIPTORS$b$1 ? V8_PROTOTYPE_DEFINE_BUG$1$1 ? function defineProperty2(O, P, Attributes) {
      anObject$e(O);
      P = toPropertyKey$2$2(P);
      anObject$e(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE$2 in Attributes && !Attributes[WRITABLE$2]) {
        var current = $getOwnPropertyDescriptor$1$2(O, P);
        if (current && current[WRITABLE$2]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE$1$2 in Attributes ? Attributes[CONFIGURABLE$1$2] : current[CONFIGURABLE$1$2],
            enumerable: ENUMERABLE$2 in Attributes ? Attributes[ENUMERABLE$2] : current[ENUMERABLE$2],
            writable: false
          };
        }
      }
      return $defineProperty$2(O, P, Attributes);
    } : $defineProperty$2 : function defineProperty2(O, P, Attributes) {
      anObject$e(O);
      P = toPropertyKey$2$2(P);
      anObject$e(Attributes);
      if (IE8_DOM_DEFINE$1$2)
        try {
          return $defineProperty$2(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw new $TypeError$b$2("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
    var makeBuiltIn$3$2 = { exports: {} };
    var DESCRIPTORS$a$1 = descriptors$2;
    var hasOwn$a$1 = hasOwnProperty_1$2;
    var FunctionPrototype$2$2 = Function.prototype;
    var getDescriptor$2 = DESCRIPTORS$a$1 && Object.getOwnPropertyDescriptor;
    var EXISTS$3 = hasOwn$a$1(FunctionPrototype$2$2, "name");
    var PROPER$2 = EXISTS$3 && (function something() {
    }).name === "something";
    var CONFIGURABLE$3 = EXISTS$3 && (!DESCRIPTORS$a$1 || DESCRIPTORS$a$1 && getDescriptor$2(FunctionPrototype$2$2, "name").configurable);
    var functionName$2 = {
      EXISTS: EXISTS$3,
      PROPER: PROPER$2,
      CONFIGURABLE: CONFIGURABLE$3
    };
    var uncurryThis$r = functionUncurryThis$2;
    var isCallable$i$1 = isCallable$o;
    var store$1$2 = sharedStore$2;
    var functionToString$1$2 = uncurryThis$r(Function.toString);
    if (!isCallable$i$1(store$1$2.inspectSource)) {
      store$1$2.inspectSource = function(it) {
        return functionToString$1$2(it);
      };
    }
    var inspectSource$3$2 = store$1$2.inspectSource;
    var global$f$2 = global$n;
    var isCallable$h$2 = isCallable$o;
    var WeakMap$3 = global$f$2.WeakMap;
    var weakMapBasicDetection$2 = isCallable$h$2(WeakMap$3) && /native code/.test(String(WeakMap$3));
    var createPropertyDescriptor$4$1 = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
    var DESCRIPTORS$9$2 = descriptors$2;
    var definePropertyModule$4$1 = objectDefineProperty$2;
    var createPropertyDescriptor$3$1 = createPropertyDescriptor$4$1;
    var createNonEnumerableProperty$6 = DESCRIPTORS$9$2 ? function(object2, key, value) {
      return definePropertyModule$4$1.f(object2, key, createPropertyDescriptor$3$1(1, value));
    } : function(object2, key, value) {
      object2[key] = value;
      return object2;
    };
    var shared$2$2 = sharedExports$2;
    var uid$1$2 = uid$3$1;
    var keys$1$1 = shared$2$2("keys");
    var sharedKey$3$1 = function(key) {
      return keys$1$1[key] || (keys$1$1[key] = uid$1$2(key));
    };
    var hiddenKeys$5$1 = {};
    var NATIVE_WEAK_MAP$2 = weakMapBasicDetection$2;
    var global$e$2 = global$n;
    var isObject$e$1 = isObject$j;
    var createNonEnumerableProperty$5$1 = createNonEnumerableProperty$6;
    var hasOwn$9$1 = hasOwnProperty_1$2;
    var shared$1$2 = sharedStore$2;
    var sharedKey$2$1 = sharedKey$3$1;
    var hiddenKeys$4$1 = hiddenKeys$5$1;
    var OBJECT_ALREADY_INITIALIZED$2 = "Object already initialized";
    var TypeError$2$2 = global$e$2.TypeError;
    var WeakMap$2$1 = global$e$2.WeakMap;
    var set$2$1, get$1$1, has$1$1;
    var enforce$2 = function(it) {
      return has$1$1(it) ? get$1$1(it) : set$2$1(it, {});
    };
    var getterFor$2 = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject$e$1(it) || (state = get$1$1(it)).type !== TYPE) {
          throw new TypeError$2$2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP$2 || shared$1$2.state) {
      var store$5 = shared$1$2.state || (shared$1$2.state = new WeakMap$2$1());
      store$5.get = store$5.get;
      store$5.has = store$5.has;
      store$5.set = store$5.set;
      set$2$1 = function(it, metadata) {
        if (store$5.has(it))
          throw new TypeError$2$2(OBJECT_ALREADY_INITIALIZED$2);
        metadata.facade = it;
        store$5.set(it, metadata);
        return metadata;
      };
      get$1$1 = function(it) {
        return store$5.get(it) || {};
      };
      has$1$1 = function(it) {
        return store$5.has(it);
      };
    } else {
      var STATE$2 = sharedKey$2$1("state");
      hiddenKeys$4$1[STATE$2] = true;
      set$2$1 = function(it, metadata) {
        if (hasOwn$9$1(it, STATE$2))
          throw new TypeError$2$2(OBJECT_ALREADY_INITIALIZED$2);
        metadata.facade = it;
        createNonEnumerableProperty$5$1(it, STATE$2, metadata);
        return metadata;
      };
      get$1$1 = function(it) {
        return hasOwn$9$1(it, STATE$2) ? it[STATE$2] : {};
      };
      has$1$1 = function(it) {
        return hasOwn$9$1(it, STATE$2);
      };
    }
    var internalState$2 = {
      set: set$2$1,
      get: get$1$1,
      has: has$1$1,
      enforce: enforce$2,
      getterFor: getterFor$2
    };
    var uncurryThis$q = functionUncurryThis$2;
    var fails$o = fails$u;
    var isCallable$g$2 = isCallable$o;
    var hasOwn$8$2 = hasOwnProperty_1$2;
    var DESCRIPTORS$8$2 = descriptors$2;
    var CONFIGURABLE_FUNCTION_NAME$1$1 = functionName$2.CONFIGURABLE;
    var inspectSource$2$2 = inspectSource$3$2;
    var InternalStateModule$5$1 = internalState$2;
    var enforceInternalState$2 = InternalStateModule$5$1.enforce;
    var getInternalState$3$1 = InternalStateModule$5$1.get;
    var $String$2$2 = String;
    var defineProperty$8$1 = Object.defineProperty;
    var stringSlice$6 = uncurryThis$q("".slice);
    var replace$3 = uncurryThis$q("".replace);
    var join$2 = uncurryThis$q([].join);
    var CONFIGURABLE_LENGTH$2 = DESCRIPTORS$8$2 && !fails$o(function() {
      return defineProperty$8$1(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE$2 = String(String).split("String");
    var makeBuiltIn$2$2 = makeBuiltIn$3$2.exports = function(value, name, options) {
      if (stringSlice$6($String$2$2(name), 0, 7) === "Symbol(") {
        name = "[" + replace$3($String$2$2(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
      }
      if (options && options.getter)
        name = "get " + name;
      if (options && options.setter)
        name = "set " + name;
      if (!hasOwn$8$2(value, "name") || CONFIGURABLE_FUNCTION_NAME$1$1 && value.name !== name) {
        if (DESCRIPTORS$8$2)
          defineProperty$8$1(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH$2 && options && hasOwn$8$2(options, "arity") && value.length !== options.arity) {
        defineProperty$8$1(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn$8$2(options, "constructor") && options.constructor) {
          if (DESCRIPTORS$8$2)
            defineProperty$8$1(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState$2(value);
      if (!hasOwn$8$2(state, "source")) {
        state.source = join$2(TEMPLATE$2, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn$2$2(function toString2() {
      return isCallable$g$2(this) && getInternalState$3$1(this).source || inspectSource$2$2(this);
    }, "toString");
    var makeBuiltInExports$2 = makeBuiltIn$3$2.exports;
    var isCallable$f$2 = isCallable$o;
    var definePropertyModule$3$1 = objectDefineProperty$2;
    var makeBuiltIn$1$2 = makeBuiltInExports$2;
    var defineGlobalProperty$1$2 = defineGlobalProperty$3$2;
    var defineBuiltIn$9$1 = function(O, key, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable$f$2(value))
        makeBuiltIn$1$2(value, name, options);
      if (options.global) {
        if (simple)
          O[key] = value;
        else
          defineGlobalProperty$1$2(key, value);
      } else {
        try {
          if (!options.unsafe)
            delete O[key];
          else if (O[key])
            simple = true;
        } catch (error) {
        }
        if (simple)
          O[key] = value;
        else
          definePropertyModule$3$1.f(O, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O;
    };
    var uncurryThis$p = functionUncurryThis$2;
    var toString$b = uncurryThis$p({}.toString);
    var stringSlice$5 = uncurryThis$p("".slice);
    var classofRaw$2$2 = function(it) {
      return stringSlice$5(toString$b(it), 8, -1);
    };
    var TO_STRING_TAG_SUPPORT$2$2 = toStringTagSupport$2;
    var isCallable$e$2 = isCallable$o;
    var classofRaw$1$2 = classofRaw$2$2;
    var wellKnownSymbol$j = wellKnownSymbol$m;
    var TO_STRING_TAG$1$2 = wellKnownSymbol$j("toStringTag");
    var $Object$2$2 = Object;
    var CORRECT_ARGUMENTS$2 = classofRaw$1$2(function() {
      return arguments;
    }()) === "Arguments";
    var tryGet$2 = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    var classof$b = TO_STRING_TAG_SUPPORT$2$2 ? classofRaw$1$2 : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet$2(O = $Object$2$2(it), TO_STRING_TAG$1$2)) == "string" ? tag : CORRECT_ARGUMENTS$2 ? classofRaw$1$2(O) : (result = classofRaw$1$2(O)) === "Object" && isCallable$e$2(O.callee) ? "Arguments" : result;
    };
    var TO_STRING_TAG_SUPPORT$1$2 = toStringTagSupport$2;
    var classof$a$1 = classof$b;
    var objectToString$2$1 = TO_STRING_TAG_SUPPORT$1$2 ? {}.toString : function toString2() {
      return "[object " + classof$a$1(this) + "]";
    };
    var TO_STRING_TAG_SUPPORT$4 = toStringTagSupport$2;
    var defineBuiltIn$8$1 = defineBuiltIn$9$1;
    var toString$a = objectToString$2$1;
    if (!TO_STRING_TAG_SUPPORT$4) {
      defineBuiltIn$8$1(Object.prototype, "toString", toString$a, { unsafe: true });
    }
    var objectGetOwnPropertyDescriptor$2 = {};
    var objectPropertyIsEnumerable$2 = {};
    var $propertyIsEnumerable$1$1 = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor$3$1 = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG$2 = getOwnPropertyDescriptor$3$1 && !$propertyIsEnumerable$1$1.call({ 1: 2 }, 1);
    objectPropertyIsEnumerable$2.f = NASHORN_BUG$2 ? function propertyIsEnumerable2(V) {
      var descriptor = getOwnPropertyDescriptor$3$1(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable$1$1;
    var uncurryThis$o = functionUncurryThis$2;
    var fails$n = fails$u;
    var classof$9$1 = classofRaw$2$2;
    var $Object$1$2 = Object;
    var split$2 = uncurryThis$o("".split);
    var indexedObject$2 = fails$n(function() {
      return !$Object$1$2("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof$9$1(it) === "String" ? split$2(it, "") : $Object$1$2(it);
    } : $Object$1$2;
    var IndexedObject$3$1 = indexedObject$2;
    var requireObjectCoercible$5 = requireObjectCoercible$7;
    var toIndexedObject$9 = function(it) {
      return IndexedObject$3$1(requireObjectCoercible$5(it));
    };
    var DESCRIPTORS$7$2 = descriptors$2;
    var call$f$1 = functionCall$2;
    var propertyIsEnumerableModule$1$2 = objectPropertyIsEnumerable$2;
    var createPropertyDescriptor$2$2 = createPropertyDescriptor$4$1;
    var toIndexedObject$8 = toIndexedObject$9;
    var toPropertyKey$1$2 = toPropertyKey$3$1;
    var hasOwn$7$2 = hasOwnProperty_1$2;
    var IE8_DOM_DEFINE$3 = ie8DomDefine$2;
    var $getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
    objectGetOwnPropertyDescriptor$2.f = DESCRIPTORS$7$2 ? $getOwnPropertyDescriptor$3 : function getOwnPropertyDescriptor2(O, P) {
      O = toIndexedObject$8(O);
      P = toPropertyKey$1$2(P);
      if (IE8_DOM_DEFINE$3)
        try {
          return $getOwnPropertyDescriptor$3(O, P);
        } catch (error) {
        }
      if (hasOwn$7$2(O, P))
        return createPropertyDescriptor$2$2(!call$f$1(propertyIsEnumerableModule$1$2.f, O, P), O[P]);
    };
    var objectGetOwnPropertyNames$2 = {};
    var ceil$2 = Math.ceil;
    var floor$2 = Math.floor;
    var mathTrunc$2 = Math.trunc || function trunc2(x) {
      var n = +x;
      return (n > 0 ? floor$2 : ceil$2)(n);
    };
    var trunc$2 = mathTrunc$2;
    var toIntegerOrInfinity$4$1 = function(argument) {
      var number2 = +argument;
      return number2 !== number2 || number2 === 0 ? 0 : trunc$2(number2);
    };
    var toIntegerOrInfinity$3$1 = toIntegerOrInfinity$4$1;
    var max$3$1 = Math.max;
    var min$3$1 = Math.min;
    var toAbsoluteIndex$4 = function(index, length2) {
      var integer = toIntegerOrInfinity$3$1(index);
      return integer < 0 ? max$3$1(integer + length2, 0) : min$3$1(integer, length2);
    };
    var toIntegerOrInfinity$2$2 = toIntegerOrInfinity$4$1;
    var min$2$1 = Math.min;
    var toLength$3 = function(argument) {
      return argument > 0 ? min$2$1(toIntegerOrInfinity$2$2(argument), 9007199254740991) : 0;
    };
    var toLength$2$1 = toLength$3;
    var lengthOfArrayLike$9 = function(obj) {
      return toLength$2$1(obj.length);
    };
    var toIndexedObject$7$1 = toIndexedObject$9;
    var toAbsoluteIndex$3$1 = toAbsoluteIndex$4;
    var lengthOfArrayLike$8 = lengthOfArrayLike$9;
    var createMethod$4 = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject$7$1($this);
        var length2 = lengthOfArrayLike$8(O);
        var index = toAbsoluteIndex$3$1(fromIndex, length2);
        var value;
        if (IS_INCLUDES && el !== el)
          while (length2 > index) {
            value = O[index++];
            if (value !== value)
              return true;
          }
        else
          for (; length2 > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    var arrayIncludes$2 = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod$4(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod$4(false)
    };
    var uncurryThis$n = functionUncurryThis$2;
    var hasOwn$6$2 = hasOwnProperty_1$2;
    var toIndexedObject$6$1 = toIndexedObject$9;
    var indexOf$1$1 = arrayIncludes$2.indexOf;
    var hiddenKeys$3$2 = hiddenKeys$5$1;
    var push$4 = uncurryThis$n([].push);
    var objectKeysInternal$2 = function(object2, names) {
      var O = toIndexedObject$6$1(object2);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        !hasOwn$6$2(hiddenKeys$3$2, key) && hasOwn$6$2(O, key) && push$4(result, key);
      while (names.length > i)
        if (hasOwn$6$2(O, key = names[i++])) {
          ~indexOf$1$1(result, key) || push$4(result, key);
        }
      return result;
    };
    var enumBugKeys$3$1 = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
    var internalObjectKeys$1$2 = objectKeysInternal$2;
    var enumBugKeys$2$2 = enumBugKeys$3$1;
    var hiddenKeys$2$2 = enumBugKeys$2$2.concat("length", "prototype");
    objectGetOwnPropertyNames$2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys$1$2(O, hiddenKeys$2$2);
    };
    var objectGetOwnPropertySymbols$2 = {};
    objectGetOwnPropertySymbols$2.f = Object.getOwnPropertySymbols;
    var getBuiltIn$5$2 = getBuiltIn$7$2;
    var uncurryThis$m = functionUncurryThis$2;
    var getOwnPropertyNamesModule$1$1 = objectGetOwnPropertyNames$2;
    var getOwnPropertySymbolsModule$1$2 = objectGetOwnPropertySymbols$2;
    var anObject$d = anObject$f;
    var concat$2$1 = uncurryThis$m([].concat);
    var ownKeys$1$2 = getBuiltIn$5$2("Reflect", "ownKeys") || function ownKeys2(it) {
      var keys2 = getOwnPropertyNamesModule$1$1.f(anObject$d(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule$1$2.f;
      return getOwnPropertySymbols ? concat$2$1(keys2, getOwnPropertySymbols(it)) : keys2;
    };
    var hasOwn$5$2 = hasOwnProperty_1$2;
    var ownKeys$3 = ownKeys$1$2;
    var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor$2;
    var definePropertyModule$2$2 = objectDefineProperty$2;
    var copyConstructorProperties$1$2 = function(target, source, exceptions) {
      var keys2 = ownKeys$3(source);
      var defineProperty2 = definePropertyModule$2$2.f;
      var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule$2.f;
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        if (!hasOwn$5$2(target, key) && !(exceptions && hasOwn$5$2(exceptions, key))) {
          defineProperty2(target, key, getOwnPropertyDescriptor2(source, key));
        }
      }
    };
    var fails$m = fails$u;
    var isCallable$d$2 = isCallable$o;
    var replacement$2 = /#|\.prototype\./;
    var isForced$3$1 = function(feature, detection) {
      var value = data$2[normalize$2(feature)];
      return value === POLYFILL$2 ? true : value === NATIVE$2 ? false : isCallable$d$2(detection) ? fails$m(detection) : !!detection;
    };
    var normalize$2 = isForced$3$1.normalize = function(string2) {
      return String(string2).replace(replacement$2, ".").toLowerCase();
    };
    var data$2 = isForced$3$1.data = {};
    var NATIVE$2 = isForced$3$1.NATIVE = "N";
    var POLYFILL$2 = isForced$3$1.POLYFILL = "P";
    var isForced_1$2 = isForced$3$1;
    var global$d$2 = global$n;
    var getOwnPropertyDescriptor$2$2 = objectGetOwnPropertyDescriptor$2.f;
    var createNonEnumerableProperty$4$1 = createNonEnumerableProperty$6;
    var defineBuiltIn$7$1 = defineBuiltIn$9$1;
    var defineGlobalProperty$5 = defineGlobalProperty$3$2;
    var copyConstructorProperties$3 = copyConstructorProperties$1$2;
    var isForced$2$2 = isForced_1$2;
    var _export$2 = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global$d$2;
      } else if (STATIC) {
        target = global$d$2[TARGET] || defineGlobalProperty$5(TARGET, {});
      } else {
        target = (global$d$2[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor$2$2(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED2 = isForced$2$2(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED2 && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties$3(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty$4$1(sourceProperty, "sham", true);
          }
          defineBuiltIn$7$1(target, key, sourceProperty, options);
        }
    };
    var global$c$2 = global$n;
    var classof$8$1 = classofRaw$2$2;
    var engineIsNode$2 = classof$8$1(global$c$2.process) === "process";
    var uncurryThis$l$1 = functionUncurryThis$2;
    var aCallable$8$2 = aCallable$a;
    var functionUncurryThisAccessor$2 = function(object2, key, method2) {
      try {
        return uncurryThis$l$1(aCallable$8$2(Object.getOwnPropertyDescriptor(object2, key)[method2]));
      } catch (error) {
      }
    };
    var isCallable$c$2 = isCallable$o;
    var $String$1$2 = String;
    var $TypeError$a$2 = TypeError;
    var aPossiblePrototype$1$2 = function(argument) {
      if (typeof argument == "object" || isCallable$c$2(argument))
        return argument;
      throw new $TypeError$a$2("Can't set " + $String$1$2(argument) + " as a prototype");
    };
    var uncurryThisAccessor$2 = functionUncurryThisAccessor$2;
    var anObject$c$1 = anObject$f;
    var aPossiblePrototype$3 = aPossiblePrototype$1$2;
    var objectSetPrototypeOf$2 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test2 = {};
      var setter;
      try {
        setter = uncurryThisAccessor$2(Object.prototype, "__proto__", "set");
        setter(test2, []);
        CORRECT_SETTER = test2 instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf2(O, proto) {
        anObject$c$1(O);
        aPossiblePrototype$3(proto);
        if (CORRECT_SETTER)
          setter(O, proto);
        else
          O.__proto__ = proto;
        return O;
      };
    }() : void 0);
    var defineProperty$7$1 = objectDefineProperty$2.f;
    var hasOwn$4$2 = hasOwnProperty_1$2;
    var wellKnownSymbol$i$1 = wellKnownSymbol$m;
    var TO_STRING_TAG$4 = wellKnownSymbol$i$1("toStringTag");
    var setToStringTag$5$1 = function(target, TAG, STATIC) {
      if (target && !STATIC)
        target = target.prototype;
      if (target && !hasOwn$4$2(target, TO_STRING_TAG$4)) {
        defineProperty$7$1(target, TO_STRING_TAG$4, { configurable: true, value: TAG });
      }
    };
    var makeBuiltIn$5 = makeBuiltInExports$2;
    var defineProperty$6$1 = objectDefineProperty$2;
    var defineBuiltInAccessor$3$1 = function(target, name, descriptor) {
      if (descriptor.get)
        makeBuiltIn$5(descriptor.get, name, { getter: true });
      if (descriptor.set)
        makeBuiltIn$5(descriptor.set, name, { setter: true });
      return defineProperty$6$1.f(target, name, descriptor);
    };
    var getBuiltIn$4$2 = getBuiltIn$7$2;
    var defineBuiltInAccessor$2$2 = defineBuiltInAccessor$3$1;
    var wellKnownSymbol$h$1 = wellKnownSymbol$m;
    var DESCRIPTORS$6$2 = descriptors$2;
    var SPECIES$6 = wellKnownSymbol$h$1("species");
    var setSpecies$2$1 = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn$4$2(CONSTRUCTOR_NAME);
      if (DESCRIPTORS$6$2 && Constructor && !Constructor[SPECIES$6]) {
        defineBuiltInAccessor$2$2(Constructor, SPECIES$6, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
    var isPrototypeOf$1$2 = objectIsPrototypeOf$2;
    var $TypeError$9$2 = TypeError;
    var anInstance$4$1 = function(it, Prototype) {
      if (isPrototypeOf$1$2(Prototype, it))
        return it;
      throw new $TypeError$9$2("Incorrect invocation");
    };
    var uncurryThis$k$1 = functionUncurryThis$2;
    var fails$l = fails$u;
    var isCallable$b$2 = isCallable$o;
    var classof$7$1 = classof$b;
    var getBuiltIn$3$2 = getBuiltIn$7$2;
    var inspectSource$1$2 = inspectSource$3$2;
    var noop$2 = function() {
    };
    var empty$2 = [];
    var construct$2 = getBuiltIn$3$2("Reflect", "construct");
    var constructorRegExp$2 = /^\s*(?:class|function)\b/;
    var exec$1$1 = uncurryThis$k$1(constructorRegExp$2.exec);
    var INCORRECT_TO_STRING$2 = !constructorRegExp$2.test(noop$2);
    var isConstructorModern$2 = function isConstructor2(argument) {
      if (!isCallable$b$2(argument))
        return false;
      try {
        construct$2(noop$2, empty$2, argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy$2 = function isConstructor2(argument) {
      if (!isCallable$b$2(argument))
        return false;
      switch (classof$7$1(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING$2 || !!exec$1$1(constructorRegExp$2, inspectSource$1$2(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy$2.sham = true;
    var isConstructor$4 = !construct$2 || fails$l(function() {
      var called2;
      return isConstructorModern$2(isConstructorModern$2.call) || !isConstructorModern$2(Object) || !isConstructorModern$2(function() {
        called2 = true;
      }) || called2;
    }) ? isConstructorLegacy$2 : isConstructorModern$2;
    var isConstructor$3$1 = isConstructor$4;
    var tryToString$3$2 = tryToString$5$1;
    var $TypeError$8$2 = TypeError;
    var aConstructor$1$2 = function(argument) {
      if (isConstructor$3$1(argument))
        return argument;
      throw new $TypeError$8$2(tryToString$3$2(argument) + " is not a constructor");
    };
    var anObject$b$1 = anObject$f;
    var aConstructor$3 = aConstructor$1$2;
    var isNullOrUndefined$5$1 = isNullOrUndefined$8;
    var wellKnownSymbol$g$1 = wellKnownSymbol$m;
    var SPECIES$5$1 = wellKnownSymbol$g$1("species");
    var speciesConstructor$1$2 = function(O, defaultConstructor) {
      var C2 = anObject$b$1(O).constructor;
      var S;
      return C2 === void 0 || isNullOrUndefined$5$1(S = anObject$b$1(C2)[SPECIES$5$1]) ? defaultConstructor : aConstructor$3(S);
    };
    var NATIVE_BIND$1$2 = functionBindNative$2;
    var FunctionPrototype$1$2 = Function.prototype;
    var apply$3 = FunctionPrototype$1$2.apply;
    var call$e$1 = FunctionPrototype$1$2.call;
    var functionApply$2 = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$1$2 ? call$e$1.bind(apply$3) : function() {
      return call$e$1.apply(apply$3, arguments);
    });
    var classofRaw$4 = classofRaw$2$2;
    var uncurryThis$j$1 = functionUncurryThis$2;
    var functionUncurryThisClause$2 = function(fn) {
      if (classofRaw$4(fn) === "Function")
        return uncurryThis$j$1(fn);
    };
    var uncurryThis$i$1 = functionUncurryThisClause$2;
    var aCallable$7$2 = aCallable$a;
    var NATIVE_BIND$5 = functionBindNative$2;
    var bind$7 = uncurryThis$i$1(uncurryThis$i$1.bind);
    var functionBindContext$2 = function(fn, that) {
      aCallable$7$2(fn);
      return that === void 0 ? fn : NATIVE_BIND$5 ? bind$7(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
    var getBuiltIn$2$2 = getBuiltIn$7$2;
    var html$2$1 = getBuiltIn$2$2("document", "documentElement");
    var uncurryThis$h$1 = functionUncurryThis$2;
    var arraySlice$3$1 = uncurryThis$h$1([].slice);
    var $TypeError$7$2 = TypeError;
    var validateArgumentsLength$1$2 = function(passed, required) {
      if (passed < required)
        throw new $TypeError$7$2("Not enough arguments");
      return passed;
    };
    var userAgent$4$1 = engineUserAgent$2;
    var engineIsIos$2 = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$4$1);
    var global$b$2 = global$n;
    var apply$2$1 = functionApply$2;
    var bind$6$1 = functionBindContext$2;
    var isCallable$a$2 = isCallable$o;
    var hasOwn$3$2 = hasOwnProperty_1$2;
    var fails$k$1 = fails$u;
    var html$1$2 = html$2$1;
    var arraySlice$2$1 = arraySlice$3$1;
    var createElement$3 = documentCreateElement$2$1;
    var validateArgumentsLength$3 = validateArgumentsLength$1$2;
    var IS_IOS$1$2 = engineIsIos$2;
    var IS_NODE$3$2 = engineIsNode$2;
    var set$1$2 = global$b$2.setImmediate;
    var clear$2 = global$b$2.clearImmediate;
    var process$2$2 = global$b$2.process;
    var Dispatch$2 = global$b$2.Dispatch;
    var Function$1$2 = global$b$2.Function;
    var MessageChannel$2 = global$b$2.MessageChannel;
    var String$1$2 = global$b$2.String;
    var counter$2 = 0;
    var queue$2$2 = {};
    var ONREADYSTATECHANGE$2 = "onreadystatechange";
    var $location$2, defer$2, channel$2, port$2;
    fails$k$1(function() {
      $location$2 = global$b$2.location;
    });
    var run$2 = function(id2) {
      if (hasOwn$3$2(queue$2$2, id2)) {
        var fn = queue$2$2[id2];
        delete queue$2$2[id2];
        fn();
      }
    };
    var runner$2 = function(id2) {
      return function() {
        run$2(id2);
      };
    };
    var eventListener$2 = function(event) {
      run$2(event.data);
    };
    var globalPostMessageDefer$2 = function(id2) {
      global$b$2.postMessage(String$1$2(id2), $location$2.protocol + "//" + $location$2.host);
    };
    if (!set$1$2 || !clear$2) {
      set$1$2 = function setImmediate(handler) {
        validateArgumentsLength$3(arguments.length, 1);
        var fn = isCallable$a$2(handler) ? handler : Function$1$2(handler);
        var args = arraySlice$2$1(arguments, 1);
        queue$2$2[++counter$2] = function() {
          apply$2$1(fn, void 0, args);
        };
        defer$2(counter$2);
        return counter$2;
      };
      clear$2 = function clearImmediate(id2) {
        delete queue$2$2[id2];
      };
      if (IS_NODE$3$2) {
        defer$2 = function(id2) {
          process$2$2.nextTick(runner$2(id2));
        };
      } else if (Dispatch$2 && Dispatch$2.now) {
        defer$2 = function(id2) {
          Dispatch$2.now(runner$2(id2));
        };
      } else if (MessageChannel$2 && !IS_IOS$1$2) {
        channel$2 = new MessageChannel$2();
        port$2 = channel$2.port2;
        channel$2.port1.onmessage = eventListener$2;
        defer$2 = bind$6$1(port$2.postMessage, port$2);
      } else if (global$b$2.addEventListener && isCallable$a$2(global$b$2.postMessage) && !global$b$2.importScripts && $location$2 && $location$2.protocol !== "file:" && !fails$k$1(globalPostMessageDefer$2)) {
        defer$2 = globalPostMessageDefer$2;
        global$b$2.addEventListener("message", eventListener$2, false);
      } else if (ONREADYSTATECHANGE$2 in createElement$3("script")) {
        defer$2 = function(id2) {
          html$1$2.appendChild(createElement$3("script"))[ONREADYSTATECHANGE$2] = function() {
            html$1$2.removeChild(this);
            run$2(id2);
          };
        };
      } else {
        defer$2 = function(id2) {
          setTimeout(runner$2(id2), 0);
        };
      }
    }
    var task$1$2 = {
      set: set$1$2,
      clear: clear$2
    };
    var Queue$2$2 = function() {
      this.head = null;
      this.tail = null;
    };
    Queue$2$2.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null)
            this.tail = null;
          return entry.item;
        }
      }
    };
    var queue$1$2 = Queue$2$2;
    var userAgent$3$2 = engineUserAgent$2;
    var engineIsIosPebble$2 = /ipad|iphone|ipod/i.test(userAgent$3$2) && typeof Pebble != "undefined";
    var userAgent$2$2 = engineUserAgent$2;
    var engineIsWebosWebkit$2 = /web0s(?!.*chrome)/i.test(userAgent$2$2);
    var global$a$2 = global$n;
    var bind$5$1 = functionBindContext$2;
    var getOwnPropertyDescriptor$1$2 = objectGetOwnPropertyDescriptor$2.f;
    var macrotask$2 = task$1$2.set;
    var Queue$1$2 = queue$1$2;
    var IS_IOS$3 = engineIsIos$2;
    var IS_IOS_PEBBLE$2 = engineIsIosPebble$2;
    var IS_WEBOS_WEBKIT$2 = engineIsWebosWebkit$2;
    var IS_NODE$2$2 = engineIsNode$2;
    var MutationObserver$3 = global$a$2.MutationObserver || global$a$2.WebKitMutationObserver;
    var document$2$2 = global$a$2.document;
    var process$1$2 = global$a$2.process;
    var Promise$3 = global$a$2.Promise;
    var queueMicrotaskDescriptor$2 = getOwnPropertyDescriptor$1$2(global$a$2, "queueMicrotask");
    var microtask$1$2 = queueMicrotaskDescriptor$2 && queueMicrotaskDescriptor$2.value;
    var notify$1$2, toggle$2, node$2, promise$2, then$2;
    if (!microtask$1$2) {
      var queue$4 = new Queue$1$2();
      var flush$2 = function() {
        var parent, fn;
        if (IS_NODE$2$2 && (parent = process$1$2.domain))
          parent.exit();
        while (fn = queue$4.get())
          try {
            fn();
          } catch (error) {
            if (queue$4.head)
              notify$1$2();
            throw error;
          }
        if (parent)
          parent.enter();
      };
      if (!IS_IOS$3 && !IS_NODE$2$2 && !IS_WEBOS_WEBKIT$2 && MutationObserver$3 && document$2$2) {
        toggle$2 = true;
        node$2 = document$2$2.createTextNode("");
        new MutationObserver$3(flush$2).observe(node$2, { characterData: true });
        notify$1$2 = function() {
          node$2.data = toggle$2 = !toggle$2;
        };
      } else if (!IS_IOS_PEBBLE$2 && Promise$3 && Promise$3.resolve) {
        promise$2 = Promise$3.resolve(void 0);
        promise$2.constructor = Promise$3;
        then$2 = bind$5$1(promise$2.then, promise$2);
        notify$1$2 = function() {
          then$2(flush$2);
        };
      } else if (IS_NODE$2$2) {
        notify$1$2 = function() {
          process$1$2.nextTick(flush$2);
        };
      } else {
        macrotask$2 = bind$5$1(macrotask$2, global$a$2);
        notify$1$2 = function() {
          macrotask$2(flush$2);
        };
      }
      microtask$1$2 = function(fn) {
        if (!queue$4.head)
          notify$1$2();
        queue$4.add(fn);
      };
    }
    var microtask_1$2 = microtask$1$2;
    var hostReportErrors$1$2 = function(a2, b) {
      try {
        arguments.length === 1 ? console.error(a2) : console.error(a2, b);
      } catch (error) {
      }
    };
    var perform$4$1 = function(exec2) {
      try {
        return { error: false, value: exec2() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
    var global$9$2 = global$n;
    var promiseNativeConstructor$2 = global$9$2.Promise;
    var engineIsDeno$2 = typeof Deno == "object" && Deno && typeof Deno.version == "object";
    var IS_DENO$1$2 = engineIsDeno$2;
    var IS_NODE$1$2 = engineIsNode$2;
    var engineIsBrowser$2 = !IS_DENO$1$2 && !IS_NODE$1$2 && typeof window == "object" && typeof document == "object";
    var global$8$2 = global$n;
    var NativePromiseConstructor$3$2 = promiseNativeConstructor$2;
    var isCallable$9$2 = isCallable$o;
    var isForced$1$2 = isForced_1$2;
    var inspectSource$5 = inspectSource$3$2;
    var wellKnownSymbol$f$1 = wellKnownSymbol$m;
    var IS_BROWSER$2 = engineIsBrowser$2;
    var IS_DENO$3 = engineIsDeno$2;
    var V8_VERSION$2$1 = engineV8Version$2;
    NativePromiseConstructor$3$2 && NativePromiseConstructor$3$2.prototype;
    var SPECIES$4$1 = wellKnownSymbol$f$1("species");
    var SUBCLASSING$2 = false;
    var NATIVE_PROMISE_REJECTION_EVENT$1$2 = isCallable$9$2(global$8$2.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR$5$2 = isForced$1$2("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource$5(NativePromiseConstructor$3$2);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3$2);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION$2$1 === 66)
        return true;
      if (!V8_VERSION$2$1 || V8_VERSION$2$1 < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise2 = new NativePromiseConstructor$3$2(function(resolve) {
          resolve(1);
        });
        var FakePromise = function(exec2) {
          exec2(function() {
          }, function() {
          });
        };
        var constructor = promise2.constructor = {};
        constructor[SPECIES$4$1] = FakePromise;
        SUBCLASSING$2 = promise2.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING$2)
          return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER$2 || IS_DENO$3) && !NATIVE_PROMISE_REJECTION_EVENT$1$2;
    });
    var promiseConstructorDetection$2 = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5$2,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1$2,
      SUBCLASSING: SUBCLASSING$2
    };
    var newPromiseCapability$2$2 = {};
    var aCallable$6$2 = aCallable$a;
    var $TypeError$6$2 = TypeError;
    var PromiseCapability$2 = function(C2) {
      var resolve, reject;
      this.promise = new C2(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0)
          throw new $TypeError$6$2("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable$6$2(resolve);
      this.reject = aCallable$6$2(reject);
    };
    newPromiseCapability$2$2.f = function(C2) {
      return new PromiseCapability$2(C2);
    };
    var $$p = _export$2;
    var IS_NODE$5 = engineIsNode$2;
    var global$7$2 = global$n;
    var call$d$2 = functionCall$2;
    var defineBuiltIn$6$1 = defineBuiltIn$9$1;
    var setPrototypeOf$2$1 = objectSetPrototypeOf$2;
    var setToStringTag$4$1 = setToStringTag$5$1;
    var setSpecies$1$2 = setSpecies$2$1;
    var aCallable$5$2 = aCallable$a;
    var isCallable$8$2 = isCallable$o;
    var isObject$d$1 = isObject$j;
    var anInstance$3$1 = anInstance$4$1;
    var speciesConstructor$3 = speciesConstructor$1$2;
    var task$3 = task$1$2.set;
    var microtask$3 = microtask_1$2;
    var hostReportErrors$3 = hostReportErrors$1$2;
    var perform$3$2 = perform$4$1;
    var Queue$4 = queue$1$2;
    var InternalStateModule$4$1 = internalState$2;
    var NativePromiseConstructor$2$2 = promiseNativeConstructor$2;
    var PromiseConstructorDetection$2 = promiseConstructorDetection$2;
    var newPromiseCapabilityModule$4$1 = newPromiseCapability$2$2;
    var PROMISE$2 = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR$4$2 = PromiseConstructorDetection$2.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT$3 = PromiseConstructorDetection$2.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING$2 = PromiseConstructorDetection$2.SUBCLASSING;
    var getInternalPromiseState$2 = InternalStateModule$4$1.getterFor(PROMISE$2);
    var setInternalState$4$1 = InternalStateModule$4$1.set;
    var NativePromisePrototype$1$2 = NativePromiseConstructor$2$2 && NativePromiseConstructor$2$2.prototype;
    var PromiseConstructor$2 = NativePromiseConstructor$2$2;
    var PromisePrototype$2 = NativePromisePrototype$1$2;
    var TypeError$1$2 = global$7$2.TypeError;
    var document$1$2 = global$7$2.document;
    var process$5 = global$7$2.process;
    var newPromiseCapability$1$2 = newPromiseCapabilityModule$4$1.f;
    var newGenericPromiseCapability$2 = newPromiseCapability$1$2;
    var DISPATCH_EVENT$2 = !!(document$1$2 && document$1$2.createEvent && global$7$2.dispatchEvent);
    var UNHANDLED_REJECTION$2 = "unhandledrejection";
    var REJECTION_HANDLED$2 = "rejectionhandled";
    var PENDING$2 = 0;
    var FULFILLED$2 = 1;
    var REJECTED$2 = 2;
    var HANDLED$2 = 1;
    var UNHANDLED$2 = 2;
    var Internal$2, OwnPromiseCapability$2, PromiseWrapper$2, nativeThen$2;
    var isThenable$2 = function(it) {
      var then2;
      return isObject$d$1(it) && isCallable$8$2(then2 = it.then) ? then2 : false;
    };
    var callReaction$2 = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED$2;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then2, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED$2)
              onHandleUnhandled$2(state);
            state.rejection = HANDLED$2;
          }
          if (handler === true)
            result = value;
          else {
            if (domain)
              domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError$1$2("Promise-chain cycle"));
          } else if (then2 = isThenable$2(result)) {
            call$d$2(then2, result, resolve, reject);
          } else
            resolve(result);
        } else
          reject(value);
      } catch (error) {
        if (domain && !exited)
          domain.exit();
        reject(error);
      }
    };
    var notify$3 = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      microtask$3(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction$2(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled$2(state);
      });
    };
    var dispatchEvent$2 = function(name, promise2, reason) {
      var event, handler;
      if (DISPATCH_EVENT$2) {
        event = document$1$2.createEvent("Event");
        event.promise = promise2;
        event.reason = reason;
        event.initEvent(name, false, true);
        global$7$2.dispatchEvent(event);
      } else
        event = { promise: promise2, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT$3 && (handler = global$7$2["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION$2)
        hostReportErrors$3("Unhandled promise rejection", reason);
    };
    var onUnhandled$2 = function(state) {
      call$d$2(task$3, global$7$2, function() {
        var promise2 = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled$2(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform$3$2(function() {
            if (IS_NODE$5) {
              process$5.emit("unhandledRejection", value, promise2);
            } else
              dispatchEvent$2(UNHANDLED_REJECTION$2, promise2, value);
          });
          state.rejection = IS_NODE$5 || isUnhandled$2(state) ? UNHANDLED$2 : HANDLED$2;
          if (result.error)
            throw result.value;
        }
      });
    };
    var isUnhandled$2 = function(state) {
      return state.rejection !== HANDLED$2 && !state.parent;
    };
    var onHandleUnhandled$2 = function(state) {
      call$d$2(task$3, global$7$2, function() {
        var promise2 = state.facade;
        if (IS_NODE$5) {
          process$5.emit("rejectionHandled", promise2);
        } else
          dispatchEvent$2(REJECTION_HANDLED$2, promise2, state.value);
      });
    };
    var bind$4$2 = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject$2 = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED$2;
      notify$3(state, true);
    };
    var internalResolve$2 = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw new TypeError$1$2("Promise can't be resolved itself");
        var then2 = isThenable$2(value);
        if (then2) {
          microtask$3(function() {
            var wrapper = { done: false };
            try {
              call$d$2(
                then2,
                value,
                bind$4$2(internalResolve$2, wrapper, state),
                bind$4$2(internalReject$2, wrapper, state)
              );
            } catch (error) {
              internalReject$2(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED$2;
          notify$3(state, false);
        }
      } catch (error) {
        internalReject$2({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR$4$2) {
      PromiseConstructor$2 = function Promise2(executor) {
        anInstance$3$1(this, PromisePrototype$2);
        aCallable$5$2(executor);
        call$d$2(Internal$2, this);
        var state = getInternalPromiseState$2(this);
        try {
          executor(bind$4$2(internalResolve$2, state), bind$4$2(internalReject$2, state));
        } catch (error) {
          internalReject$2(state, error);
        }
      };
      PromisePrototype$2 = PromiseConstructor$2.prototype;
      Internal$2 = function Promise2(executor) {
        setInternalState$4$1(this, {
          type: PROMISE$2,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue$4(),
          rejection: false,
          state: PENDING$2,
          value: void 0
        });
      };
      Internal$2.prototype = defineBuiltIn$6$1(PromisePrototype$2, "then", function then2(onFulfilled, onRejected) {
        var state = getInternalPromiseState$2(this);
        var reaction = newPromiseCapability$1$2(speciesConstructor$3(this, PromiseConstructor$2));
        state.parent = true;
        reaction.ok = isCallable$8$2(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable$8$2(onRejected) && onRejected;
        reaction.domain = IS_NODE$5 ? process$5.domain : void 0;
        if (state.state === PENDING$2)
          state.reactions.add(reaction);
        else
          microtask$3(function() {
            callReaction$2(reaction, state);
          });
        return reaction.promise;
      });
      OwnPromiseCapability$2 = function() {
        var promise2 = new Internal$2();
        var state = getInternalPromiseState$2(promise2);
        this.promise = promise2;
        this.resolve = bind$4$2(internalResolve$2, state);
        this.reject = bind$4$2(internalReject$2, state);
      };
      newPromiseCapabilityModule$4$1.f = newPromiseCapability$1$2 = function(C2) {
        return C2 === PromiseConstructor$2 || C2 === PromiseWrapper$2 ? new OwnPromiseCapability$2(C2) : newGenericPromiseCapability$2(C2);
      };
      if (isCallable$8$2(NativePromiseConstructor$2$2) && NativePromisePrototype$1$2 !== Object.prototype) {
        nativeThen$2 = NativePromisePrototype$1$2.then;
        if (!NATIVE_PROMISE_SUBCLASSING$2) {
          defineBuiltIn$6$1(NativePromisePrototype$1$2, "then", function then2(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor$2(function(resolve, reject) {
              call$d$2(nativeThen$2, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype$1$2.constructor;
        } catch (error) {
        }
        if (setPrototypeOf$2$1) {
          setPrototypeOf$2$1(NativePromisePrototype$1$2, PromisePrototype$2);
        }
      }
    }
    $$p({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4$2 }, {
      Promise: PromiseConstructor$2
    });
    setToStringTag$4$1(PromiseConstructor$2, PROMISE$2, false);
    setSpecies$1$2(PROMISE$2);
    var iterators$2 = {};
    var wellKnownSymbol$e$1 = wellKnownSymbol$m;
    var Iterators$4$1 = iterators$2;
    var ITERATOR$5$1 = wellKnownSymbol$e$1("iterator");
    var ArrayPrototype$1$1 = Array.prototype;
    var isArrayIteratorMethod$2$1 = function(it) {
      return it !== void 0 && (Iterators$4$1.Array === it || ArrayPrototype$1$1[ITERATOR$5$1] === it);
    };
    var classof$6$1 = classof$b;
    var getMethod$2$2 = getMethod$4$1;
    var isNullOrUndefined$4$2 = isNullOrUndefined$8;
    var Iterators$3$1 = iterators$2;
    var wellKnownSymbol$d$1 = wellKnownSymbol$m;
    var ITERATOR$4$1 = wellKnownSymbol$d$1("iterator");
    var getIteratorMethod$3$1 = function(it) {
      if (!isNullOrUndefined$4$2(it))
        return getMethod$2$2(it, ITERATOR$4$1) || getMethod$2$2(it, "@@iterator") || Iterators$3$1[classof$6$1(it)];
    };
    var call$c$2 = functionCall$2;
    var aCallable$4$2 = aCallable$a;
    var anObject$a$1 = anObject$f;
    var tryToString$2$2 = tryToString$5$1;
    var getIteratorMethod$2$2 = getIteratorMethod$3$1;
    var $TypeError$5$2 = TypeError;
    var getIterator$2$1 = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2$2(argument) : usingIterator;
      if (aCallable$4$2(iteratorMethod))
        return anObject$a$1(call$c$2(iteratorMethod, argument));
      throw new $TypeError$5$2(tryToString$2$2(argument) + " is not iterable");
    };
    var call$b$2 = functionCall$2;
    var anObject$9$1 = anObject$f;
    var getMethod$1$2 = getMethod$4$1;
    var iteratorClose$2$1 = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject$9$1(iterator);
      try {
        innerResult = getMethod$1$2(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call$b$2(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject$9$1(innerResult);
      return value;
    };
    var bind$3$2 = functionBindContext$2;
    var call$a$2 = functionCall$2;
    var anObject$8$2 = anObject$f;
    var tryToString$1$2 = tryToString$5$1;
    var isArrayIteratorMethod$1$2 = isArrayIteratorMethod$2$1;
    var lengthOfArrayLike$7 = lengthOfArrayLike$9;
    var isPrototypeOf$4 = objectIsPrototypeOf$2;
    var getIterator$1$2 = getIterator$2$1;
    var getIteratorMethod$1$2 = getIteratorMethod$3$1;
    var iteratorClose$1$2 = iteratorClose$2$1;
    var $TypeError$4$2 = TypeError;
    var Result$2 = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype$2 = Result$2.prototype;
    var iterate$6 = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind$3$2(unboundFunction, that);
      var iterator, iterFn, index, length2, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose$1$2(iterator, "normal", condition);
        return new Result$2(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject$8$2(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod$1$2(iterable);
        if (!iterFn)
          throw new $TypeError$4$2(tryToString$1$2(iterable) + " is not iterable");
        if (isArrayIteratorMethod$1$2(iterFn)) {
          for (index = 0, length2 = lengthOfArrayLike$7(iterable); length2 > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf$4(ResultPrototype$2, result))
              return result;
          }
          return new Result$2(false);
        }
        iterator = getIterator$1$2(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call$a$2(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose$1$2(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf$4(ResultPrototype$2, result))
          return result;
      }
      return new Result$2(false);
    };
    var wellKnownSymbol$c$1 = wellKnownSymbol$m;
    var ITERATOR$3$1 = wellKnownSymbol$c$1("iterator");
    var SAFE_CLOSING$2 = false;
    try {
      var called$2 = 0;
      var iteratorWithReturn$2 = {
        next: function() {
          return { done: !!called$2++ };
        },
        "return": function() {
          SAFE_CLOSING$2 = true;
        }
      };
      iteratorWithReturn$2[ITERATOR$3$1] = function() {
        return this;
      };
      Array.from(iteratorWithReturn$2, function() {
        throw 2;
      });
    } catch (error) {
    }
    var checkCorrectnessOfIteration$3$1 = function(exec2, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING$2)
          return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object2 = {};
        object2[ITERATOR$3$1] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec2(object2);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
    var NativePromiseConstructor$1$2 = promiseNativeConstructor$2;
    var checkCorrectnessOfIteration$2$1 = checkCorrectnessOfIteration$3$1;
    var FORCED_PROMISE_CONSTRUCTOR$3$2 = promiseConstructorDetection$2.CONSTRUCTOR;
    var promiseStaticsIncorrectIteration$2 = FORCED_PROMISE_CONSTRUCTOR$3$2 || !checkCorrectnessOfIteration$2$1(function(iterable) {
      NativePromiseConstructor$1$2.all(iterable).then(void 0, function() {
      });
    });
    var $$o = _export$2;
    var call$9$2 = functionCall$2;
    var aCallable$3$2 = aCallable$a;
    var newPromiseCapabilityModule$3$2 = newPromiseCapability$2$2;
    var perform$2$2 = perform$4$1;
    var iterate$5$1 = iterate$6;
    var PROMISE_STATICS_INCORRECT_ITERATION$2$1 = promiseStaticsIncorrectIteration$2;
    $$o({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$2$1 }, {
      all: function all(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule$3$2.f(C2);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform$2$2(function() {
          var $promiseResolve = aCallable$3$2(C2.resolve);
          var values2 = [];
          var counter2 = 0;
          var remaining = 1;
          iterate$5$1(iterable, function(promise2) {
            var index = counter2++;
            var alreadyCalled = false;
            remaining++;
            call$9$2($promiseResolve, C2, promise2).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values2[index] = value;
              --remaining || resolve(values2);
            }, reject);
          });
          --remaining || resolve(values2);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
    var $$n = _export$2;
    var FORCED_PROMISE_CONSTRUCTOR$2$2 = promiseConstructorDetection$2.CONSTRUCTOR;
    var NativePromiseConstructor$5 = promiseNativeConstructor$2;
    var getBuiltIn$1$2 = getBuiltIn$7$2;
    var isCallable$7$2 = isCallable$o;
    var defineBuiltIn$5$1 = defineBuiltIn$9$1;
    var NativePromisePrototype$3 = NativePromiseConstructor$5 && NativePromiseConstructor$5.prototype;
    $$n({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2$2, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (isCallable$7$2(NativePromiseConstructor$5)) {
      var method$2 = getBuiltIn$1$2("Promise").prototype["catch"];
      if (NativePromisePrototype$3["catch"] !== method$2) {
        defineBuiltIn$5$1(NativePromisePrototype$3, "catch", method$2, { unsafe: true });
      }
    }
    var $$m = _export$2;
    var call$8$2 = functionCall$2;
    var aCallable$2$2 = aCallable$a;
    var newPromiseCapabilityModule$2$2 = newPromiseCapability$2$2;
    var perform$1$2 = perform$4$1;
    var iterate$4$1 = iterate$6;
    var PROMISE_STATICS_INCORRECT_ITERATION$1$2 = promiseStaticsIncorrectIteration$2;
    $$m({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1$2 }, {
      race: function race(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule$2$2.f(C2);
        var reject = capability.reject;
        var result = perform$1$2(function() {
          var $promiseResolve = aCallable$2$2(C2.resolve);
          iterate$4$1(iterable, function(promise2) {
            call$8$2($promiseResolve, C2, promise2).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
    var $$l = _export$2;
    var call$7$2 = functionCall$2;
    var newPromiseCapabilityModule$1$2 = newPromiseCapability$2$2;
    var FORCED_PROMISE_CONSTRUCTOR$1$2 = promiseConstructorDetection$2.CONSTRUCTOR;
    $$l({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1$2 }, {
      reject: function reject(r) {
        var capability = newPromiseCapabilityModule$1$2.f(this);
        call$7$2(capability.reject, void 0, r);
        return capability.promise;
      }
    });
    var anObject$7$2 = anObject$f;
    var isObject$c$1 = isObject$j;
    var newPromiseCapability$4 = newPromiseCapability$2$2;
    var promiseResolve$1$2 = function(C2, x) {
      anObject$7$2(C2);
      if (isObject$c$1(x) && x.constructor === C2)
        return x;
      var promiseCapability = newPromiseCapability$4.f(C2);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };
    var $$k = _export$2;
    var getBuiltIn$9 = getBuiltIn$7$2;
    var FORCED_PROMISE_CONSTRUCTOR$7 = promiseConstructorDetection$2.CONSTRUCTOR;
    var promiseResolve$3 = promiseResolve$1$2;
    getBuiltIn$9("Promise");
    $$k({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$7 }, {
      resolve: function resolve(x) {
        return promiseResolve$3(this, x);
      }
    });
    var objectDefineProperties$1 = {};
    var internalObjectKeys$3 = objectKeysInternal$2;
    var enumBugKeys$1$2 = enumBugKeys$3$1;
    var objectKeys$3$1 = Object.keys || function keys2(O) {
      return internalObjectKeys$3(O, enumBugKeys$1$2);
    };
    var DESCRIPTORS$5$2 = descriptors$2;
    var V8_PROTOTYPE_DEFINE_BUG$3 = v8PrototypeDefineBug$2;
    var definePropertyModule$1$2 = objectDefineProperty$2;
    var anObject$6$2 = anObject$f;
    var toIndexedObject$5$1 = toIndexedObject$9;
    var objectKeys$2$1 = objectKeys$3$1;
    objectDefineProperties$1.f = DESCRIPTORS$5$2 && !V8_PROTOTYPE_DEFINE_BUG$3 ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject$6$2(O);
      var props = toIndexedObject$5$1(Properties);
      var keys2 = objectKeys$2$1(Properties);
      var length2 = keys2.length;
      var index = 0;
      var key;
      while (length2 > index)
        definePropertyModule$1$2.f(O, key = keys2[index++], props[key]);
      return O;
    };
    var anObject$5$2 = anObject$f;
    var definePropertiesModule$1 = objectDefineProperties$1;
    var enumBugKeys$5 = enumBugKeys$3$1;
    var hiddenKeys$1$2 = hiddenKeys$5$1;
    var html$4 = html$2$1;
    var documentCreateElement$1$1 = documentCreateElement$2$1;
    var sharedKey$1$2 = sharedKey$3$1;
    var GT$1 = ">";
    var LT$1 = "<";
    var PROTOTYPE$1 = "prototype";
    var SCRIPT$1 = "script";
    var IE_PROTO$1$1 = sharedKey$1$2("IE_PROTO");
    var EmptyConstructor$1 = function() {
    };
    var scriptTag$1 = function(content) {
      return LT$1 + SCRIPT$1 + GT$1 + content + LT$1 + "/" + SCRIPT$1 + GT$1;
    };
    var NullProtoObjectViaActiveX$1 = function(activeXDocument2) {
      activeXDocument2.write(scriptTag$1(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame$1 = function() {
      var iframe = documentCreateElement$1$1("iframe");
      var JS = "java" + SCRIPT$1 + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html$4.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag$1("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument$1;
    var NullProtoObject$1 = function() {
      try {
        activeXDocument$1 = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject$1 = typeof document != "undefined" ? document.domain && activeXDocument$1 ? NullProtoObjectViaActiveX$1(activeXDocument$1) : NullProtoObjectViaIFrame$1() : NullProtoObjectViaActiveX$1(activeXDocument$1);
      var length2 = enumBugKeys$5.length;
      while (length2--)
        delete NullProtoObject$1[PROTOTYPE$1][enumBugKeys$5[length2]];
      return NullProtoObject$1();
    };
    hiddenKeys$1$2[IE_PROTO$1$1] = true;
    var objectCreate$1 = Object.create || function create2(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor$1[PROTOTYPE$1] = anObject$5$2(O);
        result = new EmptyConstructor$1();
        EmptyConstructor$1[PROTOTYPE$1] = null;
        result[IE_PROTO$1$1] = O;
      } else
        result = NullProtoObject$1();
      return Properties === void 0 ? result : definePropertiesModule$1.f(result, Properties);
    };
    var wellKnownSymbol$b$1 = wellKnownSymbol$m;
    var create$3 = objectCreate$1;
    var defineProperty$5$1 = objectDefineProperty$2.f;
    var UNSCOPABLES$1 = wellKnownSymbol$b$1("unscopables");
    var ArrayPrototype$3 = Array.prototype;
    if (ArrayPrototype$3[UNSCOPABLES$1] === void 0) {
      defineProperty$5$1(ArrayPrototype$3, UNSCOPABLES$1, {
        configurable: true,
        value: create$3(null)
      });
    }
    var addToUnscopables$3 = function(key) {
      ArrayPrototype$3[UNSCOPABLES$1][key] = true;
    };
    var fails$j$1 = fails$u;
    var correctPrototypeGetter$1 = !fails$j$1(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
    var hasOwn$2$2 = hasOwnProperty_1$2;
    var isCallable$6$2 = isCallable$o;
    var toObject$8 = toObject$a;
    var sharedKey$5 = sharedKey$3$1;
    var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter$1;
    var IE_PROTO$2 = sharedKey$5("IE_PROTO");
    var $Object$6 = Object;
    var ObjectPrototype$1 = $Object$6.prototype;
    var objectGetPrototypeOf$1 = CORRECT_PROTOTYPE_GETTER$1 ? $Object$6.getPrototypeOf : function(O) {
      var object2 = toObject$8(O);
      if (hasOwn$2$2(object2, IE_PROTO$2))
        return object2[IE_PROTO$2];
      var constructor = object2.constructor;
      if (isCallable$6$2(constructor) && object2 instanceof constructor) {
        return constructor.prototype;
      }
      return object2 instanceof $Object$6 ? ObjectPrototype$1 : null;
    };
    var fails$i$1 = fails$u;
    var isCallable$5$2 = isCallable$o;
    var isObject$b$1 = isObject$j;
    var getPrototypeOf$1$1 = objectGetPrototypeOf$1;
    var defineBuiltIn$4$2 = defineBuiltIn$9$1;
    var wellKnownSymbol$a$2 = wellKnownSymbol$m;
    var ITERATOR$2$2 = wellKnownSymbol$a$2("iterator");
    var BUGGY_SAFARI_ITERATORS$1$1 = false;
    var IteratorPrototype$2$1, PrototypeOfArrayIteratorPrototype$1, arrayIterator$1;
    if ([].keys) {
      arrayIterator$1 = [].keys();
      if (!("next" in arrayIterator$1))
        BUGGY_SAFARI_ITERATORS$1$1 = true;
      else {
        PrototypeOfArrayIteratorPrototype$1 = getPrototypeOf$1$1(getPrototypeOf$1$1(arrayIterator$1));
        if (PrototypeOfArrayIteratorPrototype$1 !== Object.prototype)
          IteratorPrototype$2$1 = PrototypeOfArrayIteratorPrototype$1;
      }
    }
    var NEW_ITERATOR_PROTOTYPE$1 = !isObject$b$1(IteratorPrototype$2$1) || fails$i$1(function() {
      var test2 = {};
      return IteratorPrototype$2$1[ITERATOR$2$2].call(test2) !== test2;
    });
    if (NEW_ITERATOR_PROTOTYPE$1)
      IteratorPrototype$2$1 = {};
    if (!isCallable$5$2(IteratorPrototype$2$1[ITERATOR$2$2])) {
      defineBuiltIn$4$2(IteratorPrototype$2$1, ITERATOR$2$2, function() {
        return this;
      });
    }
    var iteratorsCore$1 = {
      IteratorPrototype: IteratorPrototype$2$1,
      BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1$1
    };
    var IteratorPrototype$1$1 = iteratorsCore$1.IteratorPrototype;
    var create$2$1 = objectCreate$1;
    var createPropertyDescriptor$1$2 = createPropertyDescriptor$4$1;
    var setToStringTag$3$1 = setToStringTag$5$1;
    var Iterators$2$1 = iterators$2;
    var returnThis$1$1 = function() {
      return this;
    };
    var iteratorCreateConstructor$1 = function(IteratorConstructor, NAME2, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG2 = NAME2 + " Iterator";
      IteratorConstructor.prototype = create$2$1(IteratorPrototype$1$1, { next: createPropertyDescriptor$1$2(+!ENUMERABLE_NEXT, next) });
      setToStringTag$3$1(IteratorConstructor, TO_STRING_TAG2, false);
      Iterators$2$1[TO_STRING_TAG2] = returnThis$1$1;
      return IteratorConstructor;
    };
    var $$j = _export$2;
    var call$6$2 = functionCall$2;
    var FunctionName$1 = functionName$2;
    var isCallable$4$2 = isCallable$o;
    var createIteratorConstructor$1 = iteratorCreateConstructor$1;
    var getPrototypeOf$2 = objectGetPrototypeOf$1;
    var setPrototypeOf$1$1 = objectSetPrototypeOf$2;
    var setToStringTag$2$1 = setToStringTag$5$1;
    var createNonEnumerableProperty$3$1 = createNonEnumerableProperty$6;
    var defineBuiltIn$3$2 = defineBuiltIn$9$1;
    var wellKnownSymbol$9$2 = wellKnownSymbol$m;
    var Iterators$1$2 = iterators$2;
    var IteratorsCore$1 = iteratorsCore$1;
    var PROPER_FUNCTION_NAME$1 = FunctionName$1.PROPER;
    var CONFIGURABLE_FUNCTION_NAME$3 = FunctionName$1.CONFIGURABLE;
    var IteratorPrototype$3 = IteratorsCore$1.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS$2 = IteratorsCore$1.BUGGY_SAFARI_ITERATORS;
    var ITERATOR$1$2 = wellKnownSymbol$9$2("iterator");
    var KEYS$1 = "keys";
    var VALUES$1 = "values";
    var ENTRIES$1 = "entries";
    var returnThis$2 = function() {
      return this;
    };
    var iteratorDefine$1 = function(Iterable, NAME2, IteratorConstructor, next, DEFAULT, IS_SET, FORCED2) {
      createIteratorConstructor$1(IteratorConstructor, NAME2, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS$2 && KIND && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS$1:
            return function keys2() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES$1:
            return function values2() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES$1:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG2 = NAME2 + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR$1$2] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS$2 && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME2 === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype$3) {
            if (setPrototypeOf$1$1) {
              setPrototypeOf$1$1(CurrentIteratorPrototype, IteratorPrototype$3);
            } else if (!isCallable$4$2(CurrentIteratorPrototype[ITERATOR$1$2])) {
              defineBuiltIn$3$2(CurrentIteratorPrototype, ITERATOR$1$2, returnThis$2);
            }
          }
          setToStringTag$2$1(CurrentIteratorPrototype, TO_STRING_TAG2, true);
        }
      }
      if (PROPER_FUNCTION_NAME$1 && DEFAULT === VALUES$1 && nativeIterator && nativeIterator.name !== VALUES$1) {
        if (CONFIGURABLE_FUNCTION_NAME$3) {
          createNonEnumerableProperty$3$1(IterablePrototype, "name", VALUES$1);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values2() {
            return call$6$2(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES$1),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS$1),
          entries: getIterationMethod(ENTRIES$1)
        };
        if (FORCED2)
          for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS$2 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn$3$2(IterablePrototype, KEY, methods[KEY]);
            }
          }
        else
          $$j({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS$2 || INCORRECT_VALUES_NAME }, methods);
      }
      if (IterablePrototype[ITERATOR$1$2] !== defaultIterator) {
        defineBuiltIn$3$2(IterablePrototype, ITERATOR$1$2, defaultIterator, { name: DEFAULT });
      }
      Iterators$1$2[NAME2] = defaultIterator;
      return methods;
    };
    var createIterResultObject$3 = function(value, done) {
      return { value, done };
    };
    var toIndexedObject$4$1 = toIndexedObject$9;
    var addToUnscopables$2 = addToUnscopables$3;
    var Iterators$6 = iterators$2;
    var InternalStateModule$3$1 = internalState$2;
    var defineProperty$4$2 = objectDefineProperty$2.f;
    var defineIterator$2 = iteratorDefine$1;
    var createIterResultObject$2$1 = createIterResultObject$3;
    var DESCRIPTORS$4$2 = descriptors$2;
    var ARRAY_ITERATOR$1 = "Array Iterator";
    var setInternalState$3$1 = InternalStateModule$3$1.set;
    var getInternalState$2$1 = InternalStateModule$3$1.getterFor(ARRAY_ITERATOR$1);
    var es_array_iterator$1 = defineIterator$2(Array, "Array", function(iterated, kind) {
      setInternalState$3$1(this, {
        type: ARRAY_ITERATOR$1,
        target: toIndexedObject$4$1(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState$2$1(this);
      var target = state.target;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = void 0;
        return createIterResultObject$2$1(void 0, true);
      }
      switch (state.kind) {
        case "keys":
          return createIterResultObject$2$1(index, false);
        case "values":
          return createIterResultObject$2$1(target[index], false);
      }
      return createIterResultObject$2$1([index, target[index]], false);
    }, "values");
    var values$1 = Iterators$6.Arguments = Iterators$6.Array;
    addToUnscopables$2("keys");
    addToUnscopables$2("values");
    addToUnscopables$2("entries");
    if (DESCRIPTORS$4$2 && values$1.name !== "values")
      try {
        defineProperty$4$2(values$1, "name", { value: "values" });
      } catch (error) {
      }
    var $$i = _export$2;
    var call$5$2 = functionCall$2;
    var aCallable$1$2 = aCallable$a;
    var newPromiseCapabilityModule$5 = newPromiseCapability$2$2;
    var perform$5 = perform$4$1;
    var iterate$3$1 = iterate$6;
    var PROMISE_STATICS_INCORRECT_ITERATION$3 = promiseStaticsIncorrectIteration$2;
    $$i({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$3 }, {
      allSettled: function allSettled(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule$5.f(C2);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform$5(function() {
          var promiseResolve2 = aCallable$1$2(C2.resolve);
          var values2 = [];
          var counter2 = 0;
          var remaining = 1;
          iterate$3$1(iterable, function(promise2) {
            var index = counter2++;
            var alreadyCalled = false;
            remaining++;
            call$5$2(promiseResolve2, C2, promise2).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values2[index] = { status: "fulfilled", value };
              --remaining || resolve(values2);
            }, function(error) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values2[index] = { status: "rejected", reason: error };
              --remaining || resolve(values2);
            });
          });
          --remaining || resolve(values2);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
    var classof$5$2 = classof$b;
    var $String$7 = String;
    var toString$9 = function(argument) {
      if (classof$5$2(argument) === "Symbol")
        throw new TypeError("Cannot convert a Symbol value to a string");
      return $String$7(argument);
    };
    var uncurryThis$g$1 = functionUncurryThis$2;
    var toIntegerOrInfinity$1$2 = toIntegerOrInfinity$4$1;
    var toString$8 = toString$9;
    var requireObjectCoercible$4$1 = requireObjectCoercible$7;
    var charAt$4 = uncurryThis$g$1("".charAt);
    var charCodeAt$1 = uncurryThis$g$1("".charCodeAt);
    var stringSlice$4 = uncurryThis$g$1("".slice);
    var createMethod$3$1 = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = toString$8(requireObjectCoercible$4$1($this));
        var position2 = toIntegerOrInfinity$1$2(pos);
        var size = S.length;
        var first, second2;
        if (position2 < 0 || position2 >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt$1(S, position2);
        return first < 55296 || first > 56319 || position2 + 1 === size || (second2 = charCodeAt$1(S, position2 + 1)) < 56320 || second2 > 57343 ? CONVERT_TO_STRING ? charAt$4(S, position2) : first : CONVERT_TO_STRING ? stringSlice$4(S, position2, position2 + 2) : (first - 55296 << 10) + (second2 - 56320) + 65536;
      };
    };
    var stringMultibyte$1 = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod$3$1(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod$3$1(true)
    };
    var charAt$3 = stringMultibyte$1.charAt;
    var toString$7 = toString$9;
    var InternalStateModule$2$1 = internalState$2;
    var defineIterator$1$1 = iteratorDefine$1;
    var createIterResultObject$1$1 = createIterResultObject$3;
    var STRING_ITERATOR$1 = "String Iterator";
    var setInternalState$2$1 = InternalStateModule$2$1.set;
    var getInternalState$1$1 = InternalStateModule$2$1.getterFor(STRING_ITERATOR$1);
    defineIterator$1$1(String, "String", function(iterated) {
      setInternalState$2$1(this, {
        type: STRING_ITERATOR$1,
        string: toString$7(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState$1$1(this);
      var string2 = state.string;
      var index = state.index;
      var point2;
      if (index >= string2.length)
        return createIterResultObject$1$1(void 0, true);
      point2 = charAt$3(string2, index);
      state.index += point2.length;
      return createIterResultObject$1$1(point2, false);
    });
    var domIterables$1 = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
    var documentCreateElement$4 = documentCreateElement$2$1;
    var classList$1 = documentCreateElement$4("span").classList;
    var DOMTokenListPrototype$2 = classList$1 && classList$1.constructor && classList$1.constructor.prototype;
    var domTokenListPrototype$1 = DOMTokenListPrototype$2 === Object.prototype ? void 0 : DOMTokenListPrototype$2;
    var global$6$2 = global$n;
    var DOMIterables$1 = domIterables$1;
    var DOMTokenListPrototype$1$1 = domTokenListPrototype$1;
    var ArrayIteratorMethods$1 = es_array_iterator$1;
    var createNonEnumerableProperty$2$2 = createNonEnumerableProperty$6;
    var setToStringTag$1$2 = setToStringTag$5$1;
    var wellKnownSymbol$8$2 = wellKnownSymbol$m;
    var ITERATOR$7 = wellKnownSymbol$8$2("iterator");
    var ArrayValues$1 = ArrayIteratorMethods$1.values;
    var handlePrototype$1 = function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR$7] !== ArrayValues$1)
          try {
            createNonEnumerableProperty$2$2(CollectionPrototype, ITERATOR$7, ArrayValues$1);
          } catch (error) {
            CollectionPrototype[ITERATOR$7] = ArrayValues$1;
          }
        setToStringTag$1$2(CollectionPrototype, COLLECTION_NAME2, true);
        if (DOMIterables$1[COLLECTION_NAME2])
          for (var METHOD_NAME in ArrayIteratorMethods$1) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods$1[METHOD_NAME])
              try {
                createNonEnumerableProperty$2$2(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods$1[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods$1[METHOD_NAME];
              }
          }
      }
    };
    for (var COLLECTION_NAME$1 in DOMIterables$1) {
      handlePrototype$1(global$6$2[COLLECTION_NAME$1] && global$6$2[COLLECTION_NAME$1].prototype, COLLECTION_NAME$1);
    }
    handlePrototype$1(DOMTokenListPrototype$1$1, "DOMTokenList");
    var toObject$7 = toObject$a;
    var toAbsoluteIndex$2$1 = toAbsoluteIndex$4;
    var lengthOfArrayLike$6$1 = lengthOfArrayLike$9;
    var arrayFill = function fill2(value) {
      var O = toObject$7(this);
      var length2 = lengthOfArrayLike$6$1(O);
      var argumentsLength = arguments.length;
      var index = toAbsoluteIndex$2$1(argumentsLength > 1 ? arguments[1] : void 0, length2);
      var end2 = argumentsLength > 2 ? arguments[2] : void 0;
      var endPos = end2 === void 0 ? length2 : toAbsoluteIndex$2$1(end2, length2);
      while (endPos > index)
        O[index++] = value;
      return O;
    };
    var $$h = _export$2;
    var fill = arrayFill;
    var addToUnscopables$1$1 = addToUnscopables$3;
    $$h({ target: "Array", proto: true }, {
      fill
    });
    addToUnscopables$1$1("fill");
    var classof$4$2 = classofRaw$2$2;
    var isArray$5 = Array.isArray || function isArray2(argument) {
      return classof$4$2(argument) === "Array";
    };
    var toPropertyKey$5 = toPropertyKey$3$1;
    var definePropertyModule$6 = objectDefineProperty$2;
    var createPropertyDescriptor$6 = createPropertyDescriptor$4$1;
    var createProperty$4 = function(object2, key, value) {
      var propertyKey = toPropertyKey$5(key);
      if (propertyKey in object2)
        definePropertyModule$6.f(object2, propertyKey, createPropertyDescriptor$6(0, value));
      else
        object2[propertyKey] = value;
    };
    var fails$h$1 = fails$u;
    var wellKnownSymbol$7$2 = wellKnownSymbol$m;
    var V8_VERSION$1$2 = engineV8Version$2;
    var SPECIES$3$1 = wellKnownSymbol$7$2("species");
    var arrayMethodHasSpeciesSupport$4 = function(METHOD_NAME) {
      return V8_VERSION$1$2 >= 51 || !fails$h$1(function() {
        var array2 = [];
        var constructor = array2.constructor = {};
        constructor[SPECIES$3$1] = function() {
          return { foo: 1 };
        };
        return array2[METHOD_NAME](Boolean).foo !== 1;
      });
    };
    var $$g = _export$2;
    var isArray$4 = isArray$5;
    var isConstructor$2$1 = isConstructor$4;
    var isObject$a$1 = isObject$j;
    var toAbsoluteIndex$1$2 = toAbsoluteIndex$4;
    var lengthOfArrayLike$5$1 = lengthOfArrayLike$9;
    var toIndexedObject$3$2 = toIndexedObject$9;
    var createProperty$3 = createProperty$4;
    var wellKnownSymbol$6$2 = wellKnownSymbol$m;
    var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$4;
    var nativeSlice = arraySlice$3$1;
    var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$3("slice");
    var SPECIES$2$2 = wellKnownSymbol$6$2("species");
    var $Array$3 = Array;
    var max$2$1 = Math.max;
    $$g({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
      slice: function slice2(start2, end2) {
        var O = toIndexedObject$3$2(this);
        var length2 = lengthOfArrayLike$5$1(O);
        var k2 = toAbsoluteIndex$1$2(start2, length2);
        var fin = toAbsoluteIndex$1$2(end2 === void 0 ? length2 : end2, length2);
        var Constructor, result, n;
        if (isArray$4(O)) {
          Constructor = O.constructor;
          if (isConstructor$2$1(Constructor) && (Constructor === $Array$3 || isArray$4(Constructor.prototype))) {
            Constructor = void 0;
          } else if (isObject$a$1(Constructor)) {
            Constructor = Constructor[SPECIES$2$2];
            if (Constructor === null)
              Constructor = void 0;
          }
          if (Constructor === $Array$3 || Constructor === void 0) {
            return nativeSlice(O, k2, fin);
          }
        }
        result = new (Constructor === void 0 ? $Array$3 : Constructor)(max$2$1(fin - k2, 0));
        for (n = 0; k2 < fin; k2++, n++)
          if (k2 in O)
            createProperty$3(result, n, O[k2]);
        result.length = n;
        return result;
      }
    });
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __classPrivateFieldGet$1(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    var eventemitter3 = { exports: {} };
    (function(module2) {
      var has2 = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has2.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length2 = listeners.length, j;
          for (i = 0; i < length2; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length2 = listeners.length; i < length2; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module2.exports = EventEmitter2;
      }
    })(eventemitter3);
    var eventemitter3Exports = eventemitter3.exports;
    var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
    var isArray$2$1 = Array.isArray;
    var isArray$3 = isArray$2$1;
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray$3(value) ? value : [value];
    }
    var isArray$1$1 = isArray$5;
    var isConstructor$1$2 = isConstructor$4;
    var isObject$9$1 = isObject$j;
    var wellKnownSymbol$5$2 = wellKnownSymbol$m;
    var SPECIES$1$2 = wellKnownSymbol$5$2("species");
    var $Array$2 = Array;
    var arraySpeciesConstructor$1$1 = function(originalArray) {
      var C2;
      if (isArray$1$1(originalArray)) {
        C2 = originalArray.constructor;
        if (isConstructor$1$2(C2) && (C2 === $Array$2 || isArray$1$1(C2.prototype)))
          C2 = void 0;
        else if (isObject$9$1(C2)) {
          C2 = C2[SPECIES$1$2];
          if (C2 === null)
            C2 = void 0;
        }
      }
      return C2 === void 0 ? $Array$2 : C2;
    };
    var arraySpeciesConstructor$2 = arraySpeciesConstructor$1$1;
    var arraySpeciesCreate$2$1 = function(originalArray, length2) {
      return new (arraySpeciesConstructor$2(originalArray))(length2 === 0 ? 0 : length2);
    };
    var bind$2$2 = functionBindContext$2;
    var uncurryThis$f$2 = functionUncurryThis$2;
    var IndexedObject$2$1 = indexedObject$2;
    var toObject$6$1 = toObject$a;
    var lengthOfArrayLike$4$1 = lengthOfArrayLike$9;
    var arraySpeciesCreate$1$1 = arraySpeciesCreate$2$1;
    var push$3 = uncurryThis$f$2([].push);
    var createMethod$2$1 = function(TYPE) {
      var IS_MAP = TYPE === 1;
      var IS_FILTER = TYPE === 2;
      var IS_SOME = TYPE === 3;
      var IS_EVERY = TYPE === 4;
      var IS_FIND_INDEX = TYPE === 6;
      var IS_FILTER_REJECT = TYPE === 7;
      var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that, specificCreate) {
        var O = toObject$6$1($this);
        var self2 = IndexedObject$2$1(O);
        var length2 = lengthOfArrayLike$4$1(self2);
        var boundFunction = bind$2$2(callbackfn, that);
        var index = 0;
        var create2 = specificCreate || arraySpeciesCreate$1$1;
        var target = IS_MAP ? create2($this, length2) : IS_FILTER || IS_FILTER_REJECT ? create2($this, 0) : void 0;
        var value, result;
        for (; length2 > index; index++)
          if (NO_HOLES || index in self2) {
            value = self2[index];
            result = boundFunction(value, index, O);
            if (TYPE) {
              if (IS_MAP)
                target[index] = result;
              else if (result)
                switch (TYPE) {
                  case 3:
                    return true;
                  case 5:
                    return value;
                  case 6:
                    return index;
                  case 2:
                    push$3(target, value);
                }
              else
                switch (TYPE) {
                  case 4:
                    return false;
                  case 7:
                    push$3(target, value);
                }
            }
          }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    var arrayIteration$1 = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod$2$1(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod$2$1(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod$2$1(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod$2$1(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod$2$1(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod$2$1(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod$2$1(6),
      // `Array.prototype.filterReject` method
      // https://github.com/tc39/proposal-array-filtering
      filterReject: createMethod$2$1(7)
    };
    var $$f = _export$2;
    var $map = arrayIteration$1.map;
    var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$4;
    var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$2("map");
    $$f({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
      map: function map2(callbackfn) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    var DESCRIPTORS$3$2 = descriptors$2;
    var uncurryThis$e$2 = functionUncurryThis$2;
    var call$4$2 = functionCall$2;
    var fails$g$1 = fails$u;
    var objectKeys$1$2 = objectKeys$3$1;
    var getOwnPropertySymbolsModule$3 = objectGetOwnPropertySymbols$2;
    var propertyIsEnumerableModule$3 = objectPropertyIsEnumerable$2;
    var toObject$5$1 = toObject$a;
    var IndexedObject$1$2 = indexedObject$2;
    var $assign$2 = Object.assign;
    var defineProperty$3$2 = Object.defineProperty;
    var concat$1$2 = uncurryThis$e$2([].concat);
    var objectAssign$2 = !$assign$2 || fails$g$1(function() {
      if (DESCRIPTORS$3$2 && $assign$2({ b: 1 }, $assign$2(defineProperty$3$2({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty$3$2(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), { b: 2 })).b !== 1)
        return true;
      var A5 = {};
      var B2 = {};
      var symbol2 = Symbol("assign detection");
      var alphabet = "abcdefghijklmnopqrst";
      A5[symbol2] = 7;
      alphabet.split("").forEach(function(chr) {
        B2[chr] = chr;
      });
      return $assign$2({}, A5)[symbol2] !== 7 || objectKeys$1$2($assign$2({}, B2)).join("") !== alphabet;
    }) ? function assign2(target, source) {
      var T = toObject$5$1(target);
      var argumentsLength = arguments.length;
      var index = 1;
      var getOwnPropertySymbols = getOwnPropertySymbolsModule$3.f;
      var propertyIsEnumerable2 = propertyIsEnumerableModule$3.f;
      while (argumentsLength > index) {
        var S = IndexedObject$1$2(arguments[index++]);
        var keys2 = getOwnPropertySymbols ? concat$1$2(objectKeys$1$2(S), getOwnPropertySymbols(S)) : objectKeys$1$2(S);
        var length2 = keys2.length;
        var j = 0;
        var key;
        while (length2 > j) {
          key = keys2[j++];
          if (!DESCRIPTORS$3$2 || call$4$2(propertyIsEnumerable2, S, key))
            T[key] = S[key];
        }
      }
      return T;
    } : $assign$2;
    var $$e = _export$2;
    var assign$2 = objectAssign$2;
    $$e({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign$2 }, {
      assign: assign$2
    });
    var internalMetadata$1 = { exports: {} };
    var objectGetOwnPropertyNamesExternal$1 = {};
    var toAbsoluteIndex$5 = toAbsoluteIndex$4;
    var lengthOfArrayLike$3$1 = lengthOfArrayLike$9;
    var createProperty$2$1 = createProperty$4;
    var $Array$1$1 = Array;
    var max$1$1 = Math.max;
    var arraySliceSimple$1 = function(O, start2, end2) {
      var length2 = lengthOfArrayLike$3$1(O);
      var k2 = toAbsoluteIndex$5(start2, length2);
      var fin = toAbsoluteIndex$5(end2 === void 0 ? length2 : end2, length2);
      var result = $Array$1$1(max$1$1(fin - k2, 0));
      var n = 0;
      for (; k2 < fin; k2++, n++)
        createProperty$2$1(result, n, O[k2]);
      result.length = n;
      return result;
    };
    var classof$3$2 = classofRaw$2$2;
    var toIndexedObject$2$2 = toIndexedObject$9;
    var $getOwnPropertyNames$1 = objectGetOwnPropertyNames$2.f;
    var arraySlice$1$2 = arraySliceSimple$1;
    var windowNames$1 = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames$1 = function(it) {
      try {
        return $getOwnPropertyNames$1(it);
      } catch (error) {
        return arraySlice$1$2(windowNames$1);
      }
    };
    objectGetOwnPropertyNamesExternal$1.f = function getOwnPropertyNames(it) {
      return windowNames$1 && classof$3$2(it) === "Window" ? getWindowNames$1(it) : $getOwnPropertyNames$1(toIndexedObject$2$2(it));
    };
    var fails$f$1 = fails$u;
    var arrayBufferNonExtensible$1 = fails$f$1(function() {
      if (typeof ArrayBuffer == "function") {
        var buffer = new ArrayBuffer(8);
        if (Object.isExtensible(buffer))
          Object.defineProperty(buffer, "a", { value: 8 });
      }
    });
    var fails$e$1 = fails$u;
    var isObject$8$2 = isObject$j;
    var classof$2$2 = classofRaw$2$2;
    var ARRAY_BUFFER_NON_EXTENSIBLE$1 = arrayBufferNonExtensible$1;
    var $isExtensible$1 = Object.isExtensible;
    var FAILS_ON_PRIMITIVES$1 = fails$e$1(function() {
      $isExtensible$1(1);
    });
    var objectIsExtensible$1 = FAILS_ON_PRIMITIVES$1 || ARRAY_BUFFER_NON_EXTENSIBLE$1 ? function isExtensible2(it) {
      if (!isObject$8$2(it))
        return false;
      if (ARRAY_BUFFER_NON_EXTENSIBLE$1 && classof$2$2(it) === "ArrayBuffer")
        return false;
      return $isExtensible$1 ? $isExtensible$1(it) : true;
    } : $isExtensible$1;
    var fails$d$1 = fails$u;
    var freezing$1 = !fails$d$1(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
    var $$d = _export$2;
    var uncurryThis$d$2 = functionUncurryThis$2;
    var hiddenKeys$7 = hiddenKeys$5$1;
    var isObject$7$2 = isObject$j;
    var hasOwn$1$2 = hasOwnProperty_1$2;
    var defineProperty$2$2 = objectDefineProperty$2.f;
    var getOwnPropertyNamesModule$3 = objectGetOwnPropertyNames$2;
    var getOwnPropertyNamesExternalModule$1 = objectGetOwnPropertyNamesExternal$1;
    var isExtensible$1 = objectIsExtensible$1;
    var uid$5 = uid$3$1;
    var FREEZING$1 = freezing$1;
    var REQUIRED$1 = false;
    var METADATA$1 = uid$5("meta");
    var id$1$1 = 0;
    var setMetadata$1 = function(it) {
      defineProperty$2$2(it, METADATA$1, { value: {
        objectID: "O" + id$1$1++,
        // object ID
        weakData: {}
        // weak collections IDs
      } });
    };
    var fastKey$1 = function(it, create2) {
      if (!isObject$7$2(it))
        return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!hasOwn$1$2(it, METADATA$1)) {
        if (!isExtensible$1(it))
          return "F";
        if (!create2)
          return "E";
        setMetadata$1(it);
      }
      return it[METADATA$1].objectID;
    };
    var getWeakData$1$1 = function(it, create2) {
      if (!hasOwn$1$2(it, METADATA$1)) {
        if (!isExtensible$1(it))
          return true;
        if (!create2)
          return false;
        setMetadata$1(it);
      }
      return it[METADATA$1].weakData;
    };
    var onFreeze$1 = function(it) {
      if (FREEZING$1 && REQUIRED$1 && isExtensible$1(it) && !hasOwn$1$2(it, METADATA$1))
        setMetadata$1(it);
      return it;
    };
    var enable$1 = function() {
      meta$1.enable = function() {
      };
      REQUIRED$1 = true;
      var getOwnPropertyNames = getOwnPropertyNamesModule$3.f;
      var splice2 = uncurryThis$d$2([].splice);
      var test2 = {};
      test2[METADATA$1] = 1;
      if (getOwnPropertyNames(test2).length) {
        getOwnPropertyNamesModule$3.f = function(it) {
          var result = getOwnPropertyNames(it);
          for (var i = 0, length2 = result.length; i < length2; i++) {
            if (result[i] === METADATA$1) {
              splice2(result, i, 1);
              break;
            }
          }
          return result;
        };
        $$d({ target: "Object", stat: true, forced: true }, {
          getOwnPropertyNames: getOwnPropertyNamesExternalModule$1.f
        });
      }
    };
    var meta$1 = internalMetadata$1.exports = {
      enable: enable$1,
      fastKey: fastKey$1,
      getWeakData: getWeakData$1$1,
      onFreeze: onFreeze$1
    };
    hiddenKeys$7[METADATA$1] = true;
    var internalMetadataExports$1 = internalMetadata$1.exports;
    var isCallable$3$2 = isCallable$o;
    var isObject$6$2 = isObject$j;
    var setPrototypeOf$4 = objectSetPrototypeOf$2;
    var inheritIfRequired$1$1 = function($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (
        // it can work only with native `setPrototypeOf`
        setPrototypeOf$4 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        isCallable$3$2(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$6$2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
      )
        setPrototypeOf$4($this, NewTargetPrototype);
      return $this;
    };
    var $$c = _export$2;
    var global$5$2 = global$n;
    var uncurryThis$c$2 = functionUncurryThis$2;
    var isForced$5 = isForced_1$2;
    var defineBuiltIn$2$2 = defineBuiltIn$9$1;
    var InternalMetadataModule$1 = internalMetadataExports$1;
    var iterate$2$2 = iterate$6;
    var anInstance$2$1 = anInstance$4$1;
    var isCallable$2$2 = isCallable$o;
    var isNullOrUndefined$3$2 = isNullOrUndefined$8;
    var isObject$5$2 = isObject$j;
    var fails$c$1 = fails$u;
    var checkCorrectnessOfIteration$1$2 = checkCorrectnessOfIteration$3$1;
    var setToStringTag$7 = setToStringTag$5$1;
    var inheritIfRequired$2 = inheritIfRequired$1$1;
    var collection$3 = function(CONSTRUCTOR_NAME, wrapper, common) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
      var ADDER = IS_MAP ? "set" : "add";
      var NativeConstructor = global$5$2[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var Constructor = NativeConstructor;
      var exported = {};
      var fixMethod = function(KEY) {
        var uncurriedNativeMethod = uncurryThis$c$2(NativePrototype[KEY]);
        defineBuiltIn$2$2(
          NativePrototype,
          KEY,
          KEY === "add" ? function add(value) {
            uncurriedNativeMethod(this, value === 0 ? 0 : value);
            return this;
          } : KEY === "delete" ? function(key) {
            return IS_WEAK && !isObject$5$2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY === "get" ? function get2(key) {
            return IS_WEAK && !isObject$5$2(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY === "has" ? function has2(key) {
            return IS_WEAK && !isObject$5$2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : function set2(key, value) {
            uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
            return this;
          }
        );
      };
      var REPLACE2 = isForced$5(
        CONSTRUCTOR_NAME,
        !isCallable$2$2(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$c$1(function() {
          new NativeConstructor().entries().next();
        }))
      );
      if (REPLACE2) {
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule$1.enable();
      } else if (isForced$5(CONSTRUCTOR_NAME, true)) {
        var instance2 = new Constructor();
        var HASNT_CHAINING = instance2[ADDER](IS_WEAK ? {} : -0, 1) !== instance2;
        var THROWS_ON_PRIMITIVES = fails$c$1(function() {
          instance2.has(1);
        });
        var ACCEPT_ITERABLES = checkCorrectnessOfIteration$1$2(function(iterable) {
          new NativeConstructor(iterable);
        });
        var BUGGY_ZERO = !IS_WEAK && fails$c$1(function() {
          var $instance = new NativeConstructor();
          var index = 5;
          while (index--)
            $instance[ADDER](index, index);
          return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
          Constructor = wrapper(function(dummy, iterable) {
            anInstance$2$1(dummy, NativePrototype);
            var that = inheritIfRequired$2(new NativeConstructor(), dummy, Constructor);
            if (!isNullOrUndefined$3$2(iterable))
              iterate$2$2(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
            return that;
          });
          Constructor.prototype = NativePrototype;
          NativePrototype.constructor = Constructor;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
          fixMethod("delete");
          fixMethod("has");
          IS_MAP && fixMethod("get");
        }
        if (BUGGY_ZERO || HASNT_CHAINING)
          fixMethod(ADDER);
        if (IS_WEAK && NativePrototype.clear)
          delete NativePrototype.clear;
      }
      exported[CONSTRUCTOR_NAME] = Constructor;
      $$c({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
      setToStringTag$7(Constructor, CONSTRUCTOR_NAME);
      if (!IS_WEAK)
        common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };
    var defineBuiltIn$1$2 = defineBuiltIn$9$1;
    var defineBuiltIns$2 = function(target, src, options) {
      for (var key in src)
        defineBuiltIn$1$2(target, key, src[key], options);
      return target;
    };
    var uncurryThis$b$2 = functionUncurryThis$2;
    var defineBuiltIns$1$1 = defineBuiltIns$2;
    var getWeakData$2 = internalMetadataExports$1.getWeakData;
    var anInstance$1$2 = anInstance$4$1;
    var anObject$4$2 = anObject$f;
    var isNullOrUndefined$2$2 = isNullOrUndefined$8;
    var isObject$4$2 = isObject$j;
    var iterate$1$2 = iterate$6;
    var ArrayIterationModule$1 = arrayIteration$1;
    var hasOwn$d = hasOwnProperty_1$2;
    var InternalStateModule$1$2 = internalState$2;
    var setInternalState$1$1 = InternalStateModule$1$2.set;
    var internalStateGetterFor$1 = InternalStateModule$1$2.getterFor;
    var find$1 = ArrayIterationModule$1.find;
    var findIndex$1 = ArrayIterationModule$1.findIndex;
    var splice$1 = uncurryThis$b$2([].splice);
    var id$4 = 0;
    var uncaughtFrozenStore$1 = function(state) {
      return state.frozen || (state.frozen = new UncaughtFrozenStore$1());
    };
    var UncaughtFrozenStore$1 = function() {
      this.entries = [];
    };
    var findUncaughtFrozen$1 = function(store2, key) {
      return find$1(store2.entries, function(it) {
        return it[0] === key;
      });
    };
    UncaughtFrozenStore$1.prototype = {
      get: function(key) {
        var entry = findUncaughtFrozen$1(this, key);
        if (entry)
          return entry[1];
      },
      has: function(key) {
        return !!findUncaughtFrozen$1(this, key);
      },
      set: function(key, value) {
        var entry = findUncaughtFrozen$1(this, key);
        if (entry)
          entry[1] = value;
        else
          this.entries.push([key, value]);
      },
      "delete": function(key) {
        var index = findIndex$1(this.entries, function(it) {
          return it[0] === key;
        });
        if (~index)
          splice$1(this.entries, index, 1);
        return !!~index;
      }
    };
    var collectionWeak$1$1 = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance$1$2(that, Prototype);
          setInternalState$1$1(that, {
            type: CONSTRUCTOR_NAME,
            id: id$4++,
            frozen: void 0
          });
          if (!isNullOrUndefined$2$2(iterable))
            iterate$1$2(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState2 = internalStateGetterFor$1(CONSTRUCTOR_NAME);
        var define2 = function(that, key, value) {
          var state = getInternalState2(that);
          var data2 = getWeakData$2(anObject$4$2(key), true);
          if (data2 === true)
            uncaughtFrozenStore$1(state).set(key, value);
          else
            data2[state.id] = value;
          return that;
        };
        defineBuiltIns$1$1(Prototype, {
          // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
          // https://tc39.es/ecma262/#sec-weakset.prototype.delete
          "delete": function(key) {
            var state = getInternalState2(this);
            if (!isObject$4$2(key))
              return false;
            var data2 = getWeakData$2(key);
            if (data2 === true)
              return uncaughtFrozenStore$1(state)["delete"](key);
            return data2 && hasOwn$d(data2, state.id) && delete data2[state.id];
          },
          // `{ WeakMap, WeakSet }.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.has
          // https://tc39.es/ecma262/#sec-weakset.prototype.has
          has: function has2(key) {
            var state = getInternalState2(this);
            if (!isObject$4$2(key))
              return false;
            var data2 = getWeakData$2(key);
            if (data2 === true)
              return uncaughtFrozenStore$1(state).has(key);
            return data2 && hasOwn$d(data2, state.id);
          }
        });
        defineBuiltIns$1$1(Prototype, IS_MAP ? {
          // `WeakMap.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.get
          get: function get2(key) {
            var state = getInternalState2(this);
            if (isObject$4$2(key)) {
              var data2 = getWeakData$2(key);
              if (data2 === true)
                return uncaughtFrozenStore$1(state).get(key);
              return data2 ? data2[state.id] : void 0;
            }
          },
          // `WeakMap.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.set
          set: function set2(key, value) {
            return define2(this, key, value);
          }
        } : {
          // `WeakSet.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-weakset.prototype.add
          add: function add(value) {
            return define2(this, value, true);
          }
        });
        return Constructor;
      }
    };
    var collection$2 = collection$3;
    var collectionWeak$2 = collectionWeak$1$1;
    collection$2("WeakSet", function(init2) {
      return function WeakSet2() {
        return init2(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionWeak$2);
    var ScrollDirection;
    (function(ScrollDirection2) {
      ScrollDirection2[ScrollDirection2["SCROLL_NONE"] = 0] = "SCROLL_NONE";
      ScrollDirection2[ScrollDirection2["SCROLL_BACKWARD"] = 1] = "SCROLL_BACKWARD";
      ScrollDirection2[ScrollDirection2["SCROLL_FORWARD"] = 2] = "SCROLL_FORWARD";
    })(ScrollDirection || (ScrollDirection = {}));
    var Position;
    (function(Position2) {
      Position2[Position2["TOP"] = 0] = "TOP";
      Position2[Position2["RIGHT"] = 1] = "RIGHT";
      Position2[Position2["BOTTOM"] = 2] = "BOTTOM";
      Position2[Position2["LEFT"] = 3] = "LEFT";
    })(Position || (Position = {}));
    var OPTIONS_DEFAULT_DOMAIN_TYPE = "hour";
    var OPTIONS_DEFAULT_SUBDOMAIN_TYPE = "minute";
    var OPTIONS_DEFAULT_SUBDOMAIN_WIDTH = 10;
    var OPTIONS_DEFAULT_SUBDOMAIN_HEIGHT = 10;
    var OPTIONS_DEFAULT_SUBDOMAIN_GUTTER = 2;
    var OPTIONS_DEFAULT_SUBDOMAIN_RADIUS = 0;
    var OPTIONS_DEFAULT_ANIMATION_DURATION = 200;
    var OPTIONS_DEFAULT_RANGE = 12;
    var OPTIONS_DEFAULT_ITEM_SELECTOR = "#cal-heatmap";
    var OPTIONS_DEFAULT_THEME = "light";
    var OPTIONS_DEFAULT_LOCALE = "en";
    var SCALE_BASE_OPACITY_COLOR = "red";
    var SCALE_BASE_COLOR_SCHEME = "YlOrBr";
    var SCALE_BASE_COLOR_TYPE = "quantize";
    var SCALE_BASE_COLOR_DOMAIN = [0, 100];
    var _Navigator_instances, _Navigator_isDomainBoundaryReached, _Navigator_setDomainsBoundaryReached;
    var Navigator = /* @__PURE__ */ function() {
      function Navigator2(calendar2) {
        _classCallCheck$2(this, Navigator2);
        _Navigator_instances.add(this);
        this.calendar = calendar2;
        this.maxDomainReached = false;
        this.minDomainReached = false;
      }
      _createClass$2(Navigator2, [{
        key: "loadNewDomains",
        value: function loadNewDomains(newDomainCollection) {
          var _this = this;
          var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ScrollDirection.SCROLL_NONE;
          var options = this.calendar.options.options;
          var templatesClt = this.calendar.templateCollection;
          var minDate = options.date.min ? templatesClt.get(options.domain.type).extractUnit(+options.date.min) : void 0;
          var maxDate = options.date.max ? templatesClt.get(options.domain.type).extractUnit(+options.date.max) : void 0;
          var domainCollection = this.calendar.domainCollection;
          if (__classPrivateFieldGet$1(this, _Navigator_instances, "m", _Navigator_isDomainBoundaryReached).call(this, newDomainCollection, minDate, maxDate, direction)) {
            return ScrollDirection.SCROLL_NONE;
          }
          if (direction !== ScrollDirection.SCROLL_NONE) {
            newDomainCollection.clamp(minDate, maxDate).slice(options.range, direction === ScrollDirection.SCROLL_FORWARD);
          }
          domainCollection.merge(newDomainCollection, options.range, function(domainKey, index) {
            var subDomainEndDate = null;
            if (newDomainCollection.at(index + 1)) {
              subDomainEndDate = newDomainCollection.at(index + 1);
            } else {
              subDomainEndDate = _this.calendar.dateHelper.intervals(options.domain.type, domainKey, 2).pop();
            }
            return templatesClt.get(options.subDomain.type).mapping(domainKey, subDomainEndDate).map(function(d) {
              return Object.assign(Object.assign({}, d), {
                v: options.data.defaultValue
              });
            });
          });
          __classPrivateFieldGet$1(this, _Navigator_instances, "m", _Navigator_setDomainsBoundaryReached).call(this, domainCollection.min, domainCollection.max, minDate, maxDate);
          if (direction === ScrollDirection.SCROLL_BACKWARD) {
            this.calendar.eventEmitter.emit("domainsLoaded", [domainCollection.min]);
          } else if (direction === ScrollDirection.SCROLL_FORWARD) {
            this.calendar.eventEmitter.emit("domainsLoaded", [domainCollection.max]);
          }
          return direction;
        }
      }, {
        key: "jumpTo",
        value: function jumpTo(date2, reset) {
          var _this$calendar = this.calendar, domainCollection = _this$calendar.domainCollection, options = _this$calendar.options;
          var minDate = new Date(domainCollection.min);
          var maxDate = new Date(domainCollection.max);
          if (date2 < minDate) {
            return this.loadNewDomains(this.calendar.createDomainCollection(date2, minDate, false), ScrollDirection.SCROLL_BACKWARD);
          }
          if (reset) {
            return this.loadNewDomains(this.calendar.createDomainCollection(date2, options.options.range), minDate < date2 ? ScrollDirection.SCROLL_FORWARD : ScrollDirection.SCROLL_BACKWARD);
          }
          if (date2 > maxDate) {
            return this.loadNewDomains(this.calendar.createDomainCollection(maxDate, date2, false), ScrollDirection.SCROLL_FORWARD);
          }
          return ScrollDirection.SCROLL_NONE;
        }
      }]);
      return Navigator2;
    }();
    _Navigator_instances = /* @__PURE__ */ new WeakSet(), _Navigator_isDomainBoundaryReached = function _Navigator_isDomainBoundaryReached2(newDomainCollection, minDate, maxDate, direction) {
      if (maxDate && newDomainCollection.max >= maxDate && this.maxDomainReached && direction === ScrollDirection.SCROLL_FORWARD) {
        return true;
      }
      if (minDate && newDomainCollection.min <= minDate && this.minDomainReached && direction === ScrollDirection.SCROLL_BACKWARD) {
        return true;
      }
      return false;
    }, _Navigator_setDomainsBoundaryReached = function _Navigator_setDomainsBoundaryReached2(lowerBound, upperBound, min2, max2) {
      if (min2) {
        var reached = lowerBound <= min2;
        this.calendar.eventEmitter.emit(reached ? "minDateReached" : "minDateNotReached");
        this.minDomainReached = reached;
      }
      if (max2) {
        var _reached = upperBound >= max2;
        this.calendar.eventEmitter.emit(_reached ? "maxDateReached" : "maxDateNotReached");
        this.maxDomainReached = _reached;
      }
    };
    var $TypeError$3$2 = TypeError;
    var MAX_SAFE_INTEGER$2 = 9007199254740991;
    var doesNotExceedSafeInteger$1$1 = function(it) {
      if (it > MAX_SAFE_INTEGER$2)
        throw $TypeError$3$2("Maximum allowed index exceeded");
      return it;
    };
    var $$b$1 = _export$2;
    var fails$b$2 = fails$u;
    var isArray$6 = isArray$5;
    var isObject$3$2 = isObject$j;
    var toObject$4$1 = toObject$a;
    var lengthOfArrayLike$2$2 = lengthOfArrayLike$9;
    var doesNotExceedSafeInteger$2 = doesNotExceedSafeInteger$1$1;
    var createProperty$1$1 = createProperty$4;
    var arraySpeciesCreate$3 = arraySpeciesCreate$2$1;
    var arrayMethodHasSpeciesSupport$1$1 = arrayMethodHasSpeciesSupport$4;
    var wellKnownSymbol$4$2 = wellKnownSymbol$m;
    var V8_VERSION$5 = engineV8Version$2;
    var IS_CONCAT_SPREADABLE$1 = wellKnownSymbol$4$2("isConcatSpreadable");
    var IS_CONCAT_SPREADABLE_SUPPORT$1 = V8_VERSION$5 >= 51 || !fails$b$2(function() {
      var array2 = [];
      array2[IS_CONCAT_SPREADABLE$1] = false;
      return array2.concat()[0] !== array2;
    });
    var isConcatSpreadable$1 = function(O) {
      if (!isObject$3$2(O))
        return false;
      var spreadable = O[IS_CONCAT_SPREADABLE$1];
      return spreadable !== void 0 ? !!spreadable : isArray$6(O);
    };
    var FORCED$2 = !IS_CONCAT_SPREADABLE_SUPPORT$1 || !arrayMethodHasSpeciesSupport$1$1("concat");
    $$b$1({ target: "Array", proto: true, arity: 1, forced: FORCED$2 }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat2(arg) {
        var O = toObject$4$1(this);
        var A5 = arraySpeciesCreate$3(O, 0);
        var n = 0;
        var i, k2, length2, len, E2;
        for (i = -1, length2 = arguments.length; i < length2; i++) {
          E2 = i === -1 ? O : arguments[i];
          if (isConcatSpreadable$1(E2)) {
            len = lengthOfArrayLike$2$2(E2);
            doesNotExceedSafeInteger$2(n + len);
            for (k2 = 0; k2 < len; k2++, n++)
              if (k2 in E2)
                createProperty$1$1(A5, n, E2[k2]);
          } else {
            doesNotExceedSafeInteger$2(n + 1);
            createProperty$1$1(A5, n++, E2);
          }
        }
        A5.length = n;
        return A5;
      }
    });
    var fails$a$2 = fails$u;
    var arrayMethodIsStrict$3 = function(METHOD_NAME, argument) {
      var method2 = [][METHOD_NAME];
      return !!method2 && fails$a$2(function() {
        method2.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
    var $$a$1 = _export$2;
    var uncurryThis$a$2 = functionUncurryThis$2;
    var IndexedObject$4 = indexedObject$2;
    var toIndexedObject$1$2 = toIndexedObject$9;
    var arrayMethodIsStrict$2 = arrayMethodIsStrict$3;
    var nativeJoin = uncurryThis$a$2([].join);
    var ES3_STRINGS = IndexedObject$4 !== Object;
    var FORCED$1 = ES3_STRINGS || !arrayMethodIsStrict$2("join", ",");
    $$a$1({ target: "Array", proto: true, forced: FORCED$1 }, {
      join: function join2(separator) {
        return nativeJoin(toIndexedObject$1$2(this), separator === void 0 ? "," : separator);
      }
    });
    var create$1$1 = objectCreate$1;
    var defineBuiltInAccessor$1$2 = defineBuiltInAccessor$3$1;
    var defineBuiltIns$3 = defineBuiltIns$2;
    var bind$1$2 = functionBindContext$2;
    var anInstance$5 = anInstance$4$1;
    var isNullOrUndefined$1$2 = isNullOrUndefined$8;
    var iterate$7 = iterate$6;
    var defineIterator$3 = iteratorDefine$1;
    var createIterResultObject$4 = createIterResultObject$3;
    var setSpecies$3 = setSpecies$2$1;
    var DESCRIPTORS$2$2 = descriptors$2;
    var fastKey$2 = internalMetadataExports$1.fastKey;
    var InternalStateModule$6 = internalState$2;
    var setInternalState$5 = InternalStateModule$6.set;
    var internalStateGetterFor$2 = InternalStateModule$6.getterFor;
    var collectionStrong$2 = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance$5(that, Prototype);
          setInternalState$5(that, {
            type: CONSTRUCTOR_NAME,
            index: create$1$1(null),
            first: void 0,
            last: void 0,
            size: 0
          });
          if (!DESCRIPTORS$2$2)
            that.size = 0;
          if (!isNullOrUndefined$1$2(iterable))
            iterate$7(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState2 = internalStateGetterFor$2(CONSTRUCTOR_NAME);
        var define2 = function(that, key, value) {
          var state = getInternalState2(that);
          var entry = getEntry(that, key);
          var previous, index;
          if (entry) {
            entry.value = value;
          } else {
            state.last = entry = {
              index: index = fastKey$2(key, true),
              key,
              value,
              previous: previous = state.last,
              next: void 0,
              removed: false
            };
            if (!state.first)
              state.first = entry;
            if (previous)
              previous.next = entry;
            if (DESCRIPTORS$2$2)
              state.size++;
            else
              that.size++;
            if (index !== "F")
              state.index[index] = entry;
          }
          return that;
        };
        var getEntry = function(that, key) {
          var state = getInternalState2(that);
          var index = fastKey$2(key);
          var entry;
          if (index !== "F")
            return state.index[index];
          for (entry = state.first; entry; entry = entry.next) {
            if (entry.key === key)
              return entry;
          }
        };
        defineBuiltIns$3(Prototype, {
          // `{ Map, Set }.prototype.clear()` methods
          // https://tc39.es/ecma262/#sec-map.prototype.clear
          // https://tc39.es/ecma262/#sec-set.prototype.clear
          clear: function clear2() {
            var that = this;
            var state = getInternalState2(that);
            var data2 = state.index;
            var entry = state.first;
            while (entry) {
              entry.removed = true;
              if (entry.previous)
                entry.previous = entry.previous.next = void 0;
              delete data2[entry.index];
              entry = entry.next;
            }
            state.first = state.last = void 0;
            if (DESCRIPTORS$2$2)
              state.size = 0;
            else
              that.size = 0;
          },
          // `{ Map, Set }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.delete
          // https://tc39.es/ecma262/#sec-set.prototype.delete
          "delete": function(key) {
            var that = this;
            var state = getInternalState2(that);
            var entry = getEntry(that, key);
            if (entry) {
              var next = entry.next;
              var prev = entry.previous;
              delete state.index[entry.index];
              entry.removed = true;
              if (prev)
                prev.next = next;
              if (next)
                next.previous = prev;
              if (state.first === entry)
                state.first = next;
              if (state.last === entry)
                state.last = prev;
              if (DESCRIPTORS$2$2)
                state.size--;
              else
                that.size--;
            }
            return !!entry;
          },
          // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.foreach
          // https://tc39.es/ecma262/#sec-set.prototype.foreach
          forEach: function forEach2(callbackfn) {
            var state = getInternalState2(this);
            var boundFunction = bind$1$2(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            var entry;
            while (entry = entry ? entry.next : state.first) {
              boundFunction(entry.value, entry.key, this);
              while (entry && entry.removed)
                entry = entry.previous;
            }
          },
          // `{ Map, Set}.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-map.prototype.has
          // https://tc39.es/ecma262/#sec-set.prototype.has
          has: function has2(key) {
            return !!getEntry(this, key);
          }
        });
        defineBuiltIns$3(Prototype, IS_MAP ? {
          // `Map.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-map.prototype.get
          get: function get2(key) {
            var entry = getEntry(this, key);
            return entry && entry.value;
          },
          // `Map.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-map.prototype.set
          set: function set2(key, value) {
            return define2(this, key === 0 ? 0 : key, value);
          }
        } : {
          // `Set.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-set.prototype.add
          add: function add(value) {
            return define2(this, value = value === 0 ? 0 : value, value);
          }
        });
        if (DESCRIPTORS$2$2)
          defineBuiltInAccessor$1$2(Prototype, "size", {
            configurable: true,
            get: function() {
              return getInternalState2(this).size;
            }
          });
        return Constructor;
      },
      setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
        var getInternalCollectionState = internalStateGetterFor$2(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor$2(ITERATOR_NAME);
        defineIterator$3(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
          setInternalState$5(this, {
            type: ITERATOR_NAME,
            target: iterated,
            state: getInternalCollectionState(iterated),
            kind,
            last: void 0
          });
        }, function() {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var entry = state.last;
          while (entry && entry.removed)
            entry = entry.previous;
          if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
            state.target = void 0;
            return createIterResultObject$4(void 0, true);
          }
          if (kind === "keys")
            return createIterResultObject$4(entry.key, false);
          if (kind === "values")
            return createIterResultObject$4(entry.value, false);
          return createIterResultObject$4([entry.key, entry.value], false);
        }, IS_MAP ? "entries" : "values", !IS_MAP, true);
        setSpecies$3(CONSTRUCTOR_NAME);
      }
    };
    var collection$1$1 = collection$3;
    var collectionStrong$1 = collectionStrong$2;
    collection$1$1("Map", function(init2) {
      return function Map2() {
        return init2(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong$1);
    var tryToString$6 = tryToString$5$1;
    var $TypeError$2$2 = TypeError;
    var deletePropertyOrThrow$1 = function(O, P) {
      if (!delete O[P])
        throw new $TypeError$2$2("Cannot delete property " + tryToString$6(P) + " of " + tryToString$6(O));
    };
    var arraySlice$4 = arraySliceSimple$1;
    var floor$1$1 = Math.floor;
    var mergeSort = function(array2, comparefn) {
      var length2 = array2.length;
      var middle = floor$1$1(length2 / 2);
      return length2 < 8 ? insertionSort(array2, comparefn) : merge(
        array2,
        mergeSort(arraySlice$4(array2, 0, middle), comparefn),
        mergeSort(arraySlice$4(array2, middle), comparefn),
        comparefn
      );
    };
    var insertionSort = function(array2, comparefn) {
      var length2 = array2.length;
      var i = 1;
      var element2, j;
      while (i < length2) {
        j = i;
        element2 = array2[i];
        while (j && comparefn(array2[j - 1], element2) > 0) {
          array2[j] = array2[--j];
        }
        if (j !== i++)
          array2[j] = element2;
      }
      return array2;
    };
    var merge = function(array2, left2, right2, comparefn) {
      var llength = left2.length;
      var rlength = right2.length;
      var lindex = 0;
      var rindex = 0;
      while (lindex < llength || rindex < rlength) {
        array2[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left2[lindex], right2[rindex]) <= 0 ? left2[lindex++] : right2[rindex++] : lindex < llength ? left2[lindex++] : right2[rindex++];
      }
      return array2;
    };
    var arraySort = mergeSort;
    var userAgent$1$2 = engineUserAgent$2;
    var firefox = userAgent$1$2.match(/firefox\/(\d+)/i);
    var engineFfVersion = !!firefox && +firefox[1];
    var UA = engineUserAgent$2;
    var engineIsIeOrEdge = /MSIE|Trident/.test(UA);
    var userAgent$6 = engineUserAgent$2;
    var webkit = userAgent$6.match(/AppleWebKit\/(\d+)\./);
    var engineWebkitVersion = !!webkit && +webkit[1];
    var $$9$1 = _export$2;
    var uncurryThis$9$2 = functionUncurryThis$2;
    var aCallable$b = aCallable$a;
    var toObject$3$1 = toObject$a;
    var lengthOfArrayLike$1$2 = lengthOfArrayLike$9;
    var deletePropertyOrThrow = deletePropertyOrThrow$1;
    var toString$6$1 = toString$9;
    var fails$9$2 = fails$u;
    var internalSort = arraySort;
    var arrayMethodIsStrict$1 = arrayMethodIsStrict$3;
    var FF = engineFfVersion;
    var IE_OR_EDGE = engineIsIeOrEdge;
    var V8 = engineV8Version$2;
    var WEBKIT = engineWebkitVersion;
    var test$2 = [];
    var nativeSort = uncurryThis$9$2(test$2.sort);
    var push$2$1 = uncurryThis$9$2(test$2.push);
    var FAILS_ON_UNDEFINED = fails$9$2(function() {
      test$2.sort(void 0);
    });
    var FAILS_ON_NULL = fails$9$2(function() {
      test$2.sort(null);
    });
    var STRICT_METHOD$1 = arrayMethodIsStrict$1("sort");
    var STABLE_SORT = !fails$9$2(function() {
      if (V8)
        return V8 < 70;
      if (FF && FF > 3)
        return;
      if (IE_OR_EDGE)
        return true;
      if (WEBKIT)
        return WEBKIT < 603;
      var result = "";
      var code, chr, value, index;
      for (code = 65; code < 76; code++) {
        chr = String.fromCharCode(code);
        switch (code) {
          case 66:
          case 69:
          case 70:
          case 72:
            value = 3;
            break;
          case 68:
          case 71:
            value = 4;
            break;
          default:
            value = 2;
        }
        for (index = 0; index < 47; index++) {
          test$2.push({ k: chr + index, v: value });
        }
      }
      test$2.sort(function(a2, b) {
        return b.v - a2.v;
      });
      for (index = 0; index < test$2.length; index++) {
        chr = test$2[index].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr)
          result += chr;
      }
      return result !== "DGBEFHACIJK";
    });
    var FORCED$3 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;
    var getSortCompare = function(comparefn) {
      return function(x, y) {
        if (y === void 0)
          return -1;
        if (x === void 0)
          return 1;
        if (comparefn !== void 0)
          return +comparefn(x, y) || 0;
        return toString$6$1(x) > toString$6$1(y) ? 1 : -1;
      };
    };
    $$9$1({ target: "Array", proto: true, forced: FORCED$3 }, {
      sort: function sort2(comparefn) {
        if (comparefn !== void 0)
          aCallable$b(comparefn);
        var array2 = toObject$3$1(this);
        if (STABLE_SORT)
          return comparefn === void 0 ? nativeSort(array2) : nativeSort(array2, comparefn);
        var items = [];
        var arrayLength = lengthOfArrayLike$1$2(array2);
        var itemsLength, index;
        for (index = 0; index < arrayLength; index++) {
          if (index in array2)
            push$2$1(items, array2[index]);
        }
        internalSort(items, getSortCompare(comparefn));
        itemsLength = lengthOfArrayLike$1$2(items);
        index = 0;
        while (index < itemsLength)
          array2[index] = items[index++];
        while (index < arrayLength)
          deletePropertyOrThrow(array2, index++);
        return array2;
      }
    });
    var $forEach = arrayIteration$1.forEach;
    var arrayMethodIsStrict = arrayMethodIsStrict$3;
    var STRICT_METHOD = arrayMethodIsStrict("forEach");
    var arrayForEach = !STRICT_METHOD ? function forEach2(callbackfn) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    } : [].forEach;
    var global$4$2 = global$n;
    var DOMIterables$2 = domIterables$1;
    var DOMTokenListPrototype$3 = domTokenListPrototype$1;
    var forEach = arrayForEach;
    var createNonEnumerableProperty$1$2 = createNonEnumerableProperty$6;
    var handlePrototype$2 = function(CollectionPrototype) {
      if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
        try {
          createNonEnumerableProperty$1$2(CollectionPrototype, "forEach", forEach);
        } catch (error) {
          CollectionPrototype.forEach = forEach;
        }
    };
    for (var COLLECTION_NAME$2 in DOMIterables$2) {
      if (DOMIterables$2[COLLECTION_NAME$2]) {
        handlePrototype$2(global$4$2[COLLECTION_NAME$2] && global$4$2[COLLECTION_NAME$2].prototype);
      }
    }
    handlePrototype$2(DOMTokenListPrototype$3);
    function isVertical(position2) {
      return position2 === "top" || position2 === "bottom";
    }
    function horizontalPadding(padding) {
      return padding[Position.LEFT] + padding[Position.RIGHT];
    }
    function verticalPadding(padding) {
      return padding[Position.TOP] + padding[Position.BOTTOM];
    }
    var _DomainCoordinates_instances, _DomainCoordinates_getWidth, _DomainCoordinates_getHeight;
    var DomainCoordinates = /* @__PURE__ */ function() {
      function DomainCoordinates2(calendar2, domainPainter) {
        _classCallCheck$2(this, DomainCoordinates2);
        _DomainCoordinates_instances.add(this);
        this.calendar = calendar2;
        this.domainPainter = domainPainter;
        this.collection = /* @__PURE__ */ new Map();
        this.scrollDirection = ScrollDirection.SCROLL_FORWARD;
      }
      _createClass$2(DomainCoordinates2, [{
        key: "get",
        value: function get2(domainKey) {
          return this.collection.get(domainKey);
        }
      }, {
        key: "update",
        value: function update2(collection2, scrollDirection) {
          var _this = this;
          var _this$calendar$option = this.calendar.options.options, verticalOrientation = _this$calendar$option.verticalOrientation, domain = _this$calendar$option.domain;
          this.scrollDirection = scrollDirection;
          var dimensions = {
            width: 0,
            height: 0
          };
          var exitingTotal = 0;
          var scrollFactor = scrollDirection === ScrollDirection.SCROLL_FORWARD ? -1 : 1;
          var keys2 = collection2.keys;
          if (this.calendar.options.options.domain.sort === "desc") {
            keys2.reverse();
            scrollFactor *= -1;
          }
          collection2.yankedDomains.forEach(function(domainKey) {
            exitingTotal += _this.collection.get(domainKey)[verticalOrientation ? "height" : "width"];
          });
          collection2.yankedDomains.forEach(function(domainKey) {
            var coor = _this.collection.get(domainKey);
            _this.collection.set(domainKey, Object.assign(Object.assign({}, coor), {
              x: verticalOrientation ? coor.x : coor.x + exitingTotal * scrollFactor,
              y: verticalOrientation ? coor.y + exitingTotal * scrollFactor : coor.y
            }));
          });
          keys2.forEach(function(domainKey) {
            var w = __classPrivateFieldGet$1(_this, _DomainCoordinates_instances, "m", _DomainCoordinates_getWidth).call(_this, domainKey);
            var h = __classPrivateFieldGet$1(_this, _DomainCoordinates_instances, "m", _DomainCoordinates_getHeight).call(_this, domainKey);
            if (verticalOrientation) {
              dimensions.height += h;
              dimensions.width = Math.max(w, dimensions.width);
            } else {
              dimensions.width += w;
              dimensions.height = Math.max(h, dimensions.height);
            }
            var x = dimensions.width - w;
            var y = dimensions.height - h;
            _this.collection.set(domainKey, Object.assign(Object.assign({}, _this.collection.get(domainKey)), {
              x: verticalOrientation ? 0 : x,
              y: verticalOrientation ? y : 0,
              pre_x: verticalOrientation ? x : x - exitingTotal * scrollFactor,
              pre_y: verticalOrientation ? y - exitingTotal * scrollFactor : y,
              width: w,
              height: h,
              inner_width: w - (verticalOrientation ? 0 : domain.gutter),
              inner_height: h - (!verticalOrientation ? 0 : domain.gutter)
            }));
          });
          return dimensions;
        }
      }]);
      return DomainCoordinates2;
    }();
    _DomainCoordinates_instances = /* @__PURE__ */ new WeakSet(), _DomainCoordinates_getWidth = function _DomainCoordinates_getWidth2(d) {
      var _this$calendar$option2 = this.calendar.options.options, domain = _this$calendar$option2.domain, subDomain = _this$calendar$option2.subDomain, x = _this$calendar$option2.x, verticalOrientation = _this$calendar$option2.verticalOrientation;
      var columnsCount = this.calendar.templateCollection.get(subDomain.type).columnsCount(d);
      var subDomainWidth = (subDomain.width + subDomain.gutter) * columnsCount - subDomain.gutter;
      return horizontalPadding(domain.padding) + x.domainHorizontalLabelWidth + (verticalOrientation ? 0 : domain.gutter) + subDomainWidth;
    }, _DomainCoordinates_getHeight = function _DomainCoordinates_getHeight2(d) {
      var _this$calendar$option3 = this.calendar.options.options, domain = _this$calendar$option3.domain, subDomain = _this$calendar$option3.subDomain, x = _this$calendar$option3.x, verticalOrientation = _this$calendar$option3.verticalOrientation;
      var rowsCount = this.calendar.templateCollection.get(subDomain.type).rowsCount(d);
      var subDomainHeight = (subDomain.height + subDomain.gutter) * rowsCount - subDomain.gutter;
      return verticalPadding(domain.padding) + subDomainHeight + (verticalOrientation ? domain.gutter : 0) + x.domainVerticalLabelHeight;
    };
    var _DomainPainter_instances, _DomainPainter_getClassName;
    var DEFAULT_SELECTOR$3 = ".ch-domain";
    var DomainPainter = /* @__PURE__ */ function() {
      function DomainPainter2(calendar2) {
        _classCallCheck$2(this, DomainPainter2);
        _DomainPainter_instances.add(this);
        this.calendar = calendar2;
        this.coordinates = new DomainCoordinates(calendar2, this);
        this.root = null;
        this.dimensions = {
          width: 0,
          height: 0
        };
      }
      _createClass$2(DomainPainter2, [{
        key: "paint",
        value: function paint(scrollDirection, rootNode) {
          var _this = this;
          var animationDuration = this.calendar.options.options.animationDuration;
          var t = rootNode.transition().duration(animationDuration);
          var coor = this.coordinates;
          this.dimensions = coor.update(this.calendar.domainCollection, scrollDirection);
          var promises = [];
          this.root = rootNode.selectAll(DEFAULT_SELECTOR$3).data(this.calendar.domainCollection.keys, function(d) {
            return d;
          }).join(function(enter) {
            return enter.append("svg").attr("x", function(d) {
              return coor.get(d).pre_x;
            }).attr("y", function(d) {
              return coor.get(d).pre_y;
            }).attr("width", function(d) {
              return coor.get(d).inner_width;
            }).attr("height", function(d) {
              return coor.get(d).inner_height;
            }).attr("class", function(d) {
              return __classPrivateFieldGet$1(_this, _DomainPainter_instances, "m", _DomainPainter_getClassName).call(_this, d);
            }).call(function(enterSelection) {
              return enterSelection.append("rect").attr("width", function(d) {
                return coor.get(d).inner_width;
              }).attr("height", function(d) {
                return coor.get(d).inner_height;
              }).attr("class", "".concat(DEFAULT_SELECTOR$3.slice(1), "-bg"));
            }).call(function(enterSelection) {
              return promises.push(enterSelection.transition(t).attr("x", function(d) {
                return coor.get(d).x;
              }).attr("y", function(d) {
                return coor.get(d).y;
              }).end());
            });
          }, function(update2) {
            return update2.call(function(updateSelection) {
              return promises.push(updateSelection.transition(t).attr("x", function(d) {
                return coor.get(d).x;
              }).attr("y", function(d) {
                return coor.get(d).y;
              }).attr("width", function(d) {
                return coor.get(d).inner_width;
              }).attr("height", function(d) {
                return coor.get(d).inner_height;
              }).end());
            }).call(function(updateSelection) {
              return promises.push(updateSelection.selectAll("".concat(DEFAULT_SELECTOR$3, "-bg")).transition(t).attr("width", function(d) {
                return coor.get(d).inner_width;
              }).attr("height", function(d) {
                return coor.get(d).inner_height;
              }).end());
            });
          }, function(exit) {
            return exit.call(function(exitSelection) {
              return promises.push(exitSelection.transition(t).attr("x", function(d) {
                return coor.get(d).x;
              }).attr("y", function(d) {
                return coor.get(d).y;
              }).remove().end());
            });
          });
          return promises;
        }
      }]);
      return DomainPainter2;
    }();
    _DomainPainter_instances = /* @__PURE__ */ new WeakSet(), _DomainPainter_getClassName = function _DomainPainter_getClassName2(d) {
      var classname = DEFAULT_SELECTOR$3.slice(1);
      var helper = this.calendar.dateHelper.date(d);
      switch (this.calendar.options.options.domain.type) {
        case "hour":
          classname += " h_".concat(helper.hour());
          break;
        case "day":
          classname += " d_".concat(helper.date(), " dy_").concat(helper.format("d") + 1);
          break;
        case "week":
          classname += " w_".concat(helper.week());
          break;
        case "month":
          classname += " m_".concat(helper.month() + 1);
          break;
        case "year":
          classname += " y_".concat(helper.year());
          break;
      }
      return classname;
    };
    var $$8$1 = _export$2;
    var $includes = arrayIncludes$2.includes;
    var fails$8$2 = fails$u;
    var addToUnscopables$4 = addToUnscopables$3;
    var BROKEN_ON_SPARSE = fails$8$2(function() {
      return !Array(1).includes();
    });
    $$8$1({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables$4("includes");
    var $$7$1 = _export$2;
    var $filter = arrayIteration$1.filter;
    var arrayMethodHasSpeciesSupport$5 = arrayMethodHasSpeciesSupport$4;
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$5("filter");
    $$7$1({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      filter: function filter2(callbackfn) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    var anObject$3$2 = anObject$f;
    var iteratorClose$3 = iteratorClose$2$1;
    var callWithSafeIterationClosing$1 = function(iterator, fn, value, ENTRIES2) {
      try {
        return ENTRIES2 ? fn(anObject$3$2(value)[0], value[1]) : fn(value);
      } catch (error) {
        iteratorClose$3(iterator, "throw", error);
      }
    };
    var bind$8 = functionBindContext$2;
    var call$3$2 = functionCall$2;
    var toObject$2$2 = toObject$a;
    var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
    var isArrayIteratorMethod$3 = isArrayIteratorMethod$2$1;
    var isConstructor$5 = isConstructor$4;
    var lengthOfArrayLike$a = lengthOfArrayLike$9;
    var createProperty$5 = createProperty$4;
    var getIterator$3 = getIterator$2$1;
    var getIteratorMethod$4 = getIteratorMethod$3$1;
    var $Array$4 = Array;
    var arrayFrom = function from2(arrayLike) {
      var O = toObject$2$2(arrayLike);
      var IS_CONSTRUCTOR = isConstructor$5(this);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      if (mapping)
        mapfn = bind$8(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
      var iteratorMethod = getIteratorMethod$4(O);
      var index = 0;
      var length2, result, step, iterator, next, value;
      if (iteratorMethod && !(this === $Array$4 && isArrayIteratorMethod$3(iteratorMethod))) {
        iterator = getIterator$3(O, iteratorMethod);
        next = iterator.next;
        result = IS_CONSTRUCTOR ? new this() : [];
        for (; !(step = call$3$2(next, iterator)).done; index++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
          createProperty$5(result, index, value);
        }
      } else {
        length2 = lengthOfArrayLike$a(O);
        result = IS_CONSTRUCTOR ? new this(length2) : $Array$4(length2);
        for (; length2 > index; index++) {
          value = mapping ? mapfn(O[index], index) : O[index];
          createProperty$5(result, index, value);
        }
      }
      result.length = index;
      return result;
    };
    var $$6$2 = _export$2;
    var from = arrayFrom;
    var checkCorrectnessOfIteration$4 = checkCorrectnessOfIteration$3$1;
    var INCORRECT_ITERATION = !checkCorrectnessOfIteration$4(function(iterable) {
      Array.from(iterable);
    });
    $$6$2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
      from
    });
    var _DomainCollection_instances, _DomainCollection_setSubDomainValues, _DomainCollection_extractValues, _DomainCollection_refreshKeys;
    var DOMAIN_FORMAT = {
      year: "YYYY",
      month: "MMMM",
      week: "wo [week] YYYY",
      xDay: "Do MMM",
      ghDay: "Do MMM",
      day: "Do MMM",
      hour: "HH:00",
      minute: "HH:mm"
    };
    var DomainCollection = /* @__PURE__ */ function() {
      function DomainCollection2(dateHelper, interval2, start2, range2) {
        var excludeEnd = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
        _classCallCheck$2(this, DomainCollection2);
        _DomainCollection_instances.add(this);
        this.collection = /* @__PURE__ */ new Map();
        this.dateHelper = dateHelper;
        if (interval2 && start2 && range2) {
          var ts = this.dateHelper.intervals(interval2, start2, range2, excludeEnd).map(function(d) {
            return castArray(d);
          });
          this.collection = new Map(ts);
        }
        this.min = 0;
        this.max = 0;
        this.keys = [];
        this.yankedDomains = [];
        if (this.collection.size > 0) {
          __classPrivateFieldGet$1(this, _DomainCollection_instances, "m", _DomainCollection_refreshKeys).call(this);
        }
      }
      _createClass$2(DomainCollection2, [{
        key: "has",
        value: function has2(key) {
          return this.collection.has(key);
        }
      }, {
        key: "get",
        value: function get2(key) {
          return this.collection.get(key);
        }
      }, {
        key: "forEach",
        value: function forEach2(callback) {
          return this.collection.forEach(callback);
        }
      }, {
        key: "at",
        value: function at(index) {
          return this.keys[index];
        }
      }, {
        key: "clamp",
        value: function clamp(minDate, maxDate) {
          var _this = this;
          if (minDate && this.min < minDate) {
            this.keys.filter(function(key) {
              return key < minDate;
            }).forEach(function(d) {
              return _this.collection.delete(d);
            });
          }
          if (maxDate && this.max > maxDate) {
            this.keys.filter(function(key) {
              return key > maxDate;
            }).forEach(function(d) {
              return _this.collection.delete(d);
            });
          }
          __classPrivateFieldGet$1(this, _DomainCollection_instances, "m", _DomainCollection_refreshKeys).call(this);
          return this;
        }
      }, {
        key: "merge",
        value: function merge2(newCollection, limit, createValueCallback) {
          var _this2 = this;
          this.yankedDomains = [];
          newCollection.keys.forEach(function(domainKey, index) {
            if (_this2.has(domainKey)) {
              return;
            }
            if (_this2.collection.size >= limit) {
              var keyToRemove = _this2.max;
              if (domainKey > _this2.max) {
                keyToRemove = _this2.min;
              }
              if (keyToRemove && _this2.collection.delete(keyToRemove)) {
                _this2.yankedDomains.push(keyToRemove);
              }
            }
            _this2.collection.set(domainKey, createValueCallback(domainKey, index));
            __classPrivateFieldGet$1(_this2, _DomainCollection_instances, "m", _DomainCollection_refreshKeys).call(_this2);
          });
          this.yankedDomains = this.yankedDomains.sort(function(a2, b) {
            return a2 - b;
          });
        }
      }, {
        key: "slice",
        value: function slice2() {
          var _this3 = this;
          var limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var fromBeginning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (this.keys.length > limit) {
            var keysToDelete = fromBeginning ? this.keys.slice(0, -limit) : this.keys.slice(limit);
            keysToDelete.forEach(function(key) {
              _this3.collection.delete(key);
            });
            __classPrivateFieldGet$1(this, _DomainCollection_instances, "m", _DomainCollection_refreshKeys).call(this);
          }
          return this;
        }
      }, {
        key: "fill",
        value: function fill2(data2, _ref, subDomainKeyExtractor) {
          var _this4 = this;
          var x = _ref.x, y = _ref.y, groupY = _ref.groupY, defaultValue = _ref.defaultValue;
          var groupedRecords = this.groupRecords(data2, x, subDomainKeyExtractor);
          this.keys.forEach(function(domainKey) {
            var records = groupedRecords.get(domainKey) || {};
            __classPrivateFieldGet$1(_this4, _DomainCollection_instances, "m", _DomainCollection_setSubDomainValues).call(_this4, domainKey, records, y, groupY, defaultValue);
          });
        }
      }, {
        key: "groupRecords",
        value: function groupRecords(data2, x, subDomainKeyExtractor) {
          var _this5 = this;
          var results = /* @__PURE__ */ new Map();
          var validSubDomainTimestamp = /* @__PURE__ */ new Map();
          this.keys.forEach(function(domainKey) {
            _this5.get(domainKey).forEach(function(subDomain) {
              validSubDomainTimestamp.set(subDomain.t, domainKey);
            });
          });
          data2.forEach(function(d) {
            var timestamp = _this5.extractTimestamp(d, x, subDomainKeyExtractor);
            if (validSubDomainTimestamp.has(timestamp)) {
              var domainKey = validSubDomainTimestamp.get(timestamp);
              var records = results.get(domainKey) || {};
              records[timestamp] || (records[timestamp] = []);
              records[timestamp].push(d);
              results.set(domainKey, records);
            }
          });
          return results;
        }
        // eslint-disable-next-line class-methods-use-this
      }, {
        key: "groupValues",
        value: function groupValues(values2, groupFn) {
          var cleanedValues = values2.filter(function(n) {
            return n !== null;
          });
          if (typeof groupFn === "string") {
            if (cleanedValues.every(function(n) {
              return typeof n === "number";
            })) {
              switch (groupFn) {
                case "sum":
                  return cleanedValues.reduce(function(a2, b) {
                    return a2 + b;
                  }, 0);
                case "count":
                  return cleanedValues.length;
                case "min":
                  return Math.min.apply(Math, _toConsumableArray$1(cleanedValues)) || null;
                case "max":
                  return Math.max.apply(Math, _toConsumableArray$1(cleanedValues)) || null;
                case "average":
                  return cleanedValues.length > 0 ? cleanedValues.reduce(function(a2, b) {
                    return a2 + b;
                  }, 0) / cleanedValues.length : null;
                default:
                  return null;
              }
            }
            switch (groupFn) {
              case "count":
                return cleanedValues.length;
              default:
                return null;
            }
          } else if (typeof groupFn === "function") {
            return groupFn(cleanedValues);
          }
          return null;
        }
        // eslint-disable-next-line class-methods-use-this
      }, {
        key: "extractTimestamp",
        value: function extractTimestamp(datum2, x, extractorFn) {
          var timestamp = typeof x === "function" ? x(datum2) : datum2[x];
          if (typeof timestamp === "string") {
            timestamp = +new Date(timestamp);
          }
          return extractorFn(timestamp);
        }
      }]);
      return DomainCollection2;
    }();
    _DomainCollection_instances = /* @__PURE__ */ new WeakSet(), _DomainCollection_setSubDomainValues = function _DomainCollection_setSubDomainValues2(domainKey, records, y, groupY, defaultValue) {
      var _this6 = this;
      this.get(domainKey).forEach(function(subDomain, index) {
        var value = defaultValue;
        if (records.hasOwnProperty(subDomain.t)) {
          value = _this6.groupValues(__classPrivateFieldGet$1(_this6, _DomainCollection_instances, "m", _DomainCollection_extractValues).call(_this6, records[subDomain.t], y), groupY);
        }
        _this6.get(domainKey)[index].v = value;
      });
    }, _DomainCollection_extractValues = function _DomainCollection_extractValues2(data2, y) {
      return data2.map(function(d) {
        return typeof y === "function" ? y(d) : d[y];
      });
    }, _DomainCollection_refreshKeys = function _DomainCollection_refreshKeys2() {
      this.keys = Array.from(this.collection.keys()).map(function(d) {
        return parseInt(d, 10);
      }).sort(function(a2, b) {
        return a2 - b;
      });
      var keys2 = this.keys;
      this.min = keys2[0];
      this.max = keys2[keys2.length - 1];
      return this.keys;
    };
    var _DomainLabelPainter_instances, _DomainLabelPainter_textVerticalAlign, _DomainLabelPainter_getX, _DomainLabelPainter_getY, _DomainLabelPainter_getDomainInsideWidth, _DomainLabelPainter_getDomainInsideHeight, _DomainLabelPainter_domainRotate;
    var DEFAULT_SELECTOR$2 = ".ch-domain-text";
    var DomainLabelPainter = /* @__PURE__ */ function() {
      function DomainLabelPainter2(calendar2) {
        _classCallCheck$2(this, DomainLabelPainter2);
        _DomainLabelPainter_instances.add(this);
        this.calendar = calendar2;
      }
      _createClass$2(DomainLabelPainter2, [{
        key: "paint",
        value: function paint(root2) {
          var _this = this;
          var _this$calendar$option = this.calendar.options.options.domain, label = _this$calendar$option.label, type = _this$calendar$option.type;
          var dateHelper = this.calendar.dateHelper;
          var format2 = label.text;
          if (format2 === null || format2 === "") {
            return;
          }
          if (typeof format2 === "undefined") {
            format2 = DOMAIN_FORMAT[type];
          }
          root2.selectAll(DEFAULT_SELECTOR$2).data(function(d) {
            return [d];
          }, function(d) {
            return d;
          }).join(function(enter) {
            return enter.append("text").attr("class", DEFAULT_SELECTOR$2.slice(1)).attr("x", function(d) {
              return __classPrivateFieldGet$1(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getX).call(_this, d);
            }).attr("y", function(d) {
              return __classPrivateFieldGet$1(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getY).call(_this, d);
            }).attr("text-anchor", label.textAlign).attr("dominant-baseline", function() {
              return __classPrivateFieldGet$1(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_textVerticalAlign).call(_this);
            }).text(function(d, i, nodes) {
              return (
                // eslint-disable-next-line implicit-arrow-linebreak
                dateHelper.format(d, format2, nodes[i])
              );
            }).call(function(selection2) {
              return __classPrivateFieldGet$1(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_domainRotate).call(_this, selection2);
            });
          }, function(update2) {
            update2.attr("x", function(d) {
              return __classPrivateFieldGet$1(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getX).call(_this, d);
            }).attr("y", function(d) {
              return __classPrivateFieldGet$1(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getY).call(_this, d);
            }).attr("text-anchor", label.textAlign).attr("dominant-baseline", function() {
              return __classPrivateFieldGet$1(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_textVerticalAlign).call(_this);
            }).text(function(d, i, nodes) {
              return (
                // eslint-disable-next-line implicit-arrow-linebreak
                dateHelper.format(d, format2, nodes[i])
              );
            }).call(function(selection2) {
              return __classPrivateFieldGet$1(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_domainRotate).call(_this, selection2);
            });
          });
        }
      }]);
      return DomainLabelPainter2;
    }();
    _DomainLabelPainter_instances = /* @__PURE__ */ new WeakSet(), _DomainLabelPainter_textVerticalAlign = function _DomainLabelPainter_textVerticalAlign2() {
      var _this$calendar$option2 = this.calendar.options.options.domain.label, position2 = _this$calendar$option2.position, rotate = _this$calendar$option2.rotate;
      if (isVertical(position2)) {
        return "middle";
      }
      if (rotate === "left" && position2 === "left" || rotate === "right" && position2 === "right") {
        return "bottom";
      }
      return "hanging";
    }, _DomainLabelPainter_getX = function _DomainLabelPainter_getX2(d) {
      var _this$calendar$option3 = this.calendar.options.options.domain, padding = _this$calendar$option3.padding, _this$calendar$option4 = _this$calendar$option3.label, position2 = _this$calendar$option4.position, textAlign = _this$calendar$option4.textAlign, offset2 = _this$calendar$option4.offset;
      var domainHorizontalLabelWidth = this.calendar.options.options.x.domainHorizontalLabelWidth;
      var x = padding[Position.LEFT];
      if (position2 === "right") {
        x += __classPrivateFieldGet$1(this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(this, d);
      }
      if (textAlign === "middle") {
        if (["top", "bottom"].includes(position2)) {
          x += __classPrivateFieldGet$1(this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(this, d) / 2;
        } else {
          x += domainHorizontalLabelWidth / 2;
        }
      }
      if (textAlign === "end") {
        if (isVertical(position2)) {
          x += __classPrivateFieldGet$1(this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(this, d);
        } else {
          x += domainHorizontalLabelWidth;
        }
      }
      return x + offset2.x;
    }, _DomainLabelPainter_getY = function _DomainLabelPainter_getY2(d) {
      var _this$calendar$option5 = this.calendar.options.options, _this$calendar$option6 = _this$calendar$option5.domain, _this$calendar$option7 = _this$calendar$option6.label, position2 = _this$calendar$option7.position, offset2 = _this$calendar$option7.offset, padding = _this$calendar$option6.padding, x = _this$calendar$option5.x;
      var y = padding[Position.TOP] + x.domainVerticalLabelHeight / 2;
      if (position2 === "bottom") {
        y += __classPrivateFieldGet$1(this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideHeight).call(this, d);
      }
      return y + offset2.y;
    }, _DomainLabelPainter_getDomainInsideWidth = function _DomainLabelPainter_getDomainInsideWidth2(d) {
      var _this$calendar$option8 = this.calendar.options.options, padding = _this$calendar$option8.domain.padding, domainHorizontalLabelWidth = _this$calendar$option8.x.domainHorizontalLabelWidth;
      var coordinates = this.calendar.calendarPainter.domainsContainerPainter.domainPainter.coordinates;
      return coordinates.get(d).inner_width - domainHorizontalLabelWidth - horizontalPadding(padding);
    }, _DomainLabelPainter_getDomainInsideHeight = function _DomainLabelPainter_getDomainInsideHeight2(d) {
      var _this$calendar$option9 = this.calendar.options.options, domainVerticalLabelHeight = _this$calendar$option9.x.domainVerticalLabelHeight, padding = _this$calendar$option9.domain.padding;
      var coordinates = this.calendar.calendarPainter.domainsContainerPainter.domainPainter.coordinates;
      return coordinates.get(d).inner_height - domainVerticalLabelHeight - verticalPadding(padding);
    }, _DomainLabelPainter_domainRotate = function _DomainLabelPainter_domainRotate2(selection2) {
      var _this2 = this;
      var _this$calendar$option10 = this.calendar.options.options, _this$calendar$option11 = _this$calendar$option10.domain.label, rotate = _this$calendar$option11.rotate, textAlign = _this$calendar$option11.textAlign, position2 = _this$calendar$option11.position, x = _this$calendar$option10.x;
      var labelWidth = x.domainHorizontalLabelWidth;
      switch (rotate) {
        case "right":
          selection2.attr("transform", function(d) {
            var domainWidth = __classPrivateFieldGet$1(_this2, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(_this2, d);
            var domainHeight = __classPrivateFieldGet$1(_this2, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideHeight).call(_this2, d);
            var s2 = ["rotate(90, ".concat(position2 === "right" ? domainWidth : labelWidth, ", 0)")];
            switch (position2) {
              case "right":
                if (textAlign === "middle") {
                  s2.push("translate(".concat(domainHeight / 2 - labelWidth / 2, ")"));
                } else if (textAlign === "end") {
                  s2.push("translate(".concat(domainHeight - labelWidth, ")"));
                }
                break;
              case "left":
                if (textAlign === "start") {
                  s2.push("translate(".concat(labelWidth, ")"));
                } else if (textAlign === "middle") {
                  s2.push("translate(".concat(labelWidth / 2 + domainHeight / 2, ")"));
                } else if (textAlign === "end") {
                  s2.push("translate(".concat(domainHeight, ")"));
                }
                break;
            }
            return s2.join(",");
          });
          break;
        case "left":
          selection2.attr("transform", function(d) {
            var domainWidth = __classPrivateFieldGet$1(_this2, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(_this2, d);
            var domainHeight = __classPrivateFieldGet$1(_this2, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideHeight).call(_this2, d);
            var s2 = ["rotate(270, ".concat(position2 === "right" ? domainWidth : labelWidth, ", 0)")];
            switch (position2) {
              case "right":
                if (textAlign === "start") {
                  s2.push("translate(-".concat(domainHeight, ")"));
                } else if (textAlign === "middle") {
                  s2.push("translate(-".concat(domainHeight / 2 + labelWidth / 2, ")"));
                } else if (textAlign === "end") {
                  s2.push("translate(-".concat(labelWidth, ")"));
                }
                break;
              case "left":
                if (textAlign === "start") {
                  s2.push("translate(".concat(labelWidth - domainHeight, ")"));
                } else if (textAlign === "middle") {
                  s2.push("translate(".concat(labelWidth / 2 - domainHeight / 2, ")"));
                }
                break;
            }
            return s2.join(",");
          });
          break;
      }
    };
    var whitespaces$2 = "	\n\v\f\r                　\u2028\u2029\uFEFF";
    var uncurryThis$8$2 = functionUncurryThis$2;
    var requireObjectCoercible$3$1 = requireObjectCoercible$7;
    var toString$5$1 = toString$9;
    var whitespaces$1 = whitespaces$2;
    var replace$2 = uncurryThis$8$2("".replace);
    var ltrim = RegExp("^[" + whitespaces$1 + "]+");
    var rtrim = RegExp("(^|[^" + whitespaces$1 + "])[" + whitespaces$1 + "]+$");
    var createMethod$1$1 = function(TYPE) {
      return function($this) {
        var string2 = toString$5$1(requireObjectCoercible$3$1($this));
        if (TYPE & 1)
          string2 = replace$2(string2, ltrim, "");
        if (TYPE & 2)
          string2 = replace$2(string2, rtrim, "$1");
        return string2;
      };
    };
    var stringTrim = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod$1$1(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod$1$1(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod$1$1(3)
    };
    var PROPER_FUNCTION_NAME$2 = functionName$2.PROPER;
    var fails$7$2 = fails$u;
    var whitespaces = whitespaces$2;
    var non = "​᠎";
    var stringTrimForced = function(METHOD_NAME) {
      return fails$7$2(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME$2 && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
    var $$5$2 = _export$2;
    var $trim = stringTrim.trim;
    var forcedStringTrimMethod = stringTrimForced;
    $$5$2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim() {
        return $trim(this);
      }
    });
    var _SubDomainPainter_instances, _SubDomainPainter_setPositions, _SubDomainPainter_classname, _SubDomainPainter_appendText, _SubDomainPainter_getCoordinates, _SubDomainPainter_getX, _SubDomainPainter_getY;
    var DEFAULT_SELECTOR$1$1 = ".ch-subdomain";
    var HIGHLIGHT_CLASSNAME = "highlight";
    var SubDomainPainter = /* @__PURE__ */ function() {
      function SubDomainPainter2(calendar2) {
        _classCallCheck$2(this, SubDomainPainter2);
        _SubDomainPainter_instances.add(this);
        this.calendar = calendar2;
        this.root = null;
      }
      _createClass$2(SubDomainPainter2, [{
        key: "paint",
        value: function paint(root2) {
          var _this = this;
          this.root = root2 || this.root;
          var containerClassname = "".concat(DEFAULT_SELECTOR$1$1, "-container");
          var subDomainSvgGroup = this.root.selectAll(containerClassname).data(function(d) {
            return [d];
          }, function(d) {
            return d;
          }).join(function(enter) {
            return enter.append("svg").call(function(selection2) {
              return __classPrivateFieldGet$1(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_setPositions).call(_this, selection2);
            }).attr("class", containerClassname.slice(1));
          }, function(update2) {
            return (
              // eslint-disable-next-line implicit-arrow-linebreak
              update2.call(function(selection2) {
                return __classPrivateFieldGet$1(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_setPositions).call(_this, selection2);
              })
            );
          });
          var _this$calendar$option = this.calendar.options.options.subDomain, radius2 = _this$calendar$option.radius, width = _this$calendar$option.width, height = _this$calendar$option.height, sort2 = _this$calendar$option.sort;
          var evt = this.calendar.eventEmitter;
          subDomainSvgGroup.selectAll("g").data(function(d) {
            var subDomainsCollection = _this.calendar.domainCollection.get(d);
            if (sort2 === "desc") {
              var max2 = Math.max.apply(Math, _toConsumableArray$1(subDomainsCollection.map(function(s2) {
                return s2.x;
              })));
              subDomainsCollection.forEach(function(s2, i) {
                subDomainsCollection[i].x = Math.abs(s2.x - max2);
              });
            }
            return subDomainsCollection;
          }).join(function(enter) {
            return enter.append("g").call(function(selection2) {
              return selection2.insert("rect").attr("class", function(d) {
                return (
                  // eslint-disable-next-line implicit-arrow-linebreak
                  __classPrivateFieldGet$1(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_classname).call(_this, d.t, "".concat(DEFAULT_SELECTOR$1$1.slice(1), "-bg"))
                );
              }).attr("width", width).attr("height", height).attr("x", function(d) {
                return __classPrivateFieldGet$1(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_getX).call(_this, d);
              }).attr("y", function(d) {
                return __classPrivateFieldGet$1(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_getY).call(_this, d);
              }).on("click", function(ev, d) {
                return (
                  // eslint-disable-next-line implicit-arrow-linebreak
                  evt.emit("click", ev, d.t, d.v)
                );
              }).on("mouseover", function(ev, d) {
                return (
                  // eslint-disable-next-line implicit-arrow-linebreak
                  evt.emit("mouseover", ev, d.t, d.v)
                );
              }).on("mouseout", function(ev, d) {
                return (
                  // eslint-disable-next-line implicit-arrow-linebreak
                  evt.emit("mouseout", ev, d.t, d.v)
                );
              }).attr("rx", radius2 > 0 ? radius2 : null).attr("ry", radius2 > 0 ? radius2 : null);
            }).call(function(selection2) {
              return __classPrivateFieldGet$1(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_appendText).call(_this, selection2);
            });
          }, function(update2) {
            return update2.selectAll("rect").attr("class", function(d) {
              return (
                // eslint-disable-next-line implicit-arrow-linebreak
                __classPrivateFieldGet$1(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_classname).call(_this, d.t, "".concat(DEFAULT_SELECTOR$1$1.slice(1), "-bg"))
              );
            }).attr("width", width).attr("height", height).attr("x", function(d) {
              return __classPrivateFieldGet$1(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_getX).call(_this, d);
            }).attr("y", function(d) {
              return __classPrivateFieldGet$1(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_getY).call(_this, d);
            }).attr("rx", radius2).attr("ry", radius2);
          });
        }
      }]);
      return SubDomainPainter2;
    }();
    _SubDomainPainter_instances = /* @__PURE__ */ new WeakSet(), _SubDomainPainter_setPositions = function _SubDomainPainter_setPositions2(selection2) {
      var options = this.calendar.options.options;
      var _options$domain = options.domain, padding = _options$domain.padding, position2 = _options$domain.label.position;
      selection2.attr("x", function() {
        var pos = padding[Position.LEFT];
        if (position2 === "left") {
          pos += options.x.domainHorizontalLabelWidth;
        }
        return pos;
      }).attr("y", function() {
        var pos = padding[Position.TOP];
        if (position2 === "top") {
          pos += options.x.domainVerticalLabelHeight;
        }
        return pos;
      });
    }, _SubDomainPainter_classname = function _SubDomainPainter_classname2(timestamp) {
      var _this2 = this;
      var _this$calendar$option2 = this.calendar.options.options, highlight = _this$calendar$option2.date.highlight, type = _this$calendar$option2.subDomain.type;
      var classname = "";
      if (highlight.length > 0) {
        highlight.forEach(function(d) {
          var unitFn = _this2.calendar.templateCollection.get(type).extractUnit;
          if (unitFn(+d) === unitFn(timestamp)) {
            classname = HIGHLIGHT_CLASSNAME;
          }
        });
      }
      for (var _len = arguments.length, otherClasses = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        otherClasses[_key - 1] = arguments[_key];
      }
      return [classname].concat(otherClasses).join(" ").trim();
    }, _SubDomainPainter_appendText = function _SubDomainPainter_appendText2(elem) {
      var _this3 = this;
      var _this$calendar$option3 = this.calendar.options.options.subDomain, width = _this$calendar$option3.width, height = _this$calendar$option3.height, label = _this$calendar$option3.label;
      if (!label) {
        return null;
      }
      return elem.append("text").attr("class", function(d) {
        return (
          // eslint-disable-next-line implicit-arrow-linebreak
          __classPrivateFieldGet$1(_this3, _SubDomainPainter_instances, "m", _SubDomainPainter_classname).call(_this3, d.t, "".concat(DEFAULT_SELECTOR$1$1.slice(1), "-text"))
        );
      }).attr("x", function(d) {
        return __classPrivateFieldGet$1(_this3, _SubDomainPainter_instances, "m", _SubDomainPainter_getX).call(_this3, d) + width / 2;
      }).attr("y", function(d) {
        return __classPrivateFieldGet$1(_this3, _SubDomainPainter_instances, "m", _SubDomainPainter_getY).call(_this3, d) + height / 2;
      }).attr("text-anchor", "middle").attr("dominant-baseline", "central").text(function(d, i, nodes) {
        return (
          // eslint-disable-next-line implicit-arrow-linebreak
          _this3.calendar.dateHelper.format(d.t, label, d.v, nodes[i])
        );
      });
    }, _SubDomainPainter_getCoordinates = function _SubDomainPainter_getCoordinates2(axis2, d) {
      var subDomain = this.calendar.options.options.subDomain;
      return d[axis2] * (subDomain[axis2 === "x" ? "width" : "height"] + subDomain.gutter);
    }, _SubDomainPainter_getX = function _SubDomainPainter_getX2(d) {
      return __classPrivateFieldGet$1(this, _SubDomainPainter_instances, "m", _SubDomainPainter_getCoordinates).call(this, "x", d);
    }, _SubDomainPainter_getY = function _SubDomainPainter_getY2(d) {
      return __classPrivateFieldGet$1(this, _SubDomainPainter_instances, "m", _SubDomainPainter_getCoordinates).call(this, "y", d);
    };
    var _DomainsContainerPainter_instances, _DomainsContainerPainter_startAnimation, _DomainsContainerPainter_endAnimation, _DomainsContainerPainter_recomputeDimensions;
    var BASE_SELECTOR = ".ch-domain-container";
    var TRANSITION_CLASSNAME = "in-transition";
    var DomainsContainerPainter = /* @__PURE__ */ function() {
      function DomainsContainerPainter2(calendar2) {
        _classCallCheck$2(this, DomainsContainerPainter2);
        _DomainsContainerPainter_instances.add(this);
        this.calendar = calendar2;
        this.domainPainter = new DomainPainter(calendar2);
        this.subDomainPainter = new SubDomainPainter(calendar2);
        this.domainLabelPainter = new DomainLabelPainter(calendar2);
        this.dimensions = {
          width: 0,
          height: 0
        };
        this.transitionsQueueCount = 0;
      }
      _createClass$2(DomainsContainerPainter2, [{
        key: "setup",
        value: function setup() {
          this.root = this.calendar.calendarPainter.root.attr("x", 0).attr("y", 0).append("svg").attr("class", BASE_SELECTOR.slice(1)).append("svg").attr("class", "".concat(BASE_SELECTOR.slice(1), "-animation-wrapper"));
        }
      }, {
        key: "paint",
        value: function paint(scrollDirection) {
          var _this = this;
          __classPrivateFieldGet$1(this, _DomainsContainerPainter_instances, "m", _DomainsContainerPainter_startAnimation).call(this);
          var result = this.domainPainter.paint(scrollDirection, this.root);
          this.subDomainPainter.paint(this.domainPainter.root);
          this.domainLabelPainter.paint(this.domainPainter.root);
          __classPrivateFieldGet$1(this, _DomainsContainerPainter_instances, "m", _DomainsContainerPainter_recomputeDimensions).call(this);
          Promise.allSettled(result).then(function() {
            __classPrivateFieldGet$1(_this, _DomainsContainerPainter_instances, "m", _DomainsContainerPainter_endAnimation).call(_this);
          });
          return result;
        }
      }, {
        key: "updatePosition",
        value: function updatePosition() {
          var _a;
          if (!((_a = this.root) === null || _a === void 0 ? void 0 : _a.node())) {
            return Promise.resolve();
          }
          var animationDuration = this.calendar.options.options.animationDuration;
          var topHeight = this.calendar.pluginManager.getHeightFromPosition("top");
          var leftWidth = this.calendar.pluginManager.getWidthFromPosition("left");
          return [select$1(this.root.node().parentNode).transition().duration(animationDuration).call(function(selection2) {
            selection2.attr("x", leftWidth).attr("y", topHeight);
          }).end()];
        }
      }, {
        key: "width",
        value: function width() {
          return this.dimensions.width;
        }
      }, {
        key: "height",
        value: function height() {
          return this.dimensions.height;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          __classPrivateFieldGet$1(this, _DomainsContainerPainter_instances, "m", _DomainsContainerPainter_startAnimation).call(this);
          return Promise.resolve();
        }
      }]);
      return DomainsContainerPainter2;
    }();
    _DomainsContainerPainter_instances = /* @__PURE__ */ new WeakSet(), _DomainsContainerPainter_startAnimation = function _DomainsContainerPainter_startAnimation2() {
      var _a;
      if ((_a = this.root) === null || _a === void 0 ? void 0 : _a.node()) {
        this.transitionsQueueCount += 1;
        select$1(this.root.node().parentNode).classed(TRANSITION_CLASSNAME, true);
      }
    }, _DomainsContainerPainter_endAnimation = function _DomainsContainerPainter_endAnimation2() {
      var _a;
      if ((_a = this.root) === null || _a === void 0 ? void 0 : _a.node()) {
        this.transitionsQueueCount -= 1;
        if (this.transitionsQueueCount === 0) {
          select$1(this.root.node().parentNode).classed(TRANSITION_CLASSNAME, false);
        }
      }
    }, _DomainsContainerPainter_recomputeDimensions = function _DomainsContainerPainter_recomputeDimensions2() {
      var _this$calendar$option = this.calendar.options.options, animationDuration = _this$calendar$option.animationDuration, verticalOrientation = _this$calendar$option.verticalOrientation, gutter = _this$calendar$option.domain.gutter;
      var domainsDimensions = this.domainPainter.dimensions;
      this.dimensions = {
        width: domainsDimensions.width - (verticalOrientation ? 0 : gutter),
        height: domainsDimensions.height - (!verticalOrientation ? 0 : gutter)
      };
      this.root.transition().duration(animationDuration).attr("width", this.dimensions.width).attr("height", this.dimensions.height);
    };
    var PluginPainter = /* @__PURE__ */ function() {
      function PluginPainter2(calendar2) {
        _classCallCheck$2(this, PluginPainter2);
        this.calendar = calendar2;
      }
      _createClass$2(PluginPainter2, [{
        key: "paint",
        value: function paint() {
          var promises = [];
          promises = promises.concat(this.calendar.pluginManager.paintAll());
          promises = promises.concat(this.setPluginsPosition());
          return promises;
        }
      }, {
        key: "setPluginsPosition",
        value: function setPluginsPosition() {
          var pluginManager = this.calendar.pluginManager;
          var animationDuration = this.calendar.options.options.animationDuration;
          var domainsContainerPainter = this.calendar.calendarPainter.domainsContainerPainter;
          var top2 = pluginManager.getFromPosition("top");
          var right2 = pluginManager.getFromPosition("right");
          var bottom2 = pluginManager.getFromPosition("bottom");
          var left2 = pluginManager.getFromPosition("left");
          var topHeight = pluginManager.getHeightFromPosition("top");
          var leftWidth = pluginManager.getWidthFromPosition("left");
          var promises = [];
          var topOffset = 0;
          top2.forEach(function(plugin) {
            promises.push(plugin.root.transition().duration(animationDuration).attr("y", topOffset).attr("x", leftWidth).end());
            topOffset += plugin.options.dimensions.height;
          });
          var leftOffset = 0;
          left2.forEach(function(plugin) {
            promises.push(plugin.root.transition().duration(animationDuration).attr("x", leftOffset).attr("y", topHeight).end());
            leftOffset += plugin.options.dimensions.width;
          });
          bottom2.forEach(function(plugin) {
            promises.push(plugin.root.transition().duration(animationDuration).attr("x", leftWidth).attr("y", topHeight + domainsContainerPainter.height()).end());
          });
          leftOffset += domainsContainerPainter.width();
          right2.forEach(function(plugin) {
            promises.push(plugin.root.transition().duration(animationDuration).attr("x", leftOffset).attr("y", topHeight).end());
            leftOffset += plugin.options.dimensions.width;
          });
          return promises;
        }
      }, {
        key: "insideWidth",
        value: function insideWidth() {
          return this.calendar.pluginManager.getWidthFromPosition("left") + this.calendar.pluginManager.getWidthFromPosition("right");
        }
      }, {
        key: "insideHeight",
        value: function insideHeight() {
          return this.calendar.pluginManager.getHeightFromPosition("top") + this.calendar.pluginManager.getHeightFromPosition("bottom");
        }
      }]);
      return PluginPainter2;
    }();
    var _CalendarPainter_instances, _CalendarPainter_getHeight, _CalendarPainter_getWidth, _CalendarPainter_resize;
    var DEFAULT_SELECTOR$4 = ".ch-container";
    var CalendarPainter = /* @__PURE__ */ function() {
      function CalendarPainter2(calendar2) {
        _classCallCheck$2(this, CalendarPainter2);
        _CalendarPainter_instances.add(this);
        this.calendar = calendar2;
        this.dimensions = {
          width: 0,
          height: 0
        };
        this.root = null;
        this.domainsContainerPainter = new DomainsContainerPainter(calendar2);
        this.pluginPainter = new PluginPainter(calendar2);
      }
      _createClass$2(CalendarPainter2, [{
        key: "setup",
        value: function setup() {
          var _this$calendar$option = this.calendar.options.options, itemSelector = _this$calendar$option.itemSelector, theme = _this$calendar$option.theme;
          if (!this.root) {
            this.root = select$1(itemSelector).append("svg").attr("data-theme", theme).attr("class", DEFAULT_SELECTOR$4.slice(1));
            this.domainsContainerPainter.setup();
          }
          this.calendar.pluginManager.setupAll();
          return true;
        }
      }, {
        key: "paint",
        value: function paint() {
          var navigationDir = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ScrollDirection.SCROLL_NONE;
          var transitions = this.domainsContainerPainter.paint(navigationDir).concat(this.pluginPainter.paint()).concat(this.domainsContainerPainter.updatePosition());
          __classPrivateFieldGet$1(this, _CalendarPainter_instances, "m", _CalendarPainter_resize).call(this);
          return Promise.allSettled(transitions);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var result = this.calendar.pluginManager.destroyAll().concat(this.domainsContainerPainter.destroy());
          if (!this.root) {
            return Promise.allSettled(result);
          }
          result.push(this.root.transition().duration(this.calendar.options.options.animationDuration).attr("width", 0).attr("height", 0).remove().end());
          return Promise.allSettled(result);
        }
      }]);
      return CalendarPainter2;
    }();
    _CalendarPainter_instances = /* @__PURE__ */ new WeakSet(), _CalendarPainter_getHeight = function _CalendarPainter_getHeight2() {
      return this.domainsContainerPainter.height() + this.pluginPainter.insideHeight();
    }, _CalendarPainter_getWidth = function _CalendarPainter_getWidth2() {
      return this.domainsContainerPainter.width() + this.pluginPainter.insideWidth();
    }, _CalendarPainter_resize = function _CalendarPainter_resize2() {
      var options = this.calendar.options.options;
      var newWidth = __classPrivateFieldGet$1(this, _CalendarPainter_instances, "m", _CalendarPainter_getWidth).call(this);
      var newHeight = __classPrivateFieldGet$1(this, _CalendarPainter_instances, "m", _CalendarPainter_getHeight).call(this);
      this.root.transition().duration(options.animationDuration).attr("width", newWidth).attr("height", newHeight);
      if (newWidth !== this.dimensions.width || newHeight !== this.dimensions.height) {
        this.calendar.eventEmitter.emit("resize", newWidth, newHeight, this.dimensions.width, this.dimensions.height);
      }
      this.dimensions = {
        width: newWidth,
        height: newHeight
      };
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal$1 || freeSelf || Function("return this")();
    var root$1 = root;
    var Symbol$1$2 = root$1.Symbol;
    var Symbol$2 = Symbol$1$2;
    var objectProto$f = Object.prototype;
    var hasOwnProperty$c = objectProto$f.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$f.toString;
    var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$e = Object.prototype;
    var nativeObjectToString = objectProto$e.toString;
    function objectToString$1$1(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1$1(value);
    }
    function isObject$2$2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject$2$2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var $$4$2 = _export$2;
    var toObject$1$2 = toObject$a;
    var nativeKeys$2 = objectKeys$3$1;
    var fails$6$2 = fails$u;
    var FAILS_ON_PRIMITIVES$2 = fails$6$2(function() {
      nativeKeys$2(1);
    });
    $$4$2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$2 }, {
      keys: function keys2(it) {
        return nativeKeys$2(toObject$1$2(it));
      }
    });
    var isObject$1$2 = isObject$j;
    var classof$1$2 = classofRaw$2$2;
    var wellKnownSymbol$3$2 = wellKnownSymbol$m;
    var MATCH$1 = wellKnownSymbol$3$2("match");
    var isRegexp = function(it) {
      var isRegExp2;
      return isObject$1$2(it) && ((isRegExp2 = it[MATCH$1]) !== void 0 ? !!isRegExp2 : classof$1$2(it) === "RegExp");
    };
    var isRegExp = isRegexp;
    var $TypeError$1$2 = TypeError;
    var notARegexp = function(it) {
      if (isRegExp(it)) {
        throw new $TypeError$1$2("The method doesn't accept regular expressions");
      }
      return it;
    };
    var wellKnownSymbol$2$2 = wellKnownSymbol$m;
    var MATCH = wellKnownSymbol$2$2("match");
    var correctIsRegexpLogic = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
    var $$3$2 = _export$2;
    var uncurryThis$7$2 = functionUncurryThisClause$2;
    var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor$2.f;
    var toLength$1$2 = toLength$3;
    var toString$4$1 = toString$9;
    var notARegExp$1 = notARegexp;
    var requireObjectCoercible$2$2 = requireObjectCoercible$7;
    var correctIsRegExpLogic$1 = correctIsRegexpLogic;
    var nativeStartsWith = uncurryThis$7$2("".startsWith);
    var stringSlice$3$1 = uncurryThis$7$2("".slice);
    var min$1$2 = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic$1("startsWith");
    var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor$4(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    }();
    $$3$2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString$4$1(requireObjectCoercible$2$2(this));
        notARegExp$1(searchString);
        var index = toLength$1$2(min$1$2(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = toString$4$1(searchString);
        return nativeStartsWith ? nativeStartsWith(that, search, index) : stringSlice$3$1(that, index, index + search.length) === search;
      }
    });
    var DESCRIPTORS$1$2 = descriptors$2;
    var fails$5$2 = fails$u;
    var uncurryThis$6$2 = functionUncurryThis$2;
    var objectGetPrototypeOf$2 = objectGetPrototypeOf$1;
    var objectKeys$4 = objectKeys$3$1;
    var toIndexedObject$a = toIndexedObject$9;
    var $propertyIsEnumerable$2 = objectPropertyIsEnumerable$2.f;
    var propertyIsEnumerable$2 = uncurryThis$6$2($propertyIsEnumerable$2);
    var push$1$1 = uncurryThis$6$2([].push);
    var IE_BUG = DESCRIPTORS$1$2 && fails$5$2(function() {
      var O = /* @__PURE__ */ Object.create(null);
      O[2] = 2;
      return !propertyIsEnumerable$2(O, 2);
    });
    var createMethod$5 = function(TO_ENTRIES) {
      return function(it) {
        var O = toIndexedObject$a(it);
        var keys2 = objectKeys$4(O);
        var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf$2(O) === null;
        var length2 = keys2.length;
        var i = 0;
        var result = [];
        var key;
        while (length2 > i) {
          key = keys2[i++];
          if (!DESCRIPTORS$1$2 || (IE_WORKAROUND ? key in O : propertyIsEnumerable$2(O, key))) {
            push$1$1(result, TO_ENTRIES ? [key, O[key]] : O[key]);
          }
        }
        return result;
      };
    };
    var objectToArray = {
      // `Object.entries` method
      // https://tc39.es/ecma262/#sec-object.entries
      entries: createMethod$5(true),
      // `Object.values` method
      // https://tc39.es/ecma262/#sec-object.values
      values: createMethod$5(false)
    };
    var $$2$2 = _export$2;
    var $entries = objectToArray.entries;
    $$2$2({ target: "Object", stat: true }, {
      entries: function entries(O) {
        return $entries(O);
      }
    });
    function defined$1(x) {
      return x != null && !Number.isNaN(x);
    }
    function ascendingDefined$1(a2, b) {
      return +defined$1(b) - +defined$1(a2) || ascending$1(a2, b);
    }
    function finite$1(x) {
      return isFinite(x) ? x : NaN;
    }
    function positive$1(x) {
      return x > 0 && isFinite(x) ? x : NaN;
    }
    function negative$1(x) {
      return x < 0 && isFinite(x) ? x : NaN;
    }
    const re$1 = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
    function parse$1(string2, fallback) {
      if (!re$1.test(string2 += ""))
        return typeof fallback === "function" ? fallback(string2) : fallback;
      return new Date(string2);
    }
    const timeIntervals$1 = /* @__PURE__ */ new Map([
      ["second", second],
      ["minute", timeMinute],
      ["hour", timeHour],
      ["day", timeDay],
      ["week", timeSunday],
      ["month", timeMonth],
      ["quarter", timeMonth.every(3)],
      ["half", timeMonth.every(6)],
      ["year", timeYear],
      ["monday", timeMonday],
      ["tuesday", timeTuesday],
      ["wednesday", timeWednesday],
      ["thursday", timeThursday],
      ["friday", timeFriday],
      ["saturday", timeSaturday],
      ["sunday", timeSunday]
    ]);
    const utcIntervals$1 = /* @__PURE__ */ new Map([
      ["second", second],
      ["minute", utcMinute],
      ["hour", utcHour],
      ["day", utcDay],
      ["week", utcSunday],
      ["month", utcMonth],
      ["quarter", utcMonth.every(3)],
      ["half", utcMonth.every(6)],
      ["year", utcYear],
      ["monday", utcMonday],
      ["tuesday", utcTuesday],
      ["wednesday", utcWednesday],
      ["thursday", utcThursday],
      ["friday", utcFriday],
      ["saturday", utcSaturday],
      ["sunday", utcSunday]
    ]);
    function maybeTimeInterval$1(interval2) {
      const i = timeIntervals$1.get(`${interval2}`.toLowerCase());
      if (!i)
        throw new Error(`unknown interval: ${interval2}`);
      return i;
    }
    function maybeUtcInterval$1(interval2) {
      const i = utcIntervals$1.get(`${interval2}`.toLowerCase());
      if (!i)
        throw new Error(`unknown interval: ${interval2}`);
      return i;
    }
    const TypedArray$1 = Object.getPrototypeOf(Uint8Array);
    const objectToString$3 = Object.prototype.toString;
    const constant$1 = (x) => () => x;
    function coerceNumbers$1(values2) {
      return values2 instanceof TypedArray$1 ? values2 : map$1(values2, coerceNumber$1, Float64Array);
    }
    function coerceNumber$1(x) {
      return x == null ? NaN : Number(x);
    }
    function coerceDates$1(values2) {
      return map$1(values2, coerceDate$1);
    }
    function coerceDate$1(x) {
      return x instanceof Date && !isNaN(x) ? x : typeof x === "string" ? parse$1(x) : x == null || isNaN(x = +x) ? void 0 : new Date(x);
    }
    function arrayify$1(data2) {
      return data2 == null || data2 instanceof Array || data2 instanceof TypedArray$1 ? data2 : Array.from(data2);
    }
    function map$1(values2, f, type = Array) {
      return values2 == null ? values2 : values2 instanceof type ? values2.map(f) : type.from(values2, f);
    }
    function slice$1(values2, type = Array) {
      return values2 instanceof type ? values2.slice() : type.from(values2);
    }
    function isObject$k(option) {
      return (option == null ? void 0 : option.toString) === objectToString$3;
    }
    function isScaleOptions$1(option) {
      return isObject$k(option) && (option.type !== void 0 || option.domain !== void 0);
    }
    function maybeInterval$1(interval2, type) {
      if (interval2 == null)
        return;
      if (typeof interval2 === "number") {
        if (0 < interval2 && interval2 < 1 && Number.isInteger(1 / interval2))
          interval2 = -1 / interval2;
        const n = Math.abs(interval2);
        return interval2 < 0 ? {
          floor: (d) => Math.floor(d * n) / n,
          offset: (d) => (d * n + 1) / n,
          // note: no optional step for simplicity
          range: (lo, hi) => range(Math.ceil(lo * n), hi * n).map((x) => x / n)
        } : {
          floor: (d) => Math.floor(d / n) * n,
          offset: (d) => d + n,
          // note: no optional step for simplicity
          range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x) => x * n)
        };
      }
      if (typeof interval2 === "string")
        return (type === "time" ? maybeTimeInterval$1 : maybeUtcInterval$1)(interval2);
      if (typeof interval2.floor !== "function")
        throw new Error("invalid interval; missing floor method");
      if (typeof interval2.offset !== "function")
        throw new Error("invalid interval; missing offset method");
      return interval2;
    }
    function maybeRangeInterval$1(interval2, type) {
      interval2 = maybeInterval$1(interval2, type);
      if (interval2 && typeof interval2.range !== "function")
        throw new Error("invalid interval: missing range method");
      return interval2;
    }
    function maybeNiceInterval$1(interval2, type) {
      interval2 = maybeRangeInterval$1(interval2, type);
      if (interval2 && typeof interval2.ceil !== "function")
        throw new Error("invalid interval: missing ceil method");
      return interval2;
    }
    function isOrdinal$1(values2) {
      for (const value of values2) {
        if (value == null)
          continue;
        const type = typeof value;
        return type === "string" || type === "boolean";
      }
    }
    function isTemporal$1(values2) {
      for (const value of values2) {
        if (value == null)
          continue;
        return value instanceof Date;
      }
    }
    function isTemporalString$1(values2) {
      for (const value of values2) {
        if (value == null)
          continue;
        return typeof value === "string" && isNaN(value) && parse$1(value);
      }
    }
    function isNumericString$1(values2) {
      for (const value of values2) {
        if (value == null)
          continue;
        if (typeof value !== "string")
          return false;
        if (!value.trim())
          continue;
        return !isNaN(value);
      }
    }
    function isNoneish$1(value) {
      return value == null || isNone$1(value);
    }
    function isNone$1(value) {
      return /^\s*none\s*$/i.test(value);
    }
    function orderof$1(values2) {
      if (values2 == null)
        return;
      const first = values2[0];
      const last = values2[values2.length - 1];
      return descending(first, last);
    }
    const position$1 = Symbol("position");
    const color$1 = Symbol("color");
    const radius$1 = Symbol("radius");
    const length$1 = Symbol("length");
    const opacity$1 = Symbol("opacity");
    const symbol$1 = Symbol("symbol");
    const registry$1 = /* @__PURE__ */ new Map([
      ["x", position$1],
      ["y", position$1],
      ["fx", position$1],
      ["fy", position$1],
      ["r", radius$1],
      ["color", color$1],
      ["opacity", opacity$1],
      ["symbol", symbol$1],
      ["length", length$1]
    ]);
    const sqrt3$1 = Math.sqrt(3);
    const sqrt4_3$1 = 2 / sqrt3$1;
    const symbolHexagon$1 = {
      draw(context, size) {
        const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3$1, hy = ry / 2;
        context.moveTo(0, ry);
        context.lineTo(rx, hy);
        context.lineTo(rx, -hy);
        context.lineTo(0, -ry);
        context.lineTo(-rx, -hy);
        context.lineTo(-rx, hy);
        context.closePath();
      }
    };
    const symbols$1 = /* @__PURE__ */ new Map([
      ["asterisk", symbolAsterisk],
      ["circle", symbolCircle],
      ["cross", symbolCross],
      ["diamond", symbolDiamond],
      ["diamond2", symbolDiamond2],
      ["hexagon", symbolHexagon$1],
      ["plus", symbolPlus],
      ["square", symbolSquare],
      ["square2", symbolSquare2],
      ["star", symbolStar],
      ["times", symbolTimes],
      ["triangle", symbolTriangle],
      ["triangle2", symbolTriangle2],
      ["wye", symbolWye]
    ]);
    function isSymbolObject$1(value) {
      return value && typeof value.draw === "function";
    }
    function maybeSymbol$1(symbol2) {
      if (symbol2 == null || isSymbolObject$1(symbol2))
        return symbol2;
      const value = symbols$1.get(`${symbol2}`.toLowerCase());
      if (value)
        return value;
      throw new Error(`invalid symbol: ${symbol2}`);
    }
    function warn$1(message) {
      console.warn(message);
    }
    const ordinalSchemes$1 = /* @__PURE__ */ new Map([
      // categorical
      ["accent", schemeAccent],
      ["category10", schemeCategory10],
      ["dark2", schemeDark2],
      ["paired", schemePaired],
      ["pastel1", schemePastel1],
      ["pastel2", schemePastel2],
      ["set1", schemeSet1],
      ["set2", schemeSet2],
      ["set3", schemeSet3],
      ["tableau10", schemeTableau10],
      // diverging
      ["brbg", scheme11$1(scheme$q, interpolateBrBG)],
      ["prgn", scheme11$1(scheme$p, interpolatePRGn)],
      ["piyg", scheme11$1(scheme$o, interpolatePiYG)],
      ["puor", scheme11$1(scheme$n, interpolatePuOr)],
      ["rdbu", scheme11$1(scheme$m, interpolateRdBu)],
      ["rdgy", scheme11$1(scheme$l, interpolateRdGy)],
      ["rdylbu", scheme11$1(scheme$k, interpolateRdYlBu)],
      ["rdylgn", scheme11$1(scheme$j, interpolateRdYlGn)],
      ["spectral", scheme11$1(scheme$i, interpolateSpectral)],
      // reversed diverging (for temperature data)
      ["burd", scheme11r$1(scheme$m, interpolateRdBu)],
      ["buylrd", scheme11r$1(scheme$k, interpolateRdYlBu)],
      // sequential (single-hue)
      ["blues", scheme9$1(scheme$5, interpolateBlues)],
      ["greens", scheme9$1(scheme$4, interpolateGreens)],
      ["greys", scheme9$1(scheme$3, interpolateGreys)],
      ["oranges", scheme9$1(scheme, interpolateOranges)],
      ["purples", scheme9$1(scheme$2, interpolatePurples)],
      ["reds", scheme9$1(scheme$1, interpolateReds)],
      // sequential (multi-hue)
      ["turbo", schemei$1(interpolateTurbo)],
      ["viridis", schemei$1(interpolateViridis)],
      ["magma", schemei$1(magma)],
      ["inferno", schemei$1(inferno)],
      ["plasma", schemei$1(plasma)],
      ["cividis", schemei$1(interpolateCividis)],
      ["cubehelix", schemei$1(interpolateCubehelixDefault)],
      ["warm", schemei$1(warm)],
      ["cool", schemei$1(cool)],
      ["bugn", scheme9$1(scheme$h, interpolateBuGn)],
      ["bupu", scheme9$1(scheme$g, interpolateBuPu)],
      ["gnbu", scheme9$1(scheme$f, interpolateGnBu)],
      ["orrd", scheme9$1(scheme$e, interpolateOrRd)],
      ["pubu", scheme9$1(scheme$c, interpolatePuBu)],
      ["pubugn", scheme9$1(scheme$d, interpolatePuBuGn)],
      ["purd", scheme9$1(scheme$b, interpolatePuRd)],
      ["rdpu", scheme9$1(scheme$a, interpolateRdPu)],
      ["ylgn", scheme9$1(scheme$8, interpolateYlGn)],
      ["ylgnbu", scheme9$1(scheme$9, interpolateYlGnBu)],
      ["ylorbr", scheme9$1(scheme$7, interpolateYlOrBr)],
      ["ylorrd", scheme9$1(scheme$6, interpolateYlOrRd)],
      // cyclical
      ["rainbow", schemeicyclical$1(interpolateRainbow)],
      ["sinebow", schemeicyclical$1(interpolateSinebow)]
    ]);
    function scheme9$1(scheme2, interpolate2) {
      return ({ length: n }) => {
        if (n === 1)
          return [scheme2[3][1]];
        if (n === 2)
          return [scheme2[3][1], scheme2[3][2]];
        n = Math.max(3, Math.floor(n));
        return n > 9 ? quantize(interpolate2, n) : scheme2[n];
      };
    }
    function scheme11$1(scheme2, interpolate2) {
      return ({ length: n }) => {
        if (n === 2)
          return [scheme2[3][0], scheme2[3][2]];
        n = Math.max(3, Math.floor(n));
        return n > 11 ? quantize(interpolate2, n) : scheme2[n];
      };
    }
    function scheme11r$1(scheme2, interpolate2) {
      return ({ length: n }) => {
        if (n === 2)
          return [scheme2[3][2], scheme2[3][0]];
        n = Math.max(3, Math.floor(n));
        return n > 11 ? quantize((t) => interpolate2(1 - t), n) : scheme2[n].slice().reverse();
      };
    }
    function schemei$1(interpolate2) {
      return ({ length: n }) => quantize(interpolate2, Math.max(2, Math.floor(n)));
    }
    function schemeicyclical$1(interpolate2) {
      return ({ length: n }) => quantize(interpolate2, Math.floor(n) + 1).slice(0, -1);
    }
    function ordinalScheme$1(scheme2) {
      const s2 = `${scheme2}`.toLowerCase();
      if (!ordinalSchemes$1.has(s2))
        throw new Error(`unknown ordinal scheme: ${s2}`);
      return ordinalSchemes$1.get(s2);
    }
    function ordinalRange$1(scheme2, length2) {
      const s2 = ordinalScheme$1(scheme2);
      const r = typeof s2 === "function" ? s2({ length: length2 }) : s2;
      return r.length !== length2 ? r.slice(0, length2) : r;
    }
    function maybeBooleanRange$1(domain, scheme2 = "greys") {
      const range2 = /* @__PURE__ */ new Set();
      const [f, t] = ordinalRange$1(scheme2, 2);
      for (const value of domain) {
        if (value == null)
          continue;
        if (value === true)
          range2.add(t);
        else if (value === false)
          range2.add(f);
        else
          return;
      }
      return [...range2];
    }
    const quantitativeSchemes$1 = /* @__PURE__ */ new Map([
      // diverging
      ["brbg", interpolateBrBG],
      ["prgn", interpolatePRGn],
      ["piyg", interpolatePiYG],
      ["puor", interpolatePuOr],
      ["rdbu", interpolateRdBu],
      ["rdgy", interpolateRdGy],
      ["rdylbu", interpolateRdYlBu],
      ["rdylgn", interpolateRdYlGn],
      ["spectral", interpolateSpectral],
      // reversed diverging (for temperature data)
      ["burd", (t) => interpolateRdBu(1 - t)],
      ["buylrd", (t) => interpolateRdYlBu(1 - t)],
      // sequential (single-hue)
      ["blues", interpolateBlues],
      ["greens", interpolateGreens],
      ["greys", interpolateGreys],
      ["purples", interpolatePurples],
      ["reds", interpolateReds],
      ["oranges", interpolateOranges],
      // sequential (multi-hue)
      ["turbo", interpolateTurbo],
      ["viridis", interpolateViridis],
      ["magma", magma],
      ["inferno", inferno],
      ["plasma", plasma],
      ["cividis", interpolateCividis],
      ["cubehelix", interpolateCubehelixDefault],
      ["warm", warm],
      ["cool", cool],
      ["bugn", interpolateBuGn],
      ["bupu", interpolateBuPu],
      ["gnbu", interpolateGnBu],
      ["orrd", interpolateOrRd],
      ["pubugn", interpolatePuBuGn],
      ["pubu", interpolatePuBu],
      ["purd", interpolatePuRd],
      ["rdpu", interpolateRdPu],
      ["ylgnbu", interpolateYlGnBu],
      ["ylgn", interpolateYlGn],
      ["ylorbr", interpolateYlOrBr],
      ["ylorrd", interpolateYlOrRd],
      // cyclical
      ["rainbow", interpolateRainbow],
      ["sinebow", interpolateSinebow]
    ]);
    function quantitativeScheme$1(scheme2) {
      const s2 = `${scheme2}`.toLowerCase();
      if (!quantitativeSchemes$1.has(s2))
        throw new Error(`unknown quantitative scheme: ${s2}`);
      return quantitativeSchemes$1.get(s2);
    }
    const divergingSchemes$1 = /* @__PURE__ */ new Set([
      "brbg",
      "prgn",
      "piyg",
      "puor",
      "rdbu",
      "rdgy",
      "rdylbu",
      "rdylgn",
      "spectral",
      "burd",
      "buylrd"
    ]);
    function isDivergingScheme$1(scheme2) {
      return scheme2 != null && divergingSchemes$1.has(`${scheme2}`.toLowerCase());
    }
    const flip$3 = (i) => (t) => i(1 - t);
    const unit$1 = [0, 1];
    const interpolators$1 = /* @__PURE__ */ new Map([
      // numbers
      ["number", interpolateNumber],
      // color spaces
      ["rgb", interpolateRgb],
      ["hsl", interpolateHsl],
      ["hcl", interpolateHcl],
      ["lab", lab]
    ]);
    function maybeInterpolator$1(interpolate2) {
      const i = `${interpolate2}`.toLowerCase();
      if (!interpolators$1.has(i))
        throw new Error(`unknown interpolator: ${i}`);
      return interpolators$1.get(i);
    }
    function createScaleQ$1(key, scale2, channels, {
      type,
      nice: nice2,
      clamp,
      zero: zero2,
      domain = inferAutoDomain$1(key, channels),
      unknown,
      round: round2,
      scheme: scheme2,
      interval: interval2,
      range: range2 = registry$1.get(key) === radius$1 ? inferRadialRange$1(channels, domain) : registry$1.get(key) === length$1 ? inferLengthRange$1(channels, domain) : registry$1.get(key) === opacity$1 ? unit$1 : void 0,
      interpolate: interpolate2 = registry$1.get(key) === color$1 ? scheme2 == null && range2 !== void 0 ? interpolateRgb : quantitativeScheme$1(scheme2 !== void 0 ? scheme2 : type === "cyclical" ? "rainbow" : "turbo") : round2 ? interpolateRound : interpolateNumber,
      reverse: reverse$1
    }) {
      interval2 = maybeRangeInterval$1(interval2, type);
      if (type === "cyclical" || type === "sequential")
        type = "linear";
      reverse$1 = !!reverse$1;
      if (typeof interpolate2 !== "function") {
        interpolate2 = maybeInterpolator$1(interpolate2);
      }
      if (interpolate2.length === 1) {
        if (reverse$1) {
          interpolate2 = flip$3(interpolate2);
          reverse$1 = false;
        }
        if (range2 === void 0) {
          range2 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));
          if (range2.length === 2)
            range2 = unit$1;
        }
        scale2.interpolate((range2 === unit$1 ? constant$1 : interpolatePiecewise$1)(interpolate2));
      } else {
        scale2.interpolate(interpolate2);
      }
      if (zero2) {
        const [min2, max2] = extent(domain);
        if (min2 > 0 || max2 < 0) {
          domain = slice$1(domain);
          if (orderof$1(domain) !== Math.sign(min2))
            domain[domain.length - 1] = 0;
          else
            domain[0] = 0;
        }
      }
      if (reverse$1)
        domain = reverse(domain);
      scale2.domain(domain).unknown(unknown);
      if (nice2)
        scale2.nice(maybeNice$1(nice2, type)), domain = scale2.domain();
      if (range2 !== void 0)
        scale2.range(range2);
      if (clamp)
        scale2.clamp(clamp);
      return { type, domain, range: range2, scale: scale2, interpolate: interpolate2, interval: interval2 };
    }
    function maybeNice$1(nice2, type) {
      return nice2 === true ? void 0 : typeof nice2 === "number" ? nice2 : maybeNiceInterval$1(nice2, type);
    }
    function createScaleLinear$1(key, channels, options) {
      return createScaleQ$1(key, linear(), channels, options);
    }
    function createScaleSqrt$1(key, channels, options) {
      return createScalePow$1(key, channels, { ...options, exponent: 0.5 });
    }
    function createScalePow$1(key, channels, { exponent: exponent2 = 1, ...options }) {
      return createScaleQ$1(key, pow().exponent(exponent2), channels, { ...options, type: "pow" });
    }
    function createScaleLog$1(key, channels, { base = 10, domain = inferLogDomain$1(channels), ...options }) {
      return createScaleQ$1(key, log().base(base), channels, { ...options, domain });
    }
    function createScaleSymlog$1(key, channels, { constant: constant2 = 1, ...options }) {
      return createScaleQ$1(key, symlog().constant(constant2), channels, options);
    }
    function createScaleQuantile$1(key, channels, {
      range: range2,
      quantiles = range2 === void 0 ? 5 : (range2 = [...range2]).length,
      // deprecated; use n instead
      n = quantiles,
      scheme: scheme2 = "rdylbu",
      domain = inferQuantileDomain$1(channels),
      unknown,
      interpolate: interpolate2,
      reverse: reverse2
    }) {
      if (range2 === void 0) {
        range2 = interpolate2 !== void 0 ? quantize(interpolate2, n) : registry$1.get(key) === color$1 ? ordinalRange$1(scheme2, n) : void 0;
      }
      if (domain.length > 0) {
        domain = quantile(domain, range2 === void 0 ? { length: n } : range2).quantiles();
      }
      return createScaleThreshold$1(key, channels, { domain, range: range2, reverse: reverse2, unknown });
    }
    function createScaleQuantize$1(key, channels, {
      range: range2,
      n = range2 === void 0 ? 5 : (range2 = [...range2]).length,
      scheme: scheme2 = "rdylbu",
      domain = inferAutoDomain$1(key, channels),
      unknown,
      interpolate: interpolate2,
      reverse: reverse2
    }) {
      const [min2, max2] = extent(domain);
      let thresholds;
      if (range2 === void 0) {
        thresholds = ticks(min2, max2, n);
        if (thresholds[0] <= min2)
          thresholds.splice(0, 1);
        if (thresholds[thresholds.length - 1] >= max2)
          thresholds.pop();
        n = thresholds.length + 1;
        range2 = interpolate2 !== void 0 ? quantize(interpolate2, n) : registry$1.get(key) === color$1 ? ordinalRange$1(scheme2, n) : void 0;
      } else {
        thresholds = quantize(interpolateNumber(min2, max2), n + 1).slice(1, -1);
        if (min2 instanceof Date)
          thresholds = thresholds.map((x) => new Date(x));
      }
      if (orderof$1(arrayify$1(domain)) < 0)
        thresholds.reverse();
      return createScaleThreshold$1(key, channels, { domain: thresholds, range: range2, reverse: reverse2, unknown });
    }
    function createScaleThreshold$1(key, channels, {
      domain = [0],
      // explicit thresholds in ascending order
      unknown,
      scheme: scheme2 = "rdylbu",
      interpolate: interpolate2,
      range: range2 = interpolate2 !== void 0 ? quantize(interpolate2, domain.length + 1) : registry$1.get(key) === color$1 ? ordinalRange$1(scheme2, domain.length + 1) : void 0,
      reverse: reverse$1
    }) {
      domain = arrayify$1(domain);
      const sign2 = orderof$1(domain);
      if (!isNaN(sign2) && !isOrdered$1(domain, sign2))
        throw new Error(`the ${key} scale has a non-monotonic domain`);
      if (reverse$1)
        range2 = reverse(range2);
      return {
        type: "threshold",
        scale: threshold(sign2 < 0 ? reverse(domain) : domain, range2 === void 0 ? [] : range2).unknown(unknown),
        domain,
        range: range2
      };
    }
    function isOrdered$1(domain, sign2) {
      for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {
        const s2 = descending(d, d = domain[i]);
        if (s2 !== 0 && s2 !== sign2)
          return false;
      }
      return true;
    }
    function createScaleIdentity$1() {
      return { type: "identity", scale: identity$2() };
    }
    function inferDomain$1$1(channels, f = finite$1) {
      return channels.length ? [
        min$6(channels, ({ value }) => value === void 0 ? value : min$6(value, f)),
        max$5(channels, ({ value }) => value === void 0 ? value : max$5(value, f))
      ] : [0, 1];
    }
    function inferAutoDomain$1(key, channels) {
      const type = registry$1.get(key);
      return (type === radius$1 || type === opacity$1 || type === length$1 ? inferZeroDomain$1 : inferDomain$1$1)(channels);
    }
    function inferZeroDomain$1(channels) {
      return [0, channels.length ? max$5(channels, ({ value }) => value === void 0 ? value : max$5(value, finite$1)) : 1];
    }
    function inferRadialRange$1(channels, domain) {
      const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
      if (hint !== void 0)
        return [0, hint.radius];
      const h25 = quantile$1(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile$1(value, 0.25, positive$1));
      const range2 = domain.map((d) => 3 * Math.sqrt(d / h25));
      const k2 = 30 / max$5(range2);
      return k2 < 1 ? range2.map((r) => r * k2) : range2;
    }
    function inferLengthRange$1(channels, domain) {
      const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));
      const range2 = domain.map((d) => 12 * d / h50);
      const k2 = 60 / max$5(range2);
      return k2 < 1 ? range2.map((r) => r * k2) : range2;
    }
    function inferLogDomain$1(channels) {
      for (const { value } of channels) {
        if (value !== void 0) {
          for (let v of value) {
            if (v > 0)
              return inferDomain$1$1(channels, positive$1);
            if (v < 0)
              return inferDomain$1$1(channels, negative$1);
          }
        }
      }
      return [1, 10];
    }
    function inferQuantileDomain$1(channels) {
      const domain = [];
      for (const { value } of channels) {
        if (value === void 0)
          continue;
        for (const v of value)
          domain.push(v);
      }
      return domain;
    }
    function interpolatePiecewise$1(interpolate2) {
      return (i, j) => (t) => interpolate2(i + t * (j - i));
    }
    function createScaleD$1(key, scale2, transform, channels, {
      type,
      nice: nice2,
      clamp,
      domain = inferDomain$1$1(channels),
      unknown,
      pivot = 0,
      scheme: scheme2,
      range: range2,
      symmetric = true,
      interpolate: interpolate2 = registry$1.get(key) === color$1 ? scheme2 == null && range2 !== void 0 ? interpolateRgb : quantitativeScheme$1(scheme2 !== void 0 ? scheme2 : "rdbu") : interpolateNumber,
      reverse: reverse2
    }) {
      pivot = +pivot;
      let [min2, max2] = domain;
      if (descending(min2, max2) < 0)
        [min2, max2] = [max2, min2], reverse2 = !reverse2;
      min2 = Math.min(min2, pivot);
      max2 = Math.max(max2, pivot);
      if (typeof interpolate2 !== "function") {
        interpolate2 = maybeInterpolator$1(interpolate2);
      }
      if (range2 !== void 0) {
        interpolate2 = interpolate2.length === 1 ? interpolatePiecewise$1(interpolate2)(...range2) : piecewise(interpolate2, range2);
      }
      if (reverse2)
        interpolate2 = flip$3(interpolate2);
      if (symmetric) {
        const mid = transform.apply(pivot);
        const mindelta = mid - transform.apply(min2);
        const maxdelta = transform.apply(max2) - mid;
        if (mindelta < maxdelta)
          min2 = transform.invert(mid - maxdelta);
        else if (mindelta > maxdelta)
          max2 = transform.invert(mid + mindelta);
      }
      scale2.domain([min2, pivot, max2]).unknown(unknown).interpolator(interpolate2);
      if (clamp)
        scale2.clamp(clamp);
      if (nice2)
        scale2.nice(nice2);
      return { type, domain: [min2, max2], pivot, interpolate: interpolate2, scale: scale2 };
    }
    function createScaleDiverging$1(key, channels, options) {
      return createScaleD$1(key, diverging(), transformIdentity$1, channels, options);
    }
    function createScaleDivergingSqrt$1(key, channels, options) {
      return createScaleDivergingPow$1(key, channels, { ...options, exponent: 0.5 });
    }
    function createScaleDivergingPow$1(key, channels, { exponent: exponent2 = 1, ...options }) {
      return createScaleD$1(key, divergingPow().exponent(exponent2 = +exponent2), transformPow$1(exponent2), channels, {
        ...options,
        type: "diverging-pow"
      });
    }
    function createScaleDivergingLog$1(key, channels, { base = 10, pivot = 1, domain = inferDomain$1$1(channels, pivot < 0 ? negative$1 : positive$1), ...options }) {
      return createScaleD$1(key, divergingLog().base(base = +base), transformLog$1, channels, {
        domain,
        pivot,
        ...options
      });
    }
    function createScaleDivergingSymlog$1(key, channels, { constant: constant2 = 1, ...options }) {
      return createScaleD$1(
        key,
        divergingSymlog().constant(constant2 = +constant2),
        transformSymlog$1(constant2),
        channels,
        options
      );
    }
    const transformIdentity$1 = {
      apply(x) {
        return x;
      },
      invert(x) {
        return x;
      }
    };
    const transformLog$1 = {
      apply: Math.log,
      invert: Math.exp
    };
    const transformSqrt$1 = {
      apply(x) {
        return Math.sign(x) * Math.sqrt(Math.abs(x));
      },
      invert(x) {
        return Math.sign(x) * (x * x);
      }
    };
    function transformPow$1(exponent2) {
      return exponent2 === 0.5 ? transformSqrt$1 : {
        apply(x) {
          return Math.sign(x) * Math.pow(Math.abs(x), exponent2);
        },
        invert(x) {
          return Math.sign(x) * Math.pow(Math.abs(x), 1 / exponent2);
        }
      };
    }
    function transformSymlog$1(constant2) {
      return {
        apply(x) {
          return Math.sign(x) * Math.log1p(Math.abs(x / constant2));
        },
        invert(x) {
          return Math.sign(x) * Math.expm1(Math.abs(x)) * constant2;
        }
      };
    }
    function createScaleT$1(key, scale2, channels, options) {
      return createScaleQ$1(key, scale2, channels, options);
    }
    function createScaleTime$1(key, channels, options) {
      return createScaleT$1(key, time(), channels, options);
    }
    function createScaleUtc$1(key, channels, options) {
      return createScaleT$1(key, utcTime(), channels, options);
    }
    const ordinalImplicit$1 = Symbol("ordinal");
    function createScaleO$1(key, scale2, channels, { type, interval: interval2, domain, range: range2, reverse: reverse$1, hint }) {
      interval2 = maybeRangeInterval$1(interval2, type);
      if (domain === void 0)
        domain = inferDomain$2(channels, interval2, key);
      if (type === "categorical" || type === ordinalImplicit$1)
        type = "ordinal";
      if (reverse$1)
        domain = reverse(domain);
      scale2.domain(domain);
      if (range2 !== void 0) {
        if (typeof range2 === "function")
          range2 = range2(domain);
        scale2.range(range2);
      }
      return { type, domain, range: range2, scale: scale2, hint, interval: interval2 };
    }
    function createScaleOrdinal$1(key, channels, { type, interval: interval2, domain, range: range2, scheme: scheme2, unknown, ...options }) {
      interval2 = maybeRangeInterval$1(interval2, type);
      if (domain === void 0)
        domain = inferDomain$2(channels, interval2, key);
      let hint;
      if (registry$1.get(key) === symbol$1) {
        hint = inferSymbolHint$1(channels);
        range2 = range2 === void 0 ? inferSymbolRange$1(hint) : map$1(range2, maybeSymbol$1);
      } else if (registry$1.get(key) === color$1) {
        if (range2 === void 0 && (type === "ordinal" || type === ordinalImplicit$1)) {
          range2 = maybeBooleanRange$1(domain, scheme2);
          if (range2 !== void 0)
            scheme2 = void 0;
        }
        if (scheme2 === void 0 && range2 === void 0) {
          scheme2 = type === "ordinal" ? "turbo" : "tableau10";
        }
        if (scheme2 !== void 0) {
          if (range2 !== void 0) {
            const interpolate2 = quantitativeScheme$1(scheme2);
            const t02 = range2[0], d = range2[1] - range2[0];
            range2 = ({ length: n }) => quantize((t) => interpolate2(t02 + d * t), n);
          } else {
            range2 = ordinalScheme$1(scheme2);
          }
        }
      }
      if (unknown === implicit) {
        throw new Error(`implicit unknown on ${key} scale is not supported`);
      }
      return createScaleO$1(key, ordinal().unknown(unknown), channels, { ...options, type, domain, range: range2, hint });
    }
    function createScalePoint$1(key, channels, { align = 0.5, padding = 0.5, ...options }) {
      return maybeRound$1(point().align(align).padding(padding), channels, options, key);
    }
    function createScaleBand$1(key, channels, {
      align = 0.5,
      padding = 0.1,
      paddingInner = padding,
      paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
      ...options
    }) {
      return maybeRound$1(
        band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
        channels,
        options,
        key
      );
    }
    function maybeRound$1(scale2, channels, options, key) {
      let { round: round2 } = options;
      if (round2 !== void 0)
        scale2.round(round2 = !!round2);
      scale2 = createScaleO$1(key, scale2, channels, options);
      scale2.round = round2;
      return scale2;
    }
    function inferDomain$2(channels, interval2, key) {
      const values2 = new InternSet();
      for (const { value, domain } of channels) {
        if (domain !== void 0)
          return domain();
        if (value === void 0)
          continue;
        for (const v of value)
          values2.add(v);
      }
      if (interval2 !== void 0) {
        const [min2, max2] = extent(values2).map(interval2.floor, interval2);
        return interval2.range(min2, interval2.offset(max2));
      }
      if (values2.size > 1e4 && registry$1.get(key) === position$1) {
        throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
      }
      return sort(values2, ascendingDefined$1);
    }
    function inferHint$1(channels, key) {
      let value;
      for (const { hint } of channels) {
        const candidate = hint == null ? void 0 : hint[key];
        if (candidate === void 0)
          continue;
        if (value === void 0)
          value = candidate;
        else if (value !== candidate)
          return;
      }
      return value;
    }
    function inferSymbolHint$1(channels) {
      return {
        fill: inferHint$1(channels, "fill"),
        stroke: inferHint$1(channels, "stroke")
      };
    }
    function inferSymbolRange$1(hint) {
      return isNoneish$1(hint.fill) ? symbolsStroke : symbolsFill;
    }
    function normalizeScale$1(key, scale2, hint) {
      return createScale$1(key, hint === void 0 ? void 0 : [{ hint }], { ...scale2 });
    }
    function createScale$1(key, channels = [], options = {}) {
      const type = inferScaleType$1(key, channels, options);
      if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale$1({ type })) {
        const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
        if (values2.some(isTemporal$1))
          warn$1(
            `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType$1(
              type
            )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType$1(
              type
            )}".`
          );
        else if (values2.some(isTemporalString$1))
          warn$1(
            `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType$1(
              type
            )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType$1(
              type
            )}".`
          );
        else if (values2.some(isNumericString$1))
          warn$1(
            `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType$1(
              type
            )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType$1(
              type
            )}".`
          );
      }
      options.type = type;
      switch (type) {
        case "diverging":
        case "diverging-sqrt":
        case "diverging-pow":
        case "diverging-log":
        case "diverging-symlog":
        case "cyclical":
        case "sequential":
        case "linear":
        case "sqrt":
        case "threshold":
        case "quantile":
        case "pow":
        case "log":
        case "symlog":
          options = coerceType$1(channels, options, coerceNumbers$1);
          break;
        case "identity":
          switch (registry$1.get(key)) {
            case position$1:
              options = coerceType$1(channels, options, coerceNumbers$1);
              break;
            case symbol$1:
              options = coerceType$1(channels, options, coerceSymbols$1);
              break;
          }
          break;
        case "utc":
        case "time":
          options = coerceType$1(channels, options, coerceDates$1);
          break;
      }
      switch (type) {
        case "diverging":
          return createScaleDiverging$1(key, channels, options);
        case "diverging-sqrt":
          return createScaleDivergingSqrt$1(key, channels, options);
        case "diverging-pow":
          return createScaleDivergingPow$1(key, channels, options);
        case "diverging-log":
          return createScaleDivergingLog$1(key, channels, options);
        case "diverging-symlog":
          return createScaleDivergingSymlog$1(key, channels, options);
        case "categorical":
        case "ordinal":
        case ordinalImplicit$1:
          return createScaleOrdinal$1(key, channels, options);
        case "cyclical":
        case "sequential":
        case "linear":
          return createScaleLinear$1(key, channels, options);
        case "sqrt":
          return createScaleSqrt$1(key, channels, options);
        case "threshold":
          return createScaleThreshold$1(key, channels, options);
        case "quantile":
          return createScaleQuantile$1(key, channels, options);
        case "quantize":
          return createScaleQuantize$1(key, channels, options);
        case "pow":
          return createScalePow$1(key, channels, options);
        case "log":
          return createScaleLog$1(key, channels, options);
        case "symlog":
          return createScaleSymlog$1(key, channels, options);
        case "utc":
          return createScaleUtc$1(key, channels, options);
        case "time":
          return createScaleTime$1(key, channels, options);
        case "point":
          return createScalePoint$1(key, channels, options);
        case "band":
          return createScaleBand$1(key, channels, options);
        case "identity":
          return registry$1.get(key) === position$1 ? createScaleIdentity$1() : { type: "identity" };
        case void 0:
          return;
        default:
          throw new Error(`unknown scale type: ${type}`);
      }
    }
    function formatScaleType$1(type) {
      return typeof type === "symbol" ? type.description : type;
    }
    const typeProjection$1 = { toString: () => "projection" };
    function inferScaleType$1(key, channels, { type, domain, range: range2, scheme: scheme2, pivot, projection: projection2 }) {
      if (key === "fx" || key === "fy")
        return "band";
      if ((key === "x" || key === "y") && projection2 != null)
        type = typeProjection$1;
      for (const { type: t } of channels) {
        if (t === void 0)
          continue;
        else if (type === void 0)
          type = t;
        else if (type !== t)
          throw new Error(`scale incompatible with channel: ${type} !== ${t}`);
      }
      if (type === typeProjection$1)
        return;
      if (type !== void 0)
        return type;
      if (domain === void 0 && !channels.some(({ value }) => value !== void 0))
        return;
      const kind = registry$1.get(key);
      if (kind === radius$1)
        return "sqrt";
      if (kind === opacity$1 || kind === length$1)
        return "linear";
      if (kind === symbol$1)
        return "ordinal";
      if ((domain || range2 || []).length > 2)
        return asOrdinalType$1(kind);
      if (domain !== void 0) {
        if (isOrdinal$1(domain))
          return asOrdinalType$1(kind);
        if (isTemporal$1(domain))
          return "utc";
        if (kind === color$1 && (pivot != null || isDivergingScheme$1(scheme2)))
          return "diverging";
        return "linear";
      }
      const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
      if (values2.some(isOrdinal$1))
        return asOrdinalType$1(kind);
      if (values2.some(isTemporal$1))
        return "utc";
      if (kind === color$1 && (pivot != null || isDivergingScheme$1(scheme2)))
        return "diverging";
      return "linear";
    }
    function asOrdinalType$1(kind) {
      switch (kind) {
        case position$1:
          return "point";
        case color$1:
          return ordinalImplicit$1;
        default:
          return "ordinal";
      }
    }
    function isOrdinalScale$1({ type }) {
      return type === "ordinal" || type === "point" || type === "band" || type === ordinalImplicit$1;
    }
    function coerceType$1(channels, { domain, ...options }, coerceValues) {
      for (const c2 of channels) {
        if (c2.value !== void 0) {
          c2.value = coerceValues(c2.value);
        }
      }
      return {
        domain: domain === void 0 ? domain : coerceValues(domain),
        ...options
      };
    }
    function coerceSymbols$1(values2) {
      return map$1(values2, maybeSymbol$1);
    }
    function scale(options = {}) {
      let scale2;
      for (const key in options) {
        if (!registry$1.has(key))
          continue;
        if (!isScaleOptions$1(options[key]))
          continue;
        if (scale2 !== void 0)
          throw new Error("ambiguous scale definition; multiple scales found");
        scale2 = exposeScale(normalizeScale$1(key, options[key]));
      }
      if (scale2 === void 0)
        throw new Error("invalid scale definition; no scale found");
      return scale2;
    }
    function exposeScale({ scale: scale2, type, domain, range: range2, interpolate: interpolate2, interval: interval2, transform, percent, pivot }) {
      if (type === "identity")
        return { type: "identity", apply: (d) => d, invert: (d) => d };
      const unknown = scale2.unknown ? scale2.unknown() : void 0;
      return {
        type,
        domain: slice$1(domain),
        // defensive copy
        ...range2 !== void 0 && { range: slice$1(range2) },
        // defensive copy
        ...transform !== void 0 && { transform },
        ...percent && { percent },
        // only exposed if truthy
        ...unknown !== void 0 && { unknown },
        ...interval2 !== void 0 && { interval: interval2 },
        // quantitative
        ...interpolate2 !== void 0 && { interpolate: interpolate2 },
        ...scale2.clamp && { clamp: scale2.clamp() },
        // diverging (always asymmetric; we never want to apply the symmetric transform twice)
        ...pivot !== void 0 && { pivot, symmetric: false },
        // log, diverging-log
        ...scale2.base && { base: scale2.base() },
        // pow, diverging-pow
        ...scale2.exponent && { exponent: scale2.exponent() },
        // symlog, diverging-symlog
        ...scale2.constant && { constant: scale2.constant() },
        // band, point
        ...scale2.align && { align: scale2.align(), round: scale2.round() },
        ...scale2.padding && (scale2.paddingInner ? { paddingInner: scale2.paddingInner(), paddingOuter: scale2.paddingOuter() } : { padding: scale2.padding() }),
        ...scale2.bandwidth && { bandwidth: scale2.bandwidth(), step: scale2.step() },
        // utilities
        apply: (t) => scale2(t),
        ...scale2.invert && { invert: (t) => scale2.invert(t) }
      };
    }
    function normalizedScale(scaleOptions) {
      try {
        var scaleType = Object.keys(scaleOptions)[0];
        return scale(_defineProperty({}, scaleType, Object.assign(Object.assign({}, scaleOptions[scaleType]), {
          clamp: true
        })));
      } catch (error) {
        return null;
      }
    }
    function scaleStyle(_scale, scaleOptions) {
      var styles = {};
      if (scaleOptions.hasOwnProperty("opacity")) {
        styles.fill = function() {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            scaleOptions.opacity.baseColor || SCALE_BASE_OPACITY_COLOR
          );
        };
        styles["fill-opacity"] = function(d) {
          return _scale === null || _scale === void 0 ? void 0 : _scale.apply(d);
        };
      } else {
        styles.fill = function(d) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            typeof d === "string" && (d === null || d === void 0 ? void 0 : d.startsWith("#")) ? d : _scale === null || _scale === void 0 ? void 0 : _scale.apply(d)
          );
        };
      }
      return styles;
    }
    function applyScaleStyle(elem, _scale, scaleOptions, keyname) {
      Object.entries(scaleStyle(_scale, scaleOptions)).forEach(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), prop = _ref2[0], val = _ref2[1];
        return (
          // eslint-disable-next-line implicit-arrow-linebreak
          elem.style(prop, function(d) {
            return (
              // eslint-disable-next-line implicit-arrow-linebreak
              val(keyname ? d[keyname] : d)
            );
          })
        );
      });
    }
    var Populator = /* @__PURE__ */ function() {
      function Populator2(calendar2) {
        _classCallCheck$2(this, Populator2);
        this.calendar = calendar2;
      }
      _createClass$2(Populator2, [{
        key: "populate",
        value: function populate() {
          var calendar2 = this.calendar;
          var _calendar$options$opt = calendar2.options.options, scale2 = _calendar$options$opt.scale, subDomain = _calendar$options$opt.subDomain;
          var colorScale = normalizedScale(scale2);
          calendar2.calendarPainter.root.selectAll(".ch-domain").selectAll("svg").selectAll("g").data(function(d) {
            return calendar2.domainCollection.get(d) || [];
          }).call(function(element2) {
            applyScaleStyle(element2.select("rect"), colorScale, scale2, "v");
          }).call(function(element2) {
            element2.select("text").attr("style", function(d) {
              var defaultColor = hcl$1(colorScale === null || colorScale === void 0 ? void 0 : colorScale.apply(d.v)).l > 60 ? "#000" : "#fff";
              var color2 = subDomain.color || (d.v ? defaultColor : null);
              if (isFunction(color2)) {
                color2 = color2(d.t, d.v, colorScale === null || colorScale === void 0 ? void 0 : colorScale.apply(d.v));
              }
              if (!color2) {
                return null;
              }
              return "fill: ".concat(color2, ";");
            }).text(function(d, i, nodes) {
              return (
                // eslint-disable-next-line implicit-arrow-linebreak
                calendar2.dateHelper.format(d.t, subDomain.label, d.v, nodes[i])
              );
            });
          }).call(function() {
            calendar2.eventEmitter.emit("fill");
          });
        }
      }]);
      return Populator2;
    }();
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function assocIndexOf(array2, key) {
      var length2 = array2.length;
      while (length2--) {
        if (eq(array2[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice$2 = arrayProto.splice;
    function listCacheDelete(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index == lastIndex) {
        data2.pop();
      } else {
        splice$2.call(data2, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      return index < 0 ? void 0 : data2[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var coreJsData = root$1["__core-js_shared__"];
    var coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$b = objectProto$d.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$2$2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var Map$1 = getNative(root$1, "Map");
    var Map$2 = Map$1;
    var nativeCreate = getNative(Object, "create");
    var nativeCreate$1 = nativeCreate;
    function hashClear() {
      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$c = Object.prototype;
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate$1) {
        var result = data2[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$a.call(data2, key) ? data2[key] : void 0;
    }
    var objectProto$b = Object.prototype;
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$9.call(data2, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$2 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map2, key) {
      var data2 = map2.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    function Stack(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var defineProperty$a = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var defineProperty$1$2 = defineProperty$a;
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty$1$2) {
        defineProperty$1$2(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    function assignMergeValue(object2, key, value) {
      if (value !== void 0 && !eq(object2[key], value) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    var baseFor = createBaseFor();
    var baseFor$1 = baseFor;
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
      buffer.copy(result);
      return result;
    }
    var Uint8Array$1 = root$1.Uint8Array;
    var Uint8Array$2 = Uint8Array$1;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array2) {
      var index = -1, length2 = source.length;
      array2 || (array2 = Array(length2));
      while (++index < length2) {
        array2[index] = source[index];
      }
      return array2;
    }
    var objectCreate$2 = Object.create;
    var baseCreate = function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject$2$2(proto)) {
          return {};
        }
        if (objectCreate$2) {
          return objectCreate$2(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    var baseCreate$1 = baseCreate;
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var getPrototype$1 = getPrototype;
    var objectProto$a = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
      return value === proto;
    }
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$2;
    }
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    var isArguments$1 = isArguments;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function stubFalse() {
      return false;
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var Buffer2 = moduleExports$1 ? root$1.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var isBuffer$1 = isBuffer;
    var objectTag$3 = "[object Object]";
    var funcProto = Function.prototype, objectProto$8 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype$1(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$7.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$1 = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$1] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal$1.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeUtil$1 = nodeUtil;
    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var isTypedArray$1 = isTypedArray;
    function safeGet(object2, key) {
      if (key === "constructor" && typeof object2[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object2[key];
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$6.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index = -1, length2 = props.length;
      while (++index < length2) {
        var key = props[index];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var MAX_SAFE_INTEGER$3 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER$3 : length2;
      return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray$3(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject$2$2(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$4.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object2, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray$3(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray$3(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
          newValue = objValue;
          if (isArguments$1(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject$2$2(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object2, key, newValue);
    }
    function baseMerge(object2, source, srcIndex, customizer, stack) {
      if (object2 === source) {
        return;
      }
      baseFor$1(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject$2$2(srcValue)) {
          baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object2, key, newValue);
        }
      }, keysIn);
    }
    function identity$1(value) {
      return value;
    }
    function apply$1$2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    var nativeMax = Math.max;
    function overRest(func, start2, transform) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array(length2);
        while (++index < length2) {
          array2[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = transform(array2);
        return apply$1$2(func, this, otherArgs);
      };
    }
    function constant$2(value) {
      return function() {
        return value;
      };
    }
    var baseSetToString = !defineProperty$1$2 ? identity$1 : function(func, string2) {
      return defineProperty$1$2(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant$2(string2),
        "writable": true
      });
    };
    var baseSetToString$1 = baseSetToString;
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    var setToString = shortOut(baseSetToString$1);
    var setToString$1 = setToString;
    function baseRest(func, start2) {
      return setToString$1(overRest(func, start2, identity$1), func + "");
    }
    function isIterateeCall(value, index, object2) {
      if (!isObject$2$2(object2)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
        return eq(object2[index], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object2, sources) {
        var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length2 < 3 ? void 0 : customizer;
          length2 = 1;
        }
        object2 = Object(object2);
        while (++index < length2) {
          var source = sources[index];
          if (source) {
            assigner(object2, source, index, customizer);
          }
        }
        return object2;
      });
    }
    var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
      baseMerge(object2, source, srcIndex, customizer);
    });
    var mergeWith$1 = mergeWith;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values2) {
      var index = -1, length2 = values2 == null ? 0 : values2.length;
      this.__data__ = new MapCache();
      while (++index < length2) {
        this.add(values2[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array2, predicate) {
      var index = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index < length2) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index < arrLength) {
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen2) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen2.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$1:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object2), new Uint8Array$2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag$1:
          return object2 == other + "";
        case mapTag$1:
          var convert = mapToArray;
        case setTag$1:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag$1:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function arrayPush(array2, values2) {
      var index = -1, length2 = values2.length, offset2 = array2.length;
      while (++index < length2) {
        array2[offset2 + index] = values2[index];
      }
      return array2;
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$3(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function arrayFilter(array2, predicate) {
      var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$4 = Object.prototype;
    var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol2) {
        return propertyIsEnumerable.call(object2, symbol2);
      });
    };
    var getSymbols$1 = getSymbols;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeKeys$1 = nativeKeys;
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys$1(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$3.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys$2(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys$2, getSymbols$1);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1;
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    var DataView$1 = getNative(root$1, "DataView");
    var DataView$1$1 = DataView$1;
    var Promise$1$2 = getNative(root$1, "Promise");
    var Promise$2 = Promise$1$2;
    var Set$1 = getNative(root$1, "Set");
    var Set$2 = Set$1;
    var WeakMap$4 = getNative(root$1, "WeakMap");
    var WeakMap$1$2 = WeakMap$4;
    var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView$1$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1$2);
    var getTag = baseGetTag;
    if (DataView$1$1 && getTag(new DataView$1$1(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$1$2 && getTag(new WeakMap$1$2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    var getTag$1 = getTag;
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1$1 = objectProto$1.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray$3(object2), othIsArr = isArray$3(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$1(object2)) {
        if (!isBuffer$1(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray$1(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty$1$1.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1$1.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    var objectProto = Object.prototype;
    var hasOwnProperty$e = objectProto.hasOwnProperty;
    function baseHas(object2, key) {
      return object2 != null && hasOwnProperty$e.call(object2, key);
    }
    var symbolTag = "[object Symbol]";
    function isSymbol$4(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray$3(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$4(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match2, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
      });
      return result;
    });
    var stringToPath$1 = stringToPath;
    function arrayMap(array2, iteratee) {
      var index = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index < length2) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    var INFINITY$1 = 1 / 0;
    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$3(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol$4(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    function toString$3$1(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object2) {
      if (isArray$3(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath$1(toString$3$1(value));
    }
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol$4(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function hasPath(object2, path, hasFunc) {
      path = castPath(path, object2);
      var index = -1, length2 = path.length, result = false;
      while (++index < length2) {
        var key = toKey(path[index]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index != length2) {
        return result;
      }
      length2 = object2 == null ? 0 : object2.length;
      return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray$3(object2) || isArguments$1(object2));
    }
    function has$2(object2, path) {
      return object2 != null && hasPath(object2, path, baseHas);
    }
    function baseGet(object2, path) {
      path = castPath(path, object2);
      var index = 0, length2 = path.length;
      while (object2 != null && index < length2) {
        object2 = object2[toKey(path[index++])];
      }
      return index && index == length2 ? object2 : void 0;
    }
    function get$2(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    function baseSet(object2, path, value, customizer) {
      if (!isObject$2$2(object2)) {
        return object2;
      }
      path = castPath(path, object2);
      var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object2;
      while (nested != null && ++index < length2) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object2;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject$2$2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object2;
    }
    function set$3(object2, path, value) {
      return object2 == null ? object2 : baseSet(object2, path, value);
    }
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray$3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    var OptionsPreProcessors = {
      range: function range2(value) {
        return Math.max(+value, 1);
      },
      "date.highlight": function dateHighlight(args) {
        return castArray(args);
      },
      "subDomain.label": function subDomainLabel(value) {
        return (
          // eslint-disable-next-line
          isString(value) && value !== "" || isFunction(value) ? value : null
        );
      }
    };
    var Options = /* @__PURE__ */ function() {
      function Options2() {
        var processors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OptionsPreProcessors;
        _classCallCheck$2(this, Options2);
        this.preProcessors = processors;
        this.options = {
          // selector string of the container to append the graph to
          // Accept any string value accepted by document.querySelector or CSS3
          // or an Element object
          itemSelector: OPTIONS_DEFAULT_ITEM_SELECTOR,
          // Number of domain to display on the graph
          range: OPTIONS_DEFAULT_RANGE,
          domain: {
            type: OPTIONS_DEFAULT_DOMAIN_TYPE,
            // Space between each domain, in pixel
            gutter: 4,
            padding: [0, 0, 0, 0],
            // Whether to enable dynamic domain size
            // The width/height on a domain depends on the number of
            // subDomains items count
            dynamicDimension: true,
            // Whether to show most recent date first
            sort: "asc",
            label: {
              // Formatting of the domain label
              // @default: undefined, will use the formatting
              // according to domain type
              // Accept any string accepted by dayjs.format()
              // or a function
              //
              // Refer to https://day.js.org/docs/en/display/format
              // for list of accepted string tokens used by dayjs.format()
              text: void 0,
              // valid: top, right, bottom, left
              position: "bottom",
              // Valid are the direct svg values: start, middle, end
              textAlign: "middle",
              // By default, there is no margin/padding around the label
              offset: {
                x: 0,
                y: 0
              },
              rotate: null,
              // Used only on vertical orientation
              width: 100,
              // Used only on horizontal orientation
              height: 25
            }
          },
          subDomain: {
            type: OPTIONS_DEFAULT_SUBDOMAIN_TYPE,
            // Width of each subDomain cell, in pixel
            width: OPTIONS_DEFAULT_SUBDOMAIN_WIDTH,
            // Height of each subDomain cell, in pixel
            height: OPTIONS_DEFAULT_SUBDOMAIN_HEIGHT,
            // Space between each subDomain cell, in pixel
            gutter: OPTIONS_DEFAULT_SUBDOMAIN_GUTTER,
            // Radius of each subDomain cell, in pixel
            radius: OPTIONS_DEFAULT_SUBDOMAIN_RADIUS,
            // Formatting of the text inside each subDomain cell
            // @default: null, no text
            // Accept any string accepted by dayjs.format()
            // or a function
            //
            // Refer to https://day.js.org/docs/en/display/format
            // for list of accepted string tokens used by dayjs.format()
            label: null,
            color: void 0,
            sort: "asc"
          },
          date: {
            // Start date of the graph
            // @default now
            start: /* @__PURE__ */ new Date(),
            min: void 0,
            max: void 0,
            // List of dates to highlight
            // Valid values:
            // - []: don't highlight anything
            // - an array of Date objects: highlight the specified dates
            highlight: [],
            locale: OPTIONS_DEFAULT_LOCALE,
            timezone: void 0
          },
          // Calendar orientation
          // false: display domains side by side
          // true : display domains one under the other
          verticalOrientation: false,
          data: {
            // Data source
            // URL, where to fetch the original datas
            source: "",
            // Data type
            // Default: json
            type: "json",
            requestInit: {},
            // keyname of the time property
            x: "",
            // keyname of the value property
            y: "",
            // Grouping function of the values
            groupY: "sum",
            defaultValue: null
          },
          scale: void 0,
          // Animation duration, in ms
          animationDuration: OPTIONS_DEFAULT_ANIMATION_DURATION,
          // Theme mode: dark/light
          theme: OPTIONS_DEFAULT_THEME,
          // Internally used options, do not edit not set
          x: {
            domainHorizontalLabelWidth: 0,
            domainVerticalLabelHeight: 0
          }
        };
      }
      _createClass$2(Options2, [{
        key: "set",
        value: function set$12(key, value) {
          if (!has$2(this.options, key) || isEqual(get$2(this.options, key), value)) {
            return false;
          }
          set$3(this.options, key, has$2(this.preProcessors, key) ? get$2(this.preProcessors, key)(value) : value);
          return true;
        }
      }, {
        key: "init",
        value: function init2(opts) {
          var _this = this;
          this.options = Object.assign({}, mergeWith$1(this.options, opts, function(_, srcValue) {
            return Array.isArray(srcValue) ? srcValue : void 0;
          }));
          var options = this.options;
          Object.keys(this.preProcessors).forEach(function(key) {
            set$3(options, key, get$2(_this.preProcessors, key)(get$2(options, key)));
          });
          if (typeof options.scale === "undefined") {
            this.initScale();
          }
          options.x.domainVerticalLabelHeight = options.domain.label.height;
          if (options.domain.label.position === "top" || options.domain.label.position === "bottom") {
            options.x.domainHorizontalLabelWidth = 0;
          } else {
            options.x.domainVerticalLabelHeight = 0;
            options.x.domainHorizontalLabelWidth = options.domain.label.width;
          }
          if (options.domain.label.text === null || options.domain.label.text === "") {
            options.x.domainVerticalLabelHeight = 0;
            options.x.domainHorizontalLabelWidth = 0;
          }
        }
      }, {
        key: "initScale",
        value: function initScale() {
          this.options.scale = {
            color: {
              scheme: SCALE_BASE_COLOR_SCHEME,
              type: SCALE_BASE_COLOR_TYPE,
              domain: SCALE_BASE_COLOR_DOMAIN
            }
          };
        }
      }]);
      return Options2;
    }();
    var anObject$2$2 = anObject$f;
    var regexpFlags$1 = function() {
      var that = anObject$2$2(this);
      var result = "";
      if (that.hasIndices)
        result += "d";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.unicodeSets)
        result += "v";
      if (that.sticky)
        result += "y";
      return result;
    };
    var fails$4$2 = fails$u;
    var global$3$2 = global$n;
    var $RegExp$2 = global$3$2.RegExp;
    var UNSUPPORTED_Y$1 = fails$4$2(function() {
      var re2 = $RegExp$2("a", "y");
      re2.lastIndex = 2;
      return re2.exec("abcd") !== null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y$1 || fails$4$2(function() {
      return !$RegExp$2("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y$1 || fails$4$2(function() {
      var re2 = $RegExp$2("^r", "gy");
      re2.lastIndex = 2;
      return re2.exec("str") !== null;
    });
    var regexpStickyHelpers = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y: UNSUPPORTED_Y$1
    };
    var fails$3$2 = fails$u;
    var global$2$2 = global$n;
    var $RegExp$1 = global$2$2.RegExp;
    var regexpUnsupportedDotAll = fails$3$2(function() {
      var re2 = $RegExp$1(".", "s");
      return !(re2.dotAll && re2.test("\n") && re2.flags === "s");
    });
    var fails$2$2 = fails$u;
    var global$1$2 = global$n;
    var $RegExp = global$1$2.RegExp;
    var regexpUnsupportedNcg = fails$2$2(function() {
      var re2 = $RegExp("(?<a>b)", "g");
      return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
    });
    var call$2$2 = functionCall$2;
    var uncurryThis$5$2 = functionUncurryThis$2;
    var toString$2$2 = toString$9;
    var regexpFlags = regexpFlags$1;
    var stickyHelpers = regexpStickyHelpers;
    var shared$5 = sharedExports$2;
    var create$4 = objectCreate$1;
    var getInternalState$4 = internalState$2.get;
    var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
    var UNSUPPORTED_NCG = regexpUnsupportedNcg;
    var nativeReplace = shared$5("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt$2 = uncurryThis$5$2("".charAt);
    var indexOf$2 = uncurryThis$5$2("".indexOf);
    var replace$1$1 = uncurryThis$5$2("".replace);
    var stringSlice$2$1 = uncurryThis$5$2("".slice);
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call$2$2(nativeExec, re1, "a");
      call$2$2(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec2(string2) {
        var re2 = this;
        var state = getInternalState$4(re2);
        var str = toString$2$2(string2);
        var raw = state.raw;
        var result, reCopy, lastIndex, match2, i, object2, group;
        if (raw) {
          raw.lastIndex = re2.lastIndex;
          result = call$2$2(patchedExec, raw, str);
          re2.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re2.sticky;
        var flags = call$2$2(regexpFlags, re2);
        var source = re2.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace$1$1(flags, "y", "");
          if (indexOf$2(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice$2$1(str, re2.lastIndex);
          if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt$2(str, re2.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG)
          lastIndex = re2.lastIndex;
        match2 = call$2$2(nativeExec, sticky ? reCopy : re2, strCopy);
        if (sticky) {
          if (match2) {
            match2.input = stringSlice$2$1(match2.input, charsAdded);
            match2[0] = stringSlice$2$1(match2[0], charsAdded);
            match2.index = re2.lastIndex;
            re2.lastIndex += match2[0].length;
          } else
            re2.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match2) {
          re2.lastIndex = re2.global ? match2.index + match2[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match2 && match2.length > 1) {
          call$2$2(nativeReplace, match2[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === void 0)
                match2[i] = void 0;
            }
          });
        }
        if (match2 && groups) {
          match2.groups = object2 = create$4(null);
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object2[group[0]] = match2[group[1]];
          }
        }
        return match2;
      };
    }
    var regexpExec$2 = patchedExec;
    var $$1$2 = _export$2;
    var exec$2 = regexpExec$2;
    $$1$2({ target: "RegExp", proto: true, forced: /./.exec !== exec$2 }, {
      exec: exec$2
    });
    var uncurryThis$4$2 = functionUncurryThisClause$2;
    var defineBuiltIn$a = defineBuiltIn$9$1;
    var regexpExec$1 = regexpExec$2;
    var fails$1$2 = fails$u;
    var wellKnownSymbol$1$2 = wellKnownSymbol$m;
    var createNonEnumerableProperty$7 = createNonEnumerableProperty$6;
    var SPECIES$7 = wellKnownSymbol$1$2("species");
    var RegExpPrototype = RegExp.prototype;
    var fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {
      var SYMBOL = wellKnownSymbol$1$2(KEY);
      var DELEGATES_TO_SYMBOL = !fails$1$2(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O) !== 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1$2(function() {
        var execCalled = false;
        var re2 = /a/;
        if (KEY === "split") {
          re2 = {};
          re2.constructor = {};
          re2.constructor[SPECIES$7] = function() {
            return re2;
          };
          re2.flags = "";
          re2[SYMBOL] = /./[SYMBOL];
        }
        re2.exec = function() {
          execCalled = true;
          return null;
        };
        re2[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {
        var uncurriedNativeRegExpMethod = uncurryThis$4$2(/./[SYMBOL]);
        var methods = exec2(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var uncurriedNativeMethod = uncurryThis$4$2(nativeMethod);
          var $exec = regexp.exec;
          if ($exec === regexpExec$1 || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
            }
            return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn$a(String.prototype, KEY, methods[0]);
        defineBuiltIn$a(RegExpPrototype, SYMBOL, methods[1]);
      }
      if (SHAM)
        createNonEnumerableProperty$7(RegExpPrototype[SYMBOL], "sham", true);
    };
    var charAt$1$1 = stringMultibyte$1.charAt;
    var advanceStringIndex$1 = function(S, index, unicode) {
      return index + (unicode ? charAt$1$1(S, index).length : 1);
    };
    var uncurryThis$3$2 = functionUncurryThis$2;
    var toObject$b = toObject$a;
    var floor$3 = Math.floor;
    var charAt$5 = uncurryThis$3$2("".charAt);
    var replace$4 = uncurryThis$3$2("".replace);
    var stringSlice$1$2 = uncurryThis$3$2("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    var getSubstitution$1 = function(matched, str, position2, captures, namedCaptures, replacement2) {
      var tailPos = position2 + matched.length;
      var m = captures.length;
      var symbols2 = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject$b(namedCaptures);
        symbols2 = SUBSTITUTION_SYMBOLS;
      }
      return replace$4(replacement2, symbols2, function(match2, ch) {
        var capture;
        switch (charAt$5(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice$1$2(str, 0, position2);
          case "'":
            return stringSlice$1$2(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice$1$2(ch, 1, -1)];
            break;
          default:
            var n = +ch;
            if (n === 0)
              return match2;
            if (n > m) {
              var f = floor$3(n / 10);
              if (f === 0)
                return match2;
              if (f <= m)
                return captures[f - 1] === void 0 ? charAt$5(ch, 1) : captures[f - 1] + charAt$5(ch, 1);
              return match2;
            }
            capture = captures[n - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
    var call$1$2 = functionCall$2;
    var anObject$1$2 = anObject$f;
    var isCallable$1$2 = isCallable$o;
    var classof$c = classofRaw$2$2;
    var regexpExec = regexpExec$2;
    var $TypeError$h = TypeError;
    var regexpExecAbstract = function(R, S) {
      var exec2 = R.exec;
      if (isCallable$1$2(exec2)) {
        var result = call$1$2(exec2, R, S);
        if (result !== null)
          anObject$1$2(result);
        return result;
      }
      if (classof$c(R) === "RegExp")
        return call$1$2(regexpExec, R, S);
      throw new $TypeError$h("RegExp#exec called on incompatible receiver");
    };
    var apply$4 = functionApply$2;
    var call$k = functionCall$2;
    var uncurryThis$2$2 = functionUncurryThis$2;
    var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
    var fails$v = fails$u;
    var anObject$g = anObject$f;
    var isCallable$p = isCallable$o;
    var isNullOrUndefined$9 = isNullOrUndefined$8;
    var toIntegerOrInfinity$5 = toIntegerOrInfinity$4$1;
    var toLength$4 = toLength$3;
    var toString$1$2 = toString$9;
    var requireObjectCoercible$1$2 = requireObjectCoercible$7;
    var advanceStringIndex = advanceStringIndex$1;
    var getMethod$5 = getMethod$4$1;
    var getSubstitution = getSubstitution$1;
    var regExpExec$1$1 = regexpExecAbstract;
    var wellKnownSymbol$n = wellKnownSymbol$m;
    var REPLACE = wellKnownSymbol$n("replace");
    var max$4 = Math.max;
    var min$4 = Math.min;
    var concat$3 = uncurryThis$2$2([].concat);
    var push$5 = uncurryThis$2$2([].push);
    var stringIndexOf$1 = uncurryThis$2$2("".indexOf);
    var stringSlice$7 = uncurryThis$2$2("".slice);
    var maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    var REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$v(function() {
      var re2 = /./;
      re2.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re2, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace2, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace2(searchValue, replaceValue) {
          var O = requireObjectCoercible$1$2(this);
          var replacer = isNullOrUndefined$9(searchValue) ? void 0 : getMethod$5(searchValue, REPLACE);
          return replacer ? call$k(replacer, searchValue, O, replaceValue) : call$k(nativeReplace2, toString$1$2(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string2, replaceValue) {
          var rx = anObject$g(this);
          var S = toString$1$2(string2);
          if (typeof replaceValue == "string" && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace2, rx, S, replaceValue);
            if (res.done)
              return res.value;
          }
          var functionalReplace = isCallable$p(replaceValue);
          if (!functionalReplace)
            replaceValue = toString$1$2(replaceValue);
          var global2 = rx.global;
          var fullUnicode;
          if (global2) {
            fullUnicode = rx.unicode;
            rx.lastIndex = 0;
          }
          var results = [];
          var result;
          while (true) {
            result = regExpExec$1$1(rx, S);
            if (result === null)
              break;
            push$5(results, result);
            if (!global2)
              break;
            var matchStr = toString$1$2(result[0]);
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S, toLength$4(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i = 0; i < results.length; i++) {
            result = results[i];
            var matched = toString$1$2(result[0]);
            var position2 = max$4(min$4(toIntegerOrInfinity$5(result.index), S.length), 0);
            var captures = [];
            var replacement2;
            for (var j = 1; j < result.length; j++)
              push$5(captures, maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat$3([matched], captures, position2, S);
              if (namedCaptures !== void 0)
                push$5(replacerArgs, namedCaptures);
              replacement2 = toString$1$2(apply$4(replaceValue, void 0, replacerArgs));
            } else {
              replacement2 = getSubstitution(matched, S, position2, captures, namedCaptures, replaceValue);
            }
            if (position2 >= nextSourcePosition) {
              accumulatedResult += stringSlice$7(S, nextSourcePosition, position2) + replacement2;
              nextSourcePosition = position2 + matched.length;
            }
          }
          return accumulatedResult + stringSlice$7(S, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
    var _DataFetcher_instances, _DataFetcher_fetch;
    var DataFetcher = /* @__PURE__ */ function() {
      function DataFetcher2(calendar2) {
        _classCallCheck$2(this, DataFetcher2);
        _DataFetcher_instances.add(this);
        this.calendar = calendar2;
      }
      _createClass$2(DataFetcher2, [{
        key: "getDatas",
        value: function getDatas(source, startTimestamp, endTimestamp) {
          return __awaiter(this, void 0, void 0, /* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
            var d;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(typeof source === "string" && source.length > 0)) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return", __classPrivateFieldGet$1(this, _DataFetcher_instances, "m", _DataFetcher_fetch).call(this, source, startTimestamp, endTimestamp));
                  case 2:
                    d = [];
                    if (Array.isArray(source)) {
                      d = source;
                    }
                    return _context.abrupt("return", new Promise(function(resolve) {
                      resolve(d);
                    }));
                  case 5:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
        }
      }, {
        key: "parseURI",
        value: function parseURI(str, startTimestamp, endTimestamp) {
          var _this = this;
          var newUri = str.replace(/\{\{start=(.*?)\}\}/g, function(_, format2) {
            return (
              // eslint-disable-next-line implicit-arrow-linebreak
              _this.calendar.dateHelper.date(startTimestamp).format(format2)
            );
          });
          newUri = newUri.replace(/\{\{end=(.*?)\}\}/g, function(_, format2) {
            return (
              // eslint-disable-next-line implicit-arrow-linebreak
              _this.calendar.dateHelper.date(endTimestamp).format(format2)
            );
          });
          return newUri;
        }
      }]);
      return DataFetcher2;
    }();
    _DataFetcher_instances = /* @__PURE__ */ new WeakSet(), _DataFetcher_fetch = function _DataFetcher_fetch2(source, startTimestamp, endTimestamp) {
      var _this$calendar$option = this.calendar.options.options.data, type = _this$calendar$option.type, requestInit = _this$calendar$option.requestInit;
      var url = this.parseURI(source, startTimestamp, endTimestamp);
      switch (type) {
        case "json":
          return json(url, requestInit);
        case "csv":
          return csv(url, requestInit);
        case "tsv":
          return dsv("	", url, requestInit);
        case "txt":
          return text(url, requestInit);
        default:
          return new Promise(function(resolve) {
            resolve([]);
          });
      }
    };
    var DESCRIPTORS$e = descriptors$2;
    var FUNCTION_NAME_EXISTS$2 = functionName$2.EXISTS;
    var uncurryThis$1$2 = functionUncurryThis$2;
    var defineBuiltInAccessor$4 = defineBuiltInAccessor$3$1;
    var FunctionPrototype$5 = Function.prototype;
    var functionToString$3 = uncurryThis$1$2(FunctionPrototype$5.toString);
    var nameRE$2 = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
    var regExpExec$2 = uncurryThis$1$2(nameRE$2.exec);
    var NAME$2 = "name";
    if (DESCRIPTORS$e && !FUNCTION_NAME_EXISTS$2) {
      defineBuiltInAccessor$4(FunctionPrototype$5, NAME$2, {
        configurable: true,
        get: function() {
          try {
            return regExpExec$2(nameRE$2, functionToString$3(this))[1];
          } catch (error) {
            return "";
          }
        }
      });
    }
    var dayjs_min = { exports: {} };
    (function(module2, exports2) {
      !function(t, e) {
        module2.exports = e();
      }(commonjsGlobal$2, function() {
        var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u = "hour", a2 = "day", o = "week", c2 = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t4) {
          var e3 = ["th", "st", "nd", "rd"], n2 = t4 % 100;
          return "[" + t4 + (e3[(n2 - 20) % 10] || e3[n2] || e3[0]) + "]";
        } }, m = function(t4, e3, n2) {
          var r2 = String(t4);
          return !r2 || r2.length >= e3 ? t4 : "" + Array(e3 + 1 - r2.length).join(n2) + t4;
        }, v = { s: m, z: function(t4) {
          var e3 = -t4.utcOffset(), n2 = Math.abs(e3), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e3 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
        }, m: function t4(e3, n2) {
          if (e3.date() < n2.date())
            return -t4(n2, e3);
          var r2 = 12 * (n2.year() - e3.year()) + (n2.month() - e3.month()), i2 = e3.clone().add(r2, c2), s3 = n2 - i2 < 0, u2 = e3.clone().add(r2 + (s3 ? -1 : 1), c2);
          return +(-(r2 + (n2 - i2) / (s3 ? i2 - u2 : u2 - i2)) || 0);
        }, a: function(t4) {
          return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
        }, p: function(t4) {
          return { M: c2, y: h, w: o, d: a2, D: d, h: u, m: s2, s: i, ms: r, Q: f }[t4] || String(t4 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t4) {
          return void 0 === t4;
        } }, g = "en", D2 = {};
        D2[g] = M2;
        var p = "$isDayjsObject", S = function(t4) {
          return t4 instanceof _ || !(!t4 || !t4[p]);
        }, w = function t4(e3, n2, r2) {
          var i2;
          if (!e3)
            return g;
          if ("string" == typeof e3) {
            var s3 = e3.toLowerCase();
            D2[s3] && (i2 = s3), n2 && (D2[s3] = n2, i2 = s3);
            var u2 = e3.split("-");
            if (!i2 && u2.length > 1)
              return t4(u2[0]);
          } else {
            var a3 = e3.name;
            D2[a3] = e3, i2 = a3;
          }
          return !r2 && i2 && (g = i2), i2 || !r2 && g;
        }, O = function(t4, e3) {
          if (S(t4))
            return t4.clone();
          var n2 = "object" == typeof e3 ? e3 : {};
          return n2.date = t4, n2.args = arguments, new _(n2);
        }, b = v;
        b.l = w, b.i = S, b.w = function(t4, e3) {
          return O(t4, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _ = function() {
          function M3(t4) {
            this.$L = w(t4.locale, null, true), this.parse(t4), this.$x = this.$x || t4.x || {}, this[p] = true;
          }
          var m2 = M3.prototype;
          return m2.parse = function(t4) {
            this.$d = function(t5) {
              var e3 = t5.date, n2 = t5.utc;
              if (null === e3)
                return /* @__PURE__ */ new Date(NaN);
              if (b.u(e3))
                return /* @__PURE__ */ new Date();
              if (e3 instanceof Date)
                return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r2 = e3.match($2);
                if (r2) {
                  var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
                  return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
                }
              }
              return new Date(e3);
            }(t4), this.init();
          }, m2.init = function() {
            var t4 = this.$d;
            this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
          }, m2.$utils = function() {
            return b;
          }, m2.isValid = function() {
            return !(this.$d.toString() === l);
          }, m2.isSame = function(t4, e3) {
            var n2 = O(t4);
            return this.startOf(e3) <= n2 && n2 <= this.endOf(e3);
          }, m2.isAfter = function(t4, e3) {
            return O(t4) < this.startOf(e3);
          }, m2.isBefore = function(t4, e3) {
            return this.endOf(e3) < O(t4);
          }, m2.$g = function(t4, e3, n2) {
            return b.u(t4) ? this[e3] : this.set(n2, t4);
          }, m2.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m2.valueOf = function() {
            return this.$d.getTime();
          }, m2.startOf = function(t4, e3) {
            var n2 = this, r2 = !!b.u(e3) || e3, f2 = b.p(t4), l2 = function(t5, e4) {
              var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e4, t5) : new Date(n2.$y, e4, t5), n2);
              return r2 ? i2 : i2.endOf(a2);
            }, $3 = function(t5, e4) {
              return b.w(n2.toDate()[t5].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n2);
            }, y2 = this.$W, M4 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
            switch (f2) {
              case h:
                return r2 ? l2(1, 0) : l2(31, 11);
              case c2:
                return r2 ? l2(1, M4) : l2(0, M4 + 1);
              case o:
                var g2 = this.$locale().weekStart || 0, D3 = (y2 < g2 ? y2 + 7 : y2) - g2;
                return l2(r2 ? m3 - D3 : m3 + (6 - D3), M4);
              case a2:
              case d:
                return $3(v2 + "Hours", 0);
              case u:
                return $3(v2 + "Minutes", 1);
              case s2:
                return $3(v2 + "Seconds", 2);
              case i:
                return $3(v2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m2.endOf = function(t4) {
            return this.startOf(t4, false);
          }, m2.$set = function(t4, e3) {
            var n2, o2 = b.p(t4), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a2] = f2 + "Date", n2[d] = f2 + "Date", n2[c2] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s2] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $3 = o2 === a2 ? this.$D + (e3 - this.$W) : e3;
            if (o2 === c2 || o2 === h) {
              var y2 = this.clone().set(d, 1);
              y2.$d[l2]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
            } else
              l2 && this.$d[l2]($3);
            return this.init(), this;
          }, m2.set = function(t4, e3) {
            return this.clone().$set(t4, e3);
          }, m2.get = function(t4) {
            return this[b.p(t4)]();
          }, m2.add = function(r2, f2) {
            var d2, l2 = this;
            r2 = Number(r2);
            var $3 = b.p(f2), y2 = function(t4) {
              var e3 = O(l2);
              return b.w(e3.date(e3.date() + Math.round(t4 * r2)), l2);
            };
            if ($3 === c2)
              return this.set(c2, this.$M + r2);
            if ($3 === h)
              return this.set(h, this.$y + r2);
            if ($3 === a2)
              return y2(1);
            if ($3 === o)
              return y2(7);
            var M4 = (d2 = {}, d2[s2] = e, d2[u] = n, d2[i] = t, d2)[$3] || 1, m3 = this.$d.getTime() + r2 * M4;
            return b.w(m3, this);
          }, m2.subtract = function(t4, e3) {
            return this.add(-1 * t4, e3);
          }, m2.format = function(t4) {
            var e3 = this, n2 = this.$locale();
            if (!this.isValid())
              return n2.invalidDate || l;
            var r2 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s3 = this.$H, u2 = this.$m, a3 = this.$M, o2 = n2.weekdays, c3 = n2.months, f2 = n2.meridiem, h2 = function(t5, n3, i3, s4) {
              return t5 && (t5[n3] || t5(e3, r2)) || i3[n3].slice(0, s4);
            }, d2 = function(t5) {
              return b.s(s3 % 12 || 12, t5, "0");
            }, $3 = f2 || function(t5, e4, n3) {
              var r3 = t5 < 12 ? "AM" : "PM";
              return n3 ? r3.toLowerCase() : r3;
            };
            return r2.replace(y, function(t5, r3) {
              return r3 || function(t6) {
                switch (t6) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return b.s(e3.$y, 4, "0");
                  case "M":
                    return a3 + 1;
                  case "MM":
                    return b.s(a3 + 1, 2, "0");
                  case "MMM":
                    return h2(n2.monthsShort, a3, c3, 3);
                  case "MMMM":
                    return h2(c3, a3);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return b.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h2(n2.weekdaysMin, e3.$W, o2, 2);
                  case "ddd":
                    return h2(n2.weekdaysShort, e3.$W, o2, 3);
                  case "dddd":
                    return o2[e3.$W];
                  case "H":
                    return String(s3);
                  case "HH":
                    return b.s(s3, 2, "0");
                  case "h":
                    return d2(1);
                  case "hh":
                    return d2(2);
                  case "a":
                    return $3(s3, u2, true);
                  case "A":
                    return $3(s3, u2, false);
                  case "m":
                    return String(u2);
                  case "mm":
                    return b.s(u2, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return b.s(e3.$s, 2, "0");
                  case "SSS":
                    return b.s(e3.$ms, 3, "0");
                  case "Z":
                    return i2;
                }
                return null;
              }(t5) || i2.replace(":", "");
            });
          }, m2.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m2.diff = function(r2, d2, l2) {
            var $3, y2 = this, M4 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D3 = function() {
              return b.m(y2, m3);
            };
            switch (M4) {
              case h:
                $3 = D3() / 12;
                break;
              case c2:
                $3 = D3();
                break;
              case f:
                $3 = D3() / 3;
                break;
              case o:
                $3 = (g2 - v2) / 6048e5;
                break;
              case a2:
                $3 = (g2 - v2) / 864e5;
                break;
              case u:
                $3 = g2 / n;
                break;
              case s2:
                $3 = g2 / e;
                break;
              case i:
                $3 = g2 / t;
                break;
              default:
                $3 = g2;
            }
            return l2 ? $3 : b.a($3);
          }, m2.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m2.$locale = function() {
            return D2[this.$L];
          }, m2.locale = function(t4, e3) {
            if (!t4)
              return this.$L;
            var n2 = this.clone(), r2 = w(t4, e3, true);
            return r2 && (n2.$L = r2), n2;
          }, m2.clone = function() {
            return b.w(this.$d, this);
          }, m2.toDate = function() {
            return new Date(this.valueOf());
          }, m2.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m2.toISOString = function() {
            return this.$d.toISOString();
          }, m2.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), k2 = _.prototype;
        return O.prototype = k2, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u], ["$W", a2], ["$M", c2], ["$y", h], ["$D", d]].forEach(function(t4) {
          k2[t4[1]] = function(e3) {
            return this.$g(e3, t4[0], t4[1]);
          };
        }), O.extend = function(t4, e3) {
          return t4.$i || (t4(e3, _, O), t4.$i = true), O;
        }, O.locale = w, O.isDayjs = S, O.unix = function(t4) {
          return O(1e3 * t4);
        }, O.en = D2[g], O.Ls = D2, O.p = {}, O;
      });
    })(dayjs_min);
    var dayjs_minExports = dayjs_min.exports;
    var dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
    var weekOfYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal$2, function() {
        var e = "week", t = "year";
        return function(i, n, r) {
          var f = n.prototype;
          f.week = function(i2) {
            if (void 0 === i2 && (i2 = null), null !== i2)
              return this.add(7 * (i2 - this.week()), "day");
            var n2 = this.$locale().yearStart || 1;
            if (11 === this.month() && this.date() > 25) {
              var f2 = r(this).startOf(t).add(1, t).date(n2), s2 = r(this).endOf(e);
              if (f2.isBefore(s2))
                return 1;
            }
            var a2 = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o = this.diff(a2, e, true);
            return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
          }, f.weeks = function(e3) {
            return void 0 === e3 && (e3 = null), this.week(e3);
          };
        };
      });
    })(weekOfYear$1);
    var weekOfYearExports = weekOfYear$1.exports;
    var weekOfYear = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
    var dayOfYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal$2, function() {
        return function(e, t, n) {
          t.prototype.dayOfYear = function(e3) {
            var t4 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
            return null == e3 ? t4 : this.add(e3 - t4, "day");
          };
        };
      });
    })(dayOfYear$1);
    var dayOfYearExports = dayOfYear$1.exports;
    var dayOfYear = /* @__PURE__ */ getDefaultExportFromCjs(dayOfYearExports);
    var weekday$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal$2, function() {
        return function(e, t) {
          t.prototype.weekday = function(e3) {
            var t4 = this.$locale().weekStart || 0, i = this.$W, n = (i < t4 ? i + 7 : i) - t4;
            return this.$utils().u(e3) ? n : this.subtract(n, "day").add(e3, "day");
          };
        };
      });
    })(weekday$1);
    var weekdayExports = weekday$1.exports;
    var weekday = /* @__PURE__ */ getDefaultExportFromCjs(weekdayExports);
    var minMax$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, n) {
        module2.exports = n();
      }(commonjsGlobal$2, function() {
        return function(e, n, t) {
          var i = function(e3, n2) {
            if (!n2 || !n2.length || 1 === n2.length && !n2[0] || 1 === n2.length && Array.isArray(n2[0]) && !n2[0].length)
              return null;
            var t4;
            1 === n2.length && n2[0].length > 0 && (n2 = n2[0]);
            t4 = (n2 = n2.filter(function(e4) {
              return e4;
            }))[0];
            for (var i2 = 1; i2 < n2.length; i2 += 1)
              n2[i2].isValid() && !n2[i2][e3](t4) || (t4 = n2[i2]);
            return t4;
          };
          t.max = function() {
            var e3 = [].slice.call(arguments, 0);
            return i("isAfter", e3);
          }, t.min = function() {
            var e3 = [].slice.call(arguments, 0);
            return i("isBefore", e3);
          };
        };
      });
    })(minMax$1);
    var minMaxExports = minMax$1.exports;
    var minMax = /* @__PURE__ */ getDefaultExportFromCjs(minMaxExports);
    var isoWeeksInYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, n) {
        module2.exports = n();
      }(commonjsGlobal$2, function() {
        return function(e, n) {
          n.prototype.isoWeeksInYear = function() {
            var e3 = this.isLeapYear(), n2 = this.endOf("y").day();
            return 4 === n2 || e3 && 5 === n2 ? 53 : 52;
          };
        };
      });
    })(isoWeeksInYear$1);
    var isoWeeksInYearExports = isoWeeksInYear$1.exports;
    var isoWeeksInYear = /* @__PURE__ */ getDefaultExportFromCjs(isoWeeksInYearExports);
    var isoWeek$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal$2, function() {
        var e = "day";
        return function(t, i, s2) {
          var a2 = function(t4) {
            return t4.add(4 - t4.isoWeekday(), e);
          }, d = i.prototype;
          d.isoWeekYear = function() {
            return a2(this).year();
          }, d.isoWeek = function(t4) {
            if (!this.$utils().u(t4))
              return this.add(7 * (t4 - this.isoWeek()), e);
            var i2, d2, n2, o, r = a2(this), u = (i2 = this.isoWeekYear(), d2 = this.$u, n2 = (d2 ? s2.utc : s2)().year(i2).startOf("year"), o = 4 - n2.isoWeekday(), n2.isoWeekday() > 4 && (o += 7), n2.add(o, e));
            return r.diff(u, "week") + 1;
          }, d.isoWeekday = function(e3) {
            return this.$utils().u(e3) ? this.day() || 7 : this.day(this.day() % 7 ? e3 : e3 - 7);
          };
          var n = d.startOf;
          d.startOf = function(e3, t4) {
            var i2 = this.$utils(), s3 = !!i2.u(t4) || t4;
            return "isoweek" === i2.p(e3) ? s3 ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : n.bind(this)(e3, t4);
          };
        };
      });
    })(isoWeek$1);
    var isoWeekExports = isoWeek$1.exports;
    var isoWeek = /* @__PURE__ */ getDefaultExportFromCjs(isoWeekExports);
    var isLeapYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal$2, function() {
        return function(e, t) {
          t.prototype.isLeapYear = function() {
            return this.$y % 4 == 0 && this.$y % 100 != 0 || this.$y % 400 == 0;
          };
        };
      });
    })(isLeapYear$1);
    var isLeapYearExports = isLeapYear$1.exports;
    var isLeapYear = /* @__PURE__ */ getDefaultExportFromCjs(isLeapYearExports);
    var advancedFormat$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal$2, function() {
        return function(e, t) {
          var r = t.prototype, n = r.format;
          r.format = function(e3) {
            var t4 = this, r2 = this.$locale();
            if (!this.isValid())
              return n.bind(this)(e3);
            var s2 = this.$utils(), a2 = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
              switch (e4) {
                case "Q":
                  return Math.ceil((t4.$M + 1) / 3);
                case "Do":
                  return r2.ordinal(t4.$D);
                case "gggg":
                  return t4.weekYear();
                case "GGGG":
                  return t4.isoWeekYear();
                case "wo":
                  return r2.ordinal(t4.week(), "W");
                case "w":
                case "ww":
                  return s2.s(t4.week(), "w" === e4 ? 1 : 2, "0");
                case "W":
                case "WW":
                  return s2.s(t4.isoWeek(), "W" === e4 ? 1 : 2, "0");
                case "k":
                case "kk":
                  return s2.s(String(0 === t4.$H ? 24 : t4.$H), "k" === e4 ? 1 : 2, "0");
                case "X":
                  return Math.floor(t4.$d.getTime() / 1e3);
                case "x":
                  return t4.$d.getTime();
                case "z":
                  return "[" + t4.offsetName() + "]";
                case "zzz":
                  return "[" + t4.offsetName("long") + "]";
                default:
                  return e4;
              }
            });
            return n.bind(this)(a2);
          };
        };
      });
    })(advancedFormat$1);
    var advancedFormatExports = advancedFormat$1.exports;
    var advancedFormat = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
    var utc$1 = { exports: {} };
    (function(module2, exports2) {
      !function(t, i) {
        module2.exports = i();
      }(commonjsGlobal$2, function() {
        var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
        return function(s2, f, n) {
          var u = f.prototype;
          n.utc = function(t4) {
            var i2 = { date: t4, utc: true, args: arguments };
            return new f(i2);
          }, u.utc = function(i2) {
            var e3 = n(this.toDate(), { locale: this.$L, utc: true });
            return i2 ? e3.add(this.utcOffset(), t) : e3;
          }, u.local = function() {
            return n(this.toDate(), { locale: this.$L, utc: false });
          };
          var o = u.parse;
          u.parse = function(t4) {
            t4.utc && (this.$u = true), this.$utils().u(t4.$offset) || (this.$offset = t4.$offset), o.call(this, t4);
          };
          var r = u.init;
          u.init = function() {
            if (this.$u) {
              var t4 = this.$d;
              this.$y = t4.getUTCFullYear(), this.$M = t4.getUTCMonth(), this.$D = t4.getUTCDate(), this.$W = t4.getUTCDay(), this.$H = t4.getUTCHours(), this.$m = t4.getUTCMinutes(), this.$s = t4.getUTCSeconds(), this.$ms = t4.getUTCMilliseconds();
            } else
              r.call(this);
          };
          var a2 = u.utcOffset;
          u.utcOffset = function(s3, f2) {
            var n2 = this.$utils().u;
            if (n2(s3))
              return this.$u ? 0 : n2(this.$offset) ? a2.call(this) : this.$offset;
            if ("string" == typeof s3 && (s3 = function(t4) {
              void 0 === t4 && (t4 = "");
              var s4 = t4.match(i);
              if (!s4)
                return null;
              var f3 = ("" + s4[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
              return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
            }(s3), null === s3))
              return this;
            var u2 = Math.abs(s3) <= 16 ? 60 * s3 : s3, o2 = this;
            if (f2)
              return o2.$offset = u2, o2.$u = 0 === s3, o2;
            if (0 !== s3) {
              var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
              (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
            } else
              o2 = this.utc();
            return o2;
          };
          var h = u.format;
          u.format = function(t4) {
            var i2 = t4 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
            return h.call(this, i2);
          }, u.valueOf = function() {
            var t4 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
            return this.$d.valueOf() - 6e4 * t4;
          }, u.isUTC = function() {
            return !!this.$u;
          }, u.toISOString = function() {
            return this.toDate().toISOString();
          }, u.toString = function() {
            return this.toDate().toUTCString();
          };
          var l = u.toDate;
          u.toDate = function(t4) {
            return "s" === t4 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
          };
          var c2 = u.diff;
          u.diff = function(t4, i2, e3) {
            if (t4 && this.$u === t4.$u)
              return c2.call(this, t4, i2, e3);
            var s3 = this.local(), f2 = n(t4).local();
            return c2.call(s3, f2, i2, e3);
          };
        };
      });
    })(utc$1);
    var utcExports = utc$1.exports;
    var utc = /* @__PURE__ */ getDefaultExportFromCjs(utcExports);
    var timezone$1 = { exports: {} };
    (function(module2, exports2) {
      !function(t, e) {
        module2.exports = e();
      }(commonjsGlobal$2, function() {
        var t = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e = {};
        return function(n, i, o) {
          var r, a2 = function(t4, n2, i2) {
            void 0 === i2 && (i2 = {});
            var o2 = new Date(t4), r2 = function(t5, n3) {
              void 0 === n3 && (n3 = {});
              var i3 = n3.timeZoneName || "short", o3 = t5 + "|" + i3, r3 = e[o3];
              return r3 || (r3 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t5, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3 }), e[o3] = r3), r3;
            }(n2, i2);
            return r2.formatToParts(o2);
          }, u = function(e3, n2) {
            for (var i2 = a2(e3, n2), r2 = [], u2 = 0; u2 < i2.length; u2 += 1) {
              var f2 = i2[u2], s3 = f2.type, m = f2.value, c2 = t[s3];
              c2 >= 0 && (r2[c2] = parseInt(m, 10));
            }
            var d = r2[3], l = 24 === d ? 0 : d, h = r2[0] + "-" + r2[1] + "-" + r2[2] + " " + l + ":" + r2[4] + ":" + r2[5] + ":000", v = +e3;
            return (o.utc(h).valueOf() - (v -= v % 1e3)) / 6e4;
          }, f = i.prototype;
          f.tz = function(t4, e3) {
            void 0 === t4 && (t4 = r);
            var n2 = this.utcOffset(), i2 = this.toDate(), a3 = i2.toLocaleString("en-US", { timeZone: t4 }), u2 = Math.round((i2 - new Date(a3)) / 1e3 / 60), f2 = o(a3, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(15 * -Math.round(i2.getTimezoneOffset() / 15) - u2, true);
            if (e3) {
              var s3 = f2.utcOffset();
              f2 = f2.add(n2 - s3, "minute");
            }
            return f2.$x.$timezone = t4, f2;
          }, f.offsetName = function(t4) {
            var e3 = this.$x.$timezone || o.tz.guess(), n2 = a2(this.valueOf(), e3, { timeZoneName: t4 }).find(function(t5) {
              return "timezonename" === t5.type.toLowerCase();
            });
            return n2 && n2.value;
          };
          var s2 = f.startOf;
          f.startOf = function(t4, e3) {
            if (!this.$x || !this.$x.$timezone)
              return s2.call(this, t4, e3);
            var n2 = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
            return s2.call(n2, t4, e3).tz(this.$x.$timezone, true);
          }, o.tz = function(t4, e3, n2) {
            var i2 = n2 && e3, a3 = n2 || e3 || r, f2 = u(+o(), a3);
            if ("string" != typeof t4)
              return o(t4).tz(a3);
            var s3 = function(t5, e4, n3) {
              var i3 = t5 - 60 * e4 * 1e3, o2 = u(i3, n3);
              if (e4 === o2)
                return [i3, e4];
              var r2 = u(i3 -= 60 * (o2 - e4) * 1e3, n3);
              return o2 === r2 ? [i3, o2] : [t5 - 60 * Math.min(o2, r2) * 1e3, Math.max(o2, r2)];
            }(o.utc(t4, i2).valueOf(), f2, a3), m = s3[0], c2 = s3[1], d = o(m).utcOffset(c2);
            return d.$x.$timezone = a3, d;
          }, o.tz.guess = function() {
            return Intl.DateTimeFormat().resolvedOptions().timeZone;
          }, o.tz.setDefault = function(t4) {
            r = t4;
          };
        };
      });
    })(timezone$1);
    var timezoneExports = timezone$1.exports;
    var timezone = /* @__PURE__ */ getDefaultExportFromCjs(timezoneExports);
    var localeData$1 = { exports: {} };
    (function(module2, exports2) {
      !function(n, e) {
        module2.exports = e();
      }(commonjsGlobal$2, function() {
        return function(n, e, t) {
          var r = e.prototype, o = function(n2) {
            return n2 && (n2.indexOf ? n2 : n2.s);
          }, u = function(n2, e3, t4, r2, u2) {
            var i2 = n2.name ? n2 : n2.$locale(), a3 = o(i2[e3]), s3 = o(i2[t4]), f = a3 || s3.map(function(n3) {
              return n3.slice(0, r2);
            });
            if (!u2)
              return f;
            var d = i2.weekStart;
            return f.map(function(n3, e4) {
              return f[(e4 + (d || 0)) % 7];
            });
          }, i = function() {
            return t.Ls[t.locale()];
          }, a2 = function(n2, e3) {
            return n2.formats[e3] || function(n3) {
              return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e4, t4) {
                return e4 || t4.slice(1);
              });
            }(n2.formats[e3.toUpperCase()]);
          }, s2 = function() {
            var n2 = this;
            return { months: function(e3) {
              return e3 ? e3.format("MMMM") : u(n2, "months");
            }, monthsShort: function(e3) {
              return e3 ? e3.format("MMM") : u(n2, "monthsShort", "months", 3);
            }, firstDayOfWeek: function() {
              return n2.$locale().weekStart || 0;
            }, weekdays: function(e3) {
              return e3 ? e3.format("dddd") : u(n2, "weekdays");
            }, weekdaysMin: function(e3) {
              return e3 ? e3.format("dd") : u(n2, "weekdaysMin", "weekdays", 2);
            }, weekdaysShort: function(e3) {
              return e3 ? e3.format("ddd") : u(n2, "weekdaysShort", "weekdays", 3);
            }, longDateFormat: function(e3) {
              return a2(n2.$locale(), e3);
            }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
          };
          r.localeData = function() {
            return s2.bind(this)();
          }, t.localeData = function() {
            var n2 = i();
            return { firstDayOfWeek: function() {
              return n2.weekStart || 0;
            }, weekdays: function() {
              return t.weekdays();
            }, weekdaysShort: function() {
              return t.weekdaysShort();
            }, weekdaysMin: function() {
              return t.weekdaysMin();
            }, months: function() {
              return t.months();
            }, monthsShort: function() {
              return t.monthsShort();
            }, longDateFormat: function(e3) {
              return a2(n2, e3);
            }, meridiem: n2.meridiem, ordinal: n2.ordinal };
          }, t.months = function() {
            return u(i(), "months");
          }, t.monthsShort = function() {
            return u(i(), "monthsShort", "months", 3);
          }, t.weekdays = function(n2) {
            return u(i(), "weekdays", null, null, n2);
          }, t.weekdaysShort = function(n2) {
            return u(i(), "weekdaysShort", "weekdays", 3, n2);
          }, t.weekdaysMin = function(n2) {
            return u(i(), "weekdaysMin", "weekdays", 2, n2);
          };
        };
      });
    })(localeData$1);
    var localeDataExports = localeData$1.exports;
    var localeData = /* @__PURE__ */ getDefaultExportFromCjs(localeDataExports);
    var localizedFormat$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal$2, function() {
        var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
        return function(t, o, n) {
          var r = o.prototype, i = r.format;
          n.en.formats = e, r.format = function(t4) {
            void 0 === t4 && (t4 = "YYYY-MM-DDTHH:mm:ssZ");
            var o2 = this.$locale().formats, n2 = function(t5, o3) {
              return t5.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t6, n3, r2) {
                var i2 = r2 && r2.toUpperCase();
                return n3 || o3[r2] || e[r2] || o3[i2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t7, o4) {
                  return t7 || o4.slice(1);
                });
              });
            }(t4, void 0 === o2 ? {} : o2);
            return i.call(this, n2);
          };
        };
      });
    })(localizedFormat$1);
    var localizedFormatExports = localizedFormat$1.exports;
    var localizedFormat = /* @__PURE__ */ getDefaultExportFromCjs(localizedFormatExports);
    var updateLocale$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, n) {
        module2.exports = n();
      }(commonjsGlobal$2, function() {
        return function(e, n, t) {
          t.updateLocale = function(e3, n2) {
            var o = t.Ls[e3];
            if (o)
              return (n2 ? Object.keys(n2) : []).forEach(function(e4) {
                o[e4] = n2[e4];
              }), o;
          };
        };
      });
    })(updateLocale$1);
    var updateLocaleExports = updateLocale$1.exports;
    var updateLocale = /* @__PURE__ */ getDefaultExportFromCjs(updateLocaleExports);
    dayjs.extend(weekOfYear);
    dayjs.extend(isoWeeksInYear);
    dayjs.extend(isoWeek);
    dayjs.extend(isLeapYear);
    dayjs.extend(dayOfYear);
    dayjs.extend(weekday);
    dayjs.extend(minMax);
    dayjs.extend(advancedFormat);
    dayjs.extend(utc);
    dayjs.extend(timezone);
    dayjs.extend(localeData);
    dayjs.extend(localizedFormat);
    dayjs.extend(updateLocale);
    var DEFAULT_LOCALE = "en";
    var DateHelper = /* @__PURE__ */ function() {
      function DateHelper2() {
        _classCallCheck$2(this, DateHelper2);
        var _a;
        this.locale = DEFAULT_LOCALE;
        this.timezone = dayjs.tz.guess();
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") {
          (_a = window).dayjs || (_a.dayjs = dayjs);
        }
      }
      _createClass$2(DateHelper2, [{
        key: "setup",
        value: function setup(_ref) {
          var options = _ref.options;
          return __awaiter(this, void 0, void 0, /* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
            var userLocale, locale2;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    this.timezone = options.date.timezone || dayjs.tz.guess();
                    userLocale = options.date.locale;
                    if (!(typeof userLocale === "string" && userLocale !== DEFAULT_LOCALE)) {
                      _context.next = 17;
                      break;
                    }
                    if (!((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object")) {
                      _context.next = 12;
                      break;
                    }
                    _context.t0 = window["dayjs_locale_".concat(userLocale)];
                    if (_context.t0) {
                      _context.next = 9;
                      break;
                    }
                    _context.next = 8;
                    return this.loadBrowserLocale(userLocale);
                  case 8:
                    _context.t0 = _context.sent;
                  case 9:
                    locale2 = _context.t0;
                    _context.next = 15;
                    break;
                  case 12:
                    _context.next = 14;
                    return this.loadNodeLocale(userLocale);
                  case 14:
                    locale2 = _context.sent;
                  case 15:
                    dayjs.locale(userLocale);
                    this.locale = locale2;
                  case 17:
                    if (_typeof(userLocale) === "object") {
                      if (userLocale.hasOwnProperty("name")) {
                        dayjs.locale(userLocale.name, userLocale);
                        this.locale = userLocale;
                      } else {
                        this.locale = dayjs.updateLocale(DEFAULT_LOCALE, userLocale);
                      }
                    }
                  case 18:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
        }
        // eslint-disable-next-line class-methods-use-this
      }, {
        key: "extend",
        value: function extend2(dayjsPlugin) {
          return dayjs.extend(dayjsPlugin);
        }
        /**
         * Return the week number, relative to its month
         *
         * @param  {number|Date} d Date or timestamp in milliseconds
         * @returns {number} The week number, relative to the month [0-5]
         */
      }, {
        key: "getMonthWeekNumber",
        value: function getMonthWeekNumber(d) {
          var dayjsDate = this.date(d);
          var date2 = dayjsDate.startOf("day");
          var endOfWeek = dayjsDate.startOf("month").endOf("week");
          if (date2 <= endOfWeek) {
            return 1;
          }
          return Math.ceil(date2.diff(endOfWeek, "weeks", true)) + 1;
        }
        /**
         * Return the number of weeks in the given month
         *
         * As there is no fixed standard to specify which month a partial week should
         * belongs to, the ISO week date standard is used, where:
         * - the first week of the month should have at least 4 days
         *
         *  @see https://en.wikipedia.org/wiki/ISO_week_date
         *
         * @param  {Timestamp | dayjs.Dayjs} d Datejs object or timestamp
         * @return {number}         The number of weeks
         */
      }, {
        key: "getWeeksCountInMonth",
        value: function getWeeksCountInMonth(d) {
          var pivotDate = this.date(d);
          return this.getLastWeekOfMonth(pivotDate).diff(this.getFirstWeekOfMonth(pivotDate), "week") + 1;
        }
        /**
         * Return the start of the first week of the month
         *
         * @see getWeeksCountInMonth() about standard warning
         * @return {dayjs.Dayjs} A dayjs object representing the start of the
         * first week
         */
      }, {
        key: "getFirstWeekOfMonth",
        value: function getFirstWeekOfMonth(d) {
          var startOfMonth = this.date(d).startOf("month");
          var startOfFirstWeek = startOfMonth.startOf("week");
          if (startOfMonth.weekday() > 4) {
            startOfFirstWeek = startOfFirstWeek.add(1, "week");
          }
          return startOfFirstWeek;
        }
        /**
         * Return the end of the last week of the month
         *
         * @see getWeeksCountInMonth() about standard warning
         * @return {dayjs.Dayjs} A dayjs object representing the end of the last week
         */
      }, {
        key: "getLastWeekOfMonth",
        value: function getLastWeekOfMonth(d) {
          var endOfMonth = this.date(d).endOf("month");
          var endOfLastWeek = endOfMonth.endOf("week");
          if (endOfMonth.weekday() < 4) {
            endOfLastWeek = endOfLastWeek.subtract(1, "week");
          }
          return endOfLastWeek;
        }
      }, {
        key: "date",
        value: function date2() {
          var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Date();
          if (dayjs.isDayjs(d)) {
            return d;
          }
          return dayjs(d).tz(this.timezone).utcOffset(0).locale(this.locale);
        }
      }, {
        key: "format",
        value: function format2(timestamp, formatter) {
          if (typeof formatter === "function") {
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return formatter.apply(void 0, [timestamp].concat(args));
          }
          if (typeof formatter === "string") {
            return this.date(timestamp).format(formatter);
          }
          return null;
        }
        /**
         * Return an array of time interval
         *
         * @param  {number|Date} date A random date included in the wanted interval
         * @param  {number|Date} range Length of the wanted interval, or a stop date.
         * @param  {boolean} range Whether the end date should be excluded
         *                         from the result
         * @returns {Array<number>} Array of unix timestamp, in milliseconds
         */
      }, {
        key: "intervals",
        value: function intervals(interval2, date2, range2) {
          var excludeEnd = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
          var start2 = this.date(date2);
          var end2;
          if (typeof range2 === "number") {
            end2 = start2.add(range2, interval2);
          } else if (dayjs.isDayjs(range2)) {
            end2 = range2;
          } else {
            end2 = this.date(range2);
          }
          start2 = start2.startOf(interval2);
          end2 = end2.startOf(interval2);
          var pivot = dayjs.min(start2, end2);
          end2 = dayjs.max(start2, end2);
          var result = [];
          if (!excludeEnd) {
            end2 = end2.add(1, "second");
          }
          do {
            result.push(+pivot);
            pivot = pivot.add(1, interval2);
          } while (pivot < end2);
          return result;
        }
        // this function will work cross-browser for loading scripts asynchronously
        // eslint-disable-next-line class-methods-use-this
      }, {
        key: "loadBrowserLocale",
        value: function loadBrowserLocale(userLocale) {
          return new Promise(function(resolve, reject) {
            var s2 = document.createElement("script");
            s2.type = "text/javascript";
            s2.async = true;
            s2.src = "https://cdn.jsdelivr.net/npm/dayjs@1/locale/".concat(userLocale, ".js");
            s2.onerror = function(err) {
              reject(err);
            };
            s2.onload = function() {
              resolve(window["dayjs_locale_".concat(userLocale)]);
            };
            document.head.appendChild(s2);
          });
        }
        // eslint-disable-next-line class-methods-use-this
      }, {
        key: "loadNodeLocale",
        value: function loadNodeLocale(userLocale) {
          return __vitePreload(() => import("dayjs/locale/".concat(userLocale, ".js")), true ? [] : void 0);
        }
      }]);
      return DateHelper2;
    }();
    var $$q = _export$2;
    var uncurryThis$v = functionUncurryThis$2;
    var notARegExp = notARegexp;
    var requireObjectCoercible$8 = requireObjectCoercible$7;
    var toString$d = toString$9;
    var correctIsRegExpLogic = correctIsRegexpLogic;
    var stringIndexOf = uncurryThis$v("".indexOf);
    $$q({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf(
          toString$d(requireObjectCoercible$8(this)),
          toString$d(notARegExp(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
    var ALLOWED_DATA_TYPES = ["json", "csv", "tsv", "txt"];
    function validate(templateCollection, _ref) {
      var domain = _ref.domain, subDomain = _ref.subDomain, data2 = _ref.data;
      var domainType = domain.type;
      var subDomainType = subDomain.type;
      if (!templateCollection.has(domainType)) {
        throw new Error("'".concat(domainType, "' is not a valid domain type'"));
      }
      if (!templateCollection.has(subDomainType)) {
        throw new Error("'".concat(subDomainType, "' is not a valid subDomain type'"));
      }
      if (data2.type && !ALLOWED_DATA_TYPES.includes(data2.type)) {
        throw new Error("The data type '".concat(data2.type, "' is not valid data type"));
      }
      if (!(templateCollection.get(subDomainType).allowedDomainType || []).includes(domainType)) {
        throw new Error("The subDomain.type '".concat(subDomainType, "' can not be used together ") + "with the domain type ".concat(domainType));
      }
      return true;
    }
    var collection$4 = collection$3;
    var collectionStrong = collectionStrong$2;
    collection$4("Set", function(init2) {
      return function Set2() {
        return init2(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionStrong);
    function createPlugin(Creator, calendar2) {
      return new Creator(calendar2);
    }
    function extractPluginName(PluginClass, options) {
      return "".concat(new PluginClass().name).concat((options === null || options === void 0 ? void 0 : options.key) || "");
    }
    var PluginManager = /* @__PURE__ */ function() {
      function PluginManager2(calendar2) {
        _classCallCheck$2(this, PluginManager2);
        this.calendar = calendar2;
        this.settings = /* @__PURE__ */ new Map();
        this.plugins = /* @__PURE__ */ new Map();
        this.pendingPaint = /* @__PURE__ */ new Set();
      }
      _createClass$2(PluginManager2, [{
        key: "add",
        value: function add(plugins) {
          var _this = this;
          plugins.forEach(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), PluginClass = _ref2[0], pluginOptions = _ref2[1];
            var name = extractPluginName(PluginClass, pluginOptions);
            var existingPlugin = _this.plugins.get(name);
            if (existingPlugin && _this.settings.get(name) && isEqual(_this.settings.get(name).options, pluginOptions)) {
              return;
            }
            _this.settings.set(name, {
              options: pluginOptions,
              dirty: true
            });
            if (!_this.plugins.has(name)) {
              _this.plugins.set(name, createPlugin(PluginClass, _this.calendar));
            }
            _this.pendingPaint.add(_this.plugins.get(name));
          });
        }
      }, {
        key: "setupAll",
        value: function setupAll() {
          var _this2 = this;
          this.plugins.forEach(function(pluginInstance, name) {
            var settings = _this2.settings.get(name);
            if (typeof settings !== "undefined") {
              if (settings.dirty) {
                pluginInstance.setup(settings.options);
                settings.dirty = false;
                _this2.settings.set(name, settings);
              }
            }
          });
        }
      }, {
        key: "paintAll",
        value: function paintAll() {
          return Array.from(this.pendingPaint.values()).map(function(p) {
            return p.paint();
          });
        }
      }, {
        key: "destroyAll",
        value: function destroyAll() {
          return this.allPlugins().map(function(p) {
            return p.destroy();
          });
        }
      }, {
        key: "getFromPosition",
        value: function getFromPosition(position2) {
          return this.allPlugins().filter(function(plugin) {
            var _a;
            return ((_a = plugin.options) === null || _a === void 0 ? void 0 : _a.position) === position2;
          });
        }
      }, {
        key: "getHeightFromPosition",
        value: function getHeightFromPosition(position2) {
          return this.getFromPosition(position2).map(function(d) {
            return d.options.dimensions.height;
          }).reduce(function(a2, b) {
            return a2 + b;
          }, 0);
        }
      }, {
        key: "getWidthFromPosition",
        value: function getWidthFromPosition(position2) {
          return this.getFromPosition(position2).map(function(d) {
            return d.options.dimensions.width;
          }).reduce(function(a2, b) {
            return a2 + b;
          }, 0);
        }
      }, {
        key: "allPlugins",
        value: function allPlugins() {
          return Array.from(this.plugins.values());
        }
      }]);
      return PluginManager2;
    }();
    var VERSION = "4.2.4";
    var minuteTemplate = function minuteTemplate2(DateHelper2) {
      var COLUMNS_COUNT = 10;
      var ROWS_COUNT = 6;
      var ALLOWED_DOMAIN_TYPE = ["day", "hour"];
      return {
        name: "minute",
        allowedDomainType: ALLOWED_DOMAIN_TYPE,
        rowsCount: function rowsCount() {
          return COLUMNS_COUNT;
        },
        columnsCount: function columnsCount() {
          return ROWS_COUNT;
        },
        mapping: function mapping(startTimestamp, endTimestamp) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            DateHelper2.intervals("minute", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts, index) {
              return {
                t: ts,
                x: Math.floor(index / COLUMNS_COUNT),
                y: index % COLUMNS_COUNT
              };
            })
          );
        },
        extractUnit: function extractUnit(ts) {
          return DateHelper2.date(ts).startOf("minute").valueOf();
        }
      };
    };
    var hourTemplate = function hourTemplate2(DateHelper2, _ref) {
      var domain = _ref.domain;
      var TOTAL_ITEMS = 24;
      var ROWS_COUNT = 6;
      var ALLOWED_DOMAIN_TYPE = ["month", "week", "day"];
      return {
        name: "hour",
        allowedDomainType: ALLOWED_DOMAIN_TYPE,
        rowsCount: function rowsCount() {
          return ROWS_COUNT;
        },
        columnsCount: function columnsCount(ts) {
          switch (domain.type) {
            case "week":
              return TOTAL_ITEMS / ROWS_COUNT * 7;
            case "month":
              return TOTAL_ITEMS / ROWS_COUNT * (domain.dynamicDimension ? DateHelper2.date(ts).daysInMonth() : 31);
            case "day":
            default:
              return TOTAL_ITEMS / ROWS_COUNT;
          }
        },
        mapping: function mapping(startTimestamp, endTimestamp) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            DateHelper2.intervals("hour", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts) {
              var date2 = DateHelper2.date(ts);
              var hour = date2.hour();
              var monthDate = date2.date();
              var baseX = Math.floor(hour / ROWS_COUNT);
              var columnOffset = TOTAL_ITEMS / ROWS_COUNT;
              if (domain.type === "month") {
                baseX += (monthDate - 1) * columnOffset;
              }
              if (domain.type === "week") {
                baseX += +date2.format("d") * columnOffset;
              }
              return {
                t: ts,
                x: baseX,
                y: Math.floor(hour % ROWS_COUNT)
              };
            })
          );
        },
        extractUnit: function extractUnit(ts) {
          return DateHelper2.date(ts).startOf("hour").valueOf();
        }
      };
    };
    var dayTemplate$2 = function dayTemplate2(DateHelper2, _ref) {
      var domain = _ref.domain, verticalOrientation = _ref.verticalOrientation;
      var ROWS_COUNT = 7;
      var ALLOWED_DOMAIN_TYPE = ["year", "month", "week"];
      return {
        name: "day",
        allowedDomainType: ALLOWED_DOMAIN_TYPE,
        rowsCount: function rowsCount() {
          return domain.type === "week" ? 1 : ROWS_COUNT;
        },
        columnsCount: function columnsCount(ts) {
          switch (domain.type) {
            case "month":
              return Math.ceil(domain.dynamicDimension && !verticalOrientation ? DateHelper2.getMonthWeekNumber(DateHelper2.date(ts).endOf("month")) : 6);
            case "year":
              return Math.ceil(domain.dynamicDimension ? DateHelper2.date(ts).endOf("year").dayOfYear() / ROWS_COUNT : 54);
            case "week":
            default:
              return ROWS_COUNT;
          }
        },
        mapping: function mapping(startTimestamp, endTimestamp) {
          var weekNumber = 0;
          var x = -1;
          return DateHelper2.intervals("day", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts) {
            var date2 = DateHelper2.date(ts);
            switch (domain.type) {
              case "month":
                x = DateHelper2.getMonthWeekNumber(ts) - 1;
                break;
              case "year":
                if (weekNumber !== date2.week()) {
                  weekNumber = date2.week();
                  x += 1;
                }
                break;
              case "week":
                x = date2.weekday();
                break;
            }
            return {
              t: ts,
              x,
              y: domain.type === "week" ? 0 : date2.weekday()
            };
          });
        },
        extractUnit: function extractUnit(ts) {
          return DateHelper2.date(ts).startOf("day").valueOf();
        }
      };
    };
    var dayTemplate$1 = function dayTemplate2(DateHelper2, _ref) {
      var domain = _ref.domain, verticalOrientation = _ref.verticalOrientation;
      var COLUMNS_COUNT = 7;
      var ALLOWED_DOMAIN_TYPE = ["year", "month", "week"];
      return {
        name: "xDay",
        allowedDomainType: ALLOWED_DOMAIN_TYPE,
        rowsCount: function rowsCount(ts) {
          switch (domain.type) {
            case "month":
              return Math.ceil(domain.dynamicDimension && !verticalOrientation ? DateHelper2.getMonthWeekNumber(DateHelper2.date(ts).endOf("month")) : 6);
            case "year":
              return Math.ceil(domain.dynamicDimension ? DateHelper2.date(ts).endOf("year").dayOfYear() / COLUMNS_COUNT : 54);
            case "week":
            default:
              return COLUMNS_COUNT;
          }
        },
        columnsCount: function columnsCount() {
          if (domain.type === "week") {
            return 1;
          }
          return COLUMNS_COUNT;
        },
        mapping: function mapping(startTimestamp, endTimestamp) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            DateHelper2.intervals("day", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts) {
              var date2 = DateHelper2.date(ts);
              var endWeekNumber = date2.endOf("year").week();
              var x = 0;
              switch (domain.type) {
                case "month":
                  x = DateHelper2.getMonthWeekNumber(ts) - 1;
                  break;
                case "year":
                  if (endWeekNumber === 1 && date2.week() === endWeekNumber) {
                    x = date2.subtract(1, "week").week() + 1;
                  }
                  x = date2.week() - 1;
                  break;
                case "week":
                  x = date2.weekday();
                  break;
              }
              return {
                t: ts,
                y: x,
                x: domain.type === "week" ? 0 : date2.weekday()
              };
            })
          );
        },
        extractUnit: function extractUnit(ts) {
          return DateHelper2.date(ts).startOf("day").valueOf();
        }
      };
    };
    var dayTemplate = function dayTemplate2(DateHelper2) {
      var ROWS_COUNT = 7;
      var ALLOWED_DOMAIN_TYPE = ["month"];
      return {
        name: "ghDay",
        allowedDomainType: ALLOWED_DOMAIN_TYPE,
        rowsCount: function rowsCount() {
          return ROWS_COUNT;
        },
        columnsCount: function columnsCount(ts) {
          return DateHelper2.getWeeksCountInMonth(ts);
        },
        mapping: function mapping(startTimestamp, endTimestamp) {
          var clampStart = DateHelper2.getFirstWeekOfMonth(startTimestamp);
          var clampEnd = DateHelper2.getFirstWeekOfMonth(endTimestamp);
          var x = -1;
          var pivotDay = clampStart.weekday();
          return DateHelper2.intervals("day", clampStart, clampEnd).map(function(ts) {
            var weekday2 = DateHelper2.date(ts).weekday();
            if (weekday2 === pivotDay) {
              x += 1;
            }
            return {
              t: ts,
              x,
              y: weekday2
            };
          });
        },
        extractUnit: function extractUnit(ts) {
          return DateHelper2.date(ts).startOf("day").valueOf();
        }
      };
    };
    var weekTemplate = function weekTemplate2(DateHelper2, _ref) {
      var domain = _ref.domain;
      var ALLOWED_DOMAIN_TYPE = ["year", "month"];
      return {
        name: "week",
        allowedDomainType: ALLOWED_DOMAIN_TYPE,
        rowsCount: function rowsCount() {
          return 1;
        },
        columnsCount: function columnsCount(ts) {
          switch (domain.type) {
            case "year":
              return domain.dynamicDimension ? DateHelper2.date(ts).endOf("year").isoWeeksInYear() : 53;
            case "month":
              return domain.dynamicDimension ? DateHelper2.getWeeksCountInMonth(ts) : 5;
            default:
              return 1;
          }
        },
        mapping: function mapping(startTimestamp, endTimestamp) {
          var clampStart = DateHelper2.getFirstWeekOfMonth(startTimestamp);
          var clampEnd = DateHelper2.getFirstWeekOfMonth(endTimestamp);
          return DateHelper2.intervals("week", clampStart, clampEnd).map(function(ts, i) {
            return {
              t: ts,
              x: i,
              y: 0
            };
          });
        },
        extractUnit: function extractUnit(ts) {
          return DateHelper2.date(ts).startOf("week").valueOf();
        }
      };
    };
    var monthTemplate = function monthTemplate2(DateHelper2) {
      var ALLOWED_DOMAIN_TYPE = ["year"];
      return {
        name: "month",
        allowedDomainType: ALLOWED_DOMAIN_TYPE,
        rowsCount: function rowsCount() {
          return 1;
        },
        columnsCount: function columnsCount() {
          return 12;
        },
        mapping: function mapping(startTimestamp, endTimestamp) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            DateHelper2.intervals("month", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts) {
              return {
                t: ts,
                x: DateHelper2.date(ts).month(),
                y: 0
              };
            })
          );
        },
        extractUnit: function extractUnit(ts) {
          return DateHelper2.date(ts).startOf("month").valueOf();
        }
      };
    };
    var yearTemplate = function yearTemplate2(DateHelper2) {
      var ALLOWED_DOMAIN_TYPE = [];
      return {
        name: "year",
        allowedDomainType: ALLOWED_DOMAIN_TYPE,
        rowsCount: function rowsCount() {
          return 1;
        },
        columnsCount: function columnsCount() {
          return 1;
        },
        mapping: function mapping(startTimestamp, endTimestamp) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            DateHelper2.intervals("year", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts, index) {
              return {
                t: ts,
                x: index,
                y: 0
              };
            })
          );
        },
        extractUnit: function extractUnit(ts) {
          return DateHelper2.date(ts).startOf("year").valueOf();
        }
      };
    };
    var DefaultTemplates = [minuteTemplate, hourTemplate, dayTemplate$2, dayTemplate$1, dayTemplate, weekTemplate, monthTemplate, yearTemplate];
    var TemplateCollection = /* @__PURE__ */ function() {
      function TemplateCollection2(dateHelper, options) {
        _classCallCheck$2(this, TemplateCollection2);
        this.settings = /* @__PURE__ */ new Map();
        this.dateHelper = dateHelper;
        this.options = options;
        this.initiated = false;
      }
      _createClass$2(TemplateCollection2, [{
        key: "get",
        value: function get2(subDomainType) {
          return this.settings.get(subDomainType);
        }
      }, {
        key: "has",
        value: function has2(subDomainType) {
          return this.settings.has(subDomainType);
        }
      }, {
        key: "init",
        value: function init2() {
          if (!this.initiated) {
            this.initiated = true;
            this.add(DefaultTemplates);
          }
        }
      }, {
        key: "add",
        value: function add(templates) {
          var _this = this;
          this.init();
          var tplWithParent = [];
          castArray(templates).forEach(function(f) {
            var template = f(_this.dateHelper, _this.options.options);
            _this.settings.set(template.name, template);
            if (template.hasOwnProperty("parent")) {
              tplWithParent.push(template.name);
            }
          });
          tplWithParent.forEach(function(name) {
            var parentTemplate = _this.settings.get(_this.settings.get(name).parent);
            if (!parentTemplate) {
              return;
            }
            _this.settings.set(name, Object.assign(Object.assign({}, parentTemplate), _this.settings.get(name)));
          });
        }
      }]);
      return TemplateCollection2;
    }();
    var CalHeatmap = /* @__PURE__ */ function() {
      function CalHeatmap2() {
        _classCallCheck$2(this, CalHeatmap2);
        this.options = new Options();
        this.dateHelper = new DateHelper();
        this.templateCollection = new TemplateCollection(this.dateHelper, this.options);
        this.dataFetcher = new DataFetcher(this);
        this.navigator = new Navigator(this);
        this.populator = new Populator(this);
        this.calendarPainter = new CalendarPainter(this);
        this.eventEmitter = new EventEmitter();
        this.pluginManager = new PluginManager(this);
      }
      _createClass$2(CalHeatmap2, [{
        key: "createDomainCollection",
        value: function createDomainCollection(startDate, range2) {
          var excludeEnd = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
          return new DomainCollection(this.dateHelper, this.options.options.domain.type, startDate, range2, excludeEnd);
        }
        // =========================================================================
        // PUBLIC API
        // =========================================================================
        /**
         * Setup and paint the calendar with the given options
         *
         * @param  {Object} options The Options object
         * @return A Promise, which will fulfill once all the underlying asynchronous
         * tasks settle, whether resolved or rejected.
         */
      }, {
        key: "paint",
        value: function paint(options, plugins) {
          return __awaiter(this, void 0, void 0, /* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    this.options.init(options);
                    _context.next = 3;
                    return this.dateHelper.setup(this.options);
                  case 3:
                    this.templateCollection.init();
                    _context.prev = 4;
                    validate(this.templateCollection, this.options.options);
                    _context.next = 11;
                    break;
                  case 8:
                    _context.prev = 8;
                    _context.t0 = _context["catch"](4);
                    return _context.abrupt("return", Promise.reject(_context.t0));
                  case 11:
                    if (plugins) {
                      this.pluginManager.add(castArray(plugins));
                    }
                    this.calendarPainter.setup();
                    this.domainCollection = new DomainCollection(this.dateHelper);
                    this.navigator.loadNewDomains(this.createDomainCollection(this.options.options.date.start, this.options.options.range));
                    return _context.abrupt("return", Promise.allSettled([this.calendarPainter.paint(), this.fill()]));
                  case 16:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this, [[4, 8]]);
          }));
        }
        /**
         * Add a new subDomainTemplate
         *
         * @since 4.0.0
         * @param  {SubDomainTemplate[] | SubDomainTemplate} templates
         * A single, or an array of SubDomainTemplate object
         * @return void
         */
      }, {
        key: "addTemplates",
        value: function addTemplates(templates) {
          this.templateCollection.add(templates);
        }
        /**
         * Shift the calendar by n domains forward
         *
         * @param {number} n Number of domain intervals to shift forward
         * @return A Promise, which will fulfill once all the underlying asynchronous
         * tasks settle, whether resolved or rejected.
         */
      }, {
        key: "next",
        value: function next() {
          var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
          var loadDirection = this.navigator.loadNewDomains(this.createDomainCollection(this.domainCollection.max, n + 1).slice(n), ScrollDirection.SCROLL_FORWARD);
          return Promise.allSettled([this.calendarPainter.paint(loadDirection), this.fill()]);
        }
        /**
         * Shift the calendar by n domains backward
         *
         * @param {number} n Number of domain intervals to shift backward
         * @return A Promise, which will fulfill once all the underlying asynchronous
         * tasks settle, whether resolved or rejected.
         */
      }, {
        key: "previous",
        value: function previous() {
          var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
          var loadDirection = this.navigator.loadNewDomains(this.createDomainCollection(this.domainCollection.min, -n), ScrollDirection.SCROLL_BACKWARD);
          return Promise.allSettled([this.calendarPainter.paint(loadDirection), this.fill()]);
        }
        /**
         * Jump directly to a specific date
         *
         * JumpTo will scroll the calendar until the wanted domain with the specified
         * date is visible. Unless you set reset to true, the wanted domain
         * will not necessarily be the first domain of the calendar.
         *
         * @param {Date} date Jump to the domain containing that date
         * @param {boolean} reset Whether the wanted domain
         * should be the first domain of the calendar
         * @return A Promise, which will fulfill once all the underlying asynchronous
         * tasks settle, whether resolved or rejected.
         */
      }, {
        key: "jumpTo",
        value: function jumpTo(date2) {
          var reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          return Promise.allSettled([this.calendarPainter.paint(this.navigator.jumpTo(date2, reset)), this.fill()]);
        }
        /**
         * Fill the calendar with the given data
         *
         * @param  {Object|string}    dataSource    The calendar's datasource,
         * same type as `options.data.source`
         * @return A Promise, which will fulfill once all the underlying asynchronous
         * tasks settle, whether resolved or rejected.
         */
      }, {
        key: "fill",
        value: function fill2() {
          var _this = this;
          var dataSource = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.options.data.source;
          var options = this.options.options;
          var template = this.templateCollection;
          var endDate = this.dateHelper.intervals(options.domain.type, this.domainCollection.max, 2)[1];
          var dataPromise = this.dataFetcher.getDatas(dataSource, this.domainCollection.min, endDate);
          return new Promise(function(resolve, reject) {
            dataPromise.then(function(data2) {
              _this.domainCollection.fill(data2, options.data, template.get(options.subDomain.type).extractUnit);
              _this.populator.populate();
              resolve(null);
            }, function(error) {
              reject(error);
            });
          });
        }
        /**
         * Listener for all events
         *
         * @since 4.0.0
         * @param  {string}  eventName  Name of the event to listen to
         * @param  {function} Callback function to execute on event trigger
         * @return void
         */
      }, {
        key: "on",
        value: function on(name, fn) {
          this.eventEmitter.on(name, fn);
        }
      }, {
        key: "dimensions",
        value: function dimensions() {
          return this.calendarPainter.dimensions;
        }
        /**
         * Destroy the calendar
         *
         * @since  3.3.6
         * @return A Promise, which will fulfill once all the underlying asynchronous
         * tasks settle, whether resolved or rejected.
         */
      }, {
        key: "destroy",
        value: function destroy() {
          return this.calendarPainter.destroy();
        }
      }, {
        key: "extendDayjs",
        value: function extendDayjs(plugin) {
          return this.dateHelper.extend(plugin);
        }
      }]);
      return CalHeatmap2;
    }();
    CalHeatmap.VERSION = VERSION;
    const calHeatmap = "";
    function _classCallCheck$1(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$1(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
      }
    }
    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties$1(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties$1(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _toPrimitive$1(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey$1(arg) {
      var key = _toPrimitive$1(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var fails$b$1 = function(exec2) {
      try {
        return !!exec2();
      } catch (error) {
        return true;
      }
    };
    var fails$a$1 = fails$b$1;
    var descriptors$1 = !fails$a$1(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
    var fails$9$1 = fails$b$1;
    var functionBindNative$1 = !fails$9$1(function() {
      var test2 = (function() {
      }).bind();
      return typeof test2 != "function" || test2.hasOwnProperty("prototype");
    });
    var NATIVE_BIND$3$1 = functionBindNative$1;
    var FunctionPrototype$3$1 = Function.prototype;
    var call$d$1 = FunctionPrototype$3$1.call;
    var uncurryThisWithBind$1 = NATIVE_BIND$3$1 && FunctionPrototype$3$1.bind.bind(call$d$1, call$d$1);
    var functionUncurryThis$1 = NATIVE_BIND$3$1 ? uncurryThisWithBind$1 : function(fn) {
      return function() {
        return call$d$1.apply(fn, arguments);
      };
    };
    var isNullOrUndefined$4$1 = function(it) {
      return it === null || it === void 0;
    };
    var isNullOrUndefined$3$1 = isNullOrUndefined$4$1;
    var $TypeError$c$1 = TypeError;
    var requireObjectCoercible$2$1 = function(it) {
      if (isNullOrUndefined$3$1(it))
        throw new $TypeError$c$1("Can't call method on " + it);
      return it;
    };
    var requireObjectCoercible$1$1 = requireObjectCoercible$2$1;
    var $Object$3$1 = Object;
    var toObject$2$1 = function(argument) {
      return $Object$3$1(requireObjectCoercible$1$1(argument));
    };
    var uncurryThis$f$1 = functionUncurryThis$1;
    var toObject$1$1 = toObject$2$1;
    var hasOwnProperty$1 = uncurryThis$f$1({}.hasOwnProperty);
    var hasOwnProperty_1$1 = Object.hasOwn || function hasOwn2(it, key) {
      return hasOwnProperty$1(toObject$1$1(it), key);
    };
    var DESCRIPTORS$9$1 = descriptors$1;
    var hasOwn$8$1 = hasOwnProperty_1$1;
    var FunctionPrototype$2$1 = Function.prototype;
    var getDescriptor$1 = DESCRIPTORS$9$1 && Object.getOwnPropertyDescriptor;
    var EXISTS$1$1 = hasOwn$8$1(FunctionPrototype$2$1, "name");
    var PROPER$1 = EXISTS$1$1 && (function something() {
    }).name === "something";
    var CONFIGURABLE$1$1 = EXISTS$1$1 && (!DESCRIPTORS$9$1 || DESCRIPTORS$9$1 && getDescriptor$1(FunctionPrototype$2$1, "name").configurable);
    var functionName$1 = {
      EXISTS: EXISTS$1$1,
      PROPER: PROPER$1,
      CONFIGURABLE: CONFIGURABLE$1$1
    };
    var makeBuiltIn$3$1 = { exports: {} };
    var documentAll$2$1 = typeof document == "object" && document.all;
    var IS_HTMLDDA$1 = typeof documentAll$2$1 == "undefined" && documentAll$2$1 !== void 0;
    var documentAll_1$1 = {
      all: documentAll$2$1,
      IS_HTMLDDA: IS_HTMLDDA$1
    };
    var $documentAll$1$1 = documentAll_1$1;
    var documentAll$1$1 = $documentAll$1$1.all;
    var isCallable$h$1 = $documentAll$1$1.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll$1$1;
    } : function(argument) {
      return typeof argument == "function";
    };
    var check$1 = function(it) {
      return it && it.Math === Math && it;
    };
    var global$h$1 = (
      // eslint-disable-next-line es/no-global-this -- safe
      check$1(typeof globalThis == "object" && globalThis) || check$1(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      check$1(typeof self == "object" && self) || check$1(typeof commonjsGlobal$1 == "object" && commonjsGlobal$1) || check$1(typeof commonjsGlobal$1 == "object" && commonjsGlobal$1) || // eslint-disable-next-line no-new-func -- fallback
      function() {
        return this;
      }() || Function("return this")()
    );
    var global$g$1 = global$h$1;
    var defineProperty$4$1 = Object.defineProperty;
    var defineGlobalProperty$3$1 = function(key, value) {
      try {
        defineProperty$4$1(global$g$1, key, { value, configurable: true, writable: true });
      } catch (error) {
        global$g$1[key] = value;
      }
      return value;
    };
    var global$f$1 = global$h$1;
    var defineGlobalProperty$2$1 = defineGlobalProperty$3$1;
    var SHARED$1 = "__core-js_shared__";
    var store$3$1 = global$f$1[SHARED$1] || defineGlobalProperty$2$1(SHARED$1, {});
    var sharedStore$1 = store$3$1;
    var uncurryThis$e$1 = functionUncurryThis$1;
    var isCallable$g$1 = isCallable$h$1;
    var store$2$1 = sharedStore$1;
    var functionToString$1$1 = uncurryThis$e$1(Function.toString);
    if (!isCallable$g$1(store$2$1.inspectSource)) {
      store$2$1.inspectSource = function(it) {
        return functionToString$1$1(it);
      };
    }
    var inspectSource$3$1 = store$2$1.inspectSource;
    var global$e$1 = global$h$1;
    var isCallable$f$1 = isCallable$h$1;
    var WeakMap$1$1 = global$e$1.WeakMap;
    var weakMapBasicDetection$1 = isCallable$f$1(WeakMap$1$1) && /native code/.test(String(WeakMap$1$1));
    var isCallable$e$1 = isCallable$h$1;
    var $documentAll$2 = documentAll_1$1;
    var documentAll$3 = $documentAll$2.all;
    var isObject$8$1 = $documentAll$2.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable$e$1(it) || it === documentAll$3;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable$e$1(it);
    };
    var objectDefineProperty$1 = {};
    var global$d$1 = global$h$1;
    var isObject$7$1 = isObject$8$1;
    var document$3$1 = global$d$1.document;
    var EXISTS$2 = isObject$7$1(document$3$1) && isObject$7$1(document$3$1.createElement);
    var documentCreateElement$3 = function(it) {
      return EXISTS$2 ? document$3$1.createElement(it) : {};
    };
    var DESCRIPTORS$8$1 = descriptors$1;
    var fails$8$1 = fails$b$1;
    var createElement$1$1 = documentCreateElement$3;
    var ie8DomDefine$1 = !DESCRIPTORS$8$1 && !fails$8$1(function() {
      return Object.defineProperty(createElement$1$1("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
    var DESCRIPTORS$7$1 = descriptors$1;
    var fails$7$1 = fails$b$1;
    var v8PrototypeDefineBug$1 = DESCRIPTORS$7$1 && fails$7$1(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
    var isObject$6$1 = isObject$8$1;
    var $String$4$1 = String;
    var $TypeError$b$1 = TypeError;
    var anObject$8$1 = function(argument) {
      if (isObject$6$1(argument))
        return argument;
      throw new $TypeError$b$1($String$4$1(argument) + " is not an object");
    };
    var NATIVE_BIND$2$1 = functionBindNative$1;
    var call$c$1 = Function.prototype.call;
    var functionCall$1 = NATIVE_BIND$2$1 ? call$c$1.bind(call$c$1) : function() {
      return call$c$1.apply(call$c$1, arguments);
    };
    var global$c$1 = global$h$1;
    var isCallable$d$1 = isCallable$h$1;
    var aFunction$1 = function(argument) {
      return isCallable$d$1(argument) ? argument : void 0;
    };
    var getBuiltIn$7$1 = function(namespace2, method2) {
      return arguments.length < 2 ? aFunction$1(global$c$1[namespace2]) : global$c$1[namespace2] && global$c$1[namespace2][method2];
    };
    var uncurryThis$d$1 = functionUncurryThis$1;
    var objectIsPrototypeOf$1 = uncurryThis$d$1({}.isPrototypeOf);
    var engineUserAgent$1 = typeof navigator != "undefined" && String(navigator.userAgent) || "";
    var global$b$1 = global$h$1;
    var userAgent$3$1 = engineUserAgent$1;
    var process$3$1 = global$b$1.process;
    var Deno$1$1 = global$b$1.Deno;
    var versions$1 = process$3$1 && process$3$1.versions || Deno$1$1 && Deno$1$1.version;
    var v8$1 = versions$1 && versions$1.v8;
    var match$1, version$1;
    if (v8$1) {
      match$1 = v8$1.split(".");
      version$1 = match$1[0] > 0 && match$1[0] < 4 ? 1 : +(match$1[0] + match$1[1]);
    }
    if (!version$1 && userAgent$3$1) {
      match$1 = userAgent$3$1.match(/Edge\/(\d+)/);
      if (!match$1 || match$1[1] >= 74) {
        match$1 = userAgent$3$1.match(/Chrome\/(\d+)/);
        if (match$1)
          version$1 = +match$1[1];
      }
    }
    var engineV8Version$1 = version$1;
    var V8_VERSION$1$1 = engineV8Version$1;
    var fails$6$1 = fails$b$1;
    var global$a$1 = global$h$1;
    var $String$3$1 = global$a$1.String;
    var symbolConstructorDetection$1 = !!Object.getOwnPropertySymbols && !fails$6$1(function() {
      var symbol2 = Symbol("symbol detection");
      return !$String$3$1(symbol2) || !(Object(symbol2) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION$1$1 && V8_VERSION$1$1 < 41;
    });
    var NATIVE_SYMBOL$1$1 = symbolConstructorDetection$1;
    var useSymbolAsUid$1 = NATIVE_SYMBOL$1$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
    var getBuiltIn$6$1 = getBuiltIn$7$1;
    var isCallable$c$1 = isCallable$h$1;
    var isPrototypeOf$2$1 = objectIsPrototypeOf$1;
    var USE_SYMBOL_AS_UID$1$1 = useSymbolAsUid$1;
    var $Object$2$1 = Object;
    var isSymbol$2$1 = USE_SYMBOL_AS_UID$1$1 ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn$6$1("Symbol");
      return isCallable$c$1($Symbol) && isPrototypeOf$2$1($Symbol.prototype, $Object$2$1(it));
    };
    var $String$2$1 = String;
    var tryToString$4$1 = function(argument) {
      try {
        return $String$2$1(argument);
      } catch (error) {
        return "Object";
      }
    };
    var isCallable$b$1 = isCallable$h$1;
    var tryToString$3$1 = tryToString$4$1;
    var $TypeError$a$1 = TypeError;
    var aCallable$8$1 = function(argument) {
      if (isCallable$b$1(argument))
        return argument;
      throw new $TypeError$a$1(tryToString$3$1(argument) + " is not a function");
    };
    var aCallable$7$1 = aCallable$8$1;
    var isNullOrUndefined$2$1 = isNullOrUndefined$4$1;
    var getMethod$3$1 = function(V, P) {
      var func = V[P];
      return isNullOrUndefined$2$1(func) ? void 0 : aCallable$7$1(func);
    };
    var call$b$1 = functionCall$1;
    var isCallable$a$1 = isCallable$h$1;
    var isObject$5$1 = isObject$8$1;
    var $TypeError$9$1 = TypeError;
    var ordinaryToPrimitive$1$1 = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable$a$1(fn = input.toString) && !isObject$5$1(val = call$b$1(fn, input)))
        return val;
      if (isCallable$a$1(fn = input.valueOf) && !isObject$5$1(val = call$b$1(fn, input)))
        return val;
      if (pref !== "string" && isCallable$a$1(fn = input.toString) && !isObject$5$1(val = call$b$1(fn, input)))
        return val;
      throw new $TypeError$9$1("Can't convert object to primitive value");
    };
    var shared$3$1 = { exports: {} };
    var store$1$1 = sharedStore$1;
    (shared$3$1.exports = function(key, value) {
      return store$1$1[key] || (store$1$1[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.34.0",
      mode: "global",
      copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.34.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
    var sharedExports$1 = shared$3$1.exports;
    var uncurryThis$c$1 = functionUncurryThis$1;
    var id$3 = 0;
    var postfix$1 = Math.random();
    var toString$2$1 = uncurryThis$c$1(1 .toString);
    var uid$2$1 = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$2$1(++id$3 + postfix$1, 36);
    };
    var global$9$1 = global$h$1;
    var shared$2$1 = sharedExports$1;
    var hasOwn$7$1 = hasOwnProperty_1$1;
    var uid$1$1 = uid$2$1;
    var NATIVE_SYMBOL$2 = symbolConstructorDetection$1;
    var USE_SYMBOL_AS_UID$2 = useSymbolAsUid$1;
    var Symbol$1$1 = global$9$1.Symbol;
    var WellKnownSymbolsStore$1 = shared$2$1("wks");
    var createWellKnownSymbol$1 = USE_SYMBOL_AS_UID$2 ? Symbol$1$1["for"] || Symbol$1$1 : Symbol$1$1 && Symbol$1$1.withoutSetter || uid$1$1;
    var wellKnownSymbol$a$1 = function(name) {
      if (!hasOwn$7$1(WellKnownSymbolsStore$1, name)) {
        WellKnownSymbolsStore$1[name] = NATIVE_SYMBOL$2 && hasOwn$7$1(Symbol$1$1, name) ? Symbol$1$1[name] : createWellKnownSymbol$1("Symbol." + name);
      }
      return WellKnownSymbolsStore$1[name];
    };
    var call$a$1 = functionCall$1;
    var isObject$4$1 = isObject$8$1;
    var isSymbol$1$1 = isSymbol$2$1;
    var getMethod$2$1 = getMethod$3$1;
    var ordinaryToPrimitive$2 = ordinaryToPrimitive$1$1;
    var wellKnownSymbol$9$1 = wellKnownSymbol$a$1;
    var $TypeError$8$1 = TypeError;
    var TO_PRIMITIVE$1 = wellKnownSymbol$9$1("toPrimitive");
    var toPrimitive$1$1 = function(input, pref) {
      if (!isObject$4$1(input) || isSymbol$1$1(input))
        return input;
      var exoticToPrim = getMethod$2$1(input, TO_PRIMITIVE$1);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call$a$1(exoticToPrim, input, pref);
        if (!isObject$4$1(result) || isSymbol$1$1(result))
          return result;
        throw new $TypeError$8$1("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive$2(input, pref);
    };
    var toPrimitive$2 = toPrimitive$1$1;
    var isSymbol$3 = isSymbol$2$1;
    var toPropertyKey$2$1 = function(argument) {
      var key = toPrimitive$2(argument, "string");
      return isSymbol$3(key) ? key : key + "";
    };
    var DESCRIPTORS$6$1 = descriptors$1;
    var IE8_DOM_DEFINE$1$1 = ie8DomDefine$1;
    var V8_PROTOTYPE_DEFINE_BUG$2 = v8PrototypeDefineBug$1;
    var anObject$7$1 = anObject$8$1;
    var toPropertyKey$1$1 = toPropertyKey$2$1;
    var $TypeError$7$1 = TypeError;
    var $defineProperty$1 = Object.defineProperty;
    var $getOwnPropertyDescriptor$1$1 = Object.getOwnPropertyDescriptor;
    var ENUMERABLE$1 = "enumerable";
    var CONFIGURABLE$2 = "configurable";
    var WRITABLE$1 = "writable";
    objectDefineProperty$1.f = DESCRIPTORS$6$1 ? V8_PROTOTYPE_DEFINE_BUG$2 ? function defineProperty2(O, P, Attributes) {
      anObject$7$1(O);
      P = toPropertyKey$1$1(P);
      anObject$7$1(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE$1 in Attributes && !Attributes[WRITABLE$1]) {
        var current = $getOwnPropertyDescriptor$1$1(O, P);
        if (current && current[WRITABLE$1]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE$2 in Attributes ? Attributes[CONFIGURABLE$2] : current[CONFIGURABLE$2],
            enumerable: ENUMERABLE$1 in Attributes ? Attributes[ENUMERABLE$1] : current[ENUMERABLE$1],
            writable: false
          };
        }
      }
      return $defineProperty$1(O, P, Attributes);
    } : $defineProperty$1 : function defineProperty2(O, P, Attributes) {
      anObject$7$1(O);
      P = toPropertyKey$1$1(P);
      anObject$7$1(Attributes);
      if (IE8_DOM_DEFINE$1$1)
        try {
          return $defineProperty$1(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw new $TypeError$7$1("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
    var createPropertyDescriptor$2$1 = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
    var DESCRIPTORS$5$1 = descriptors$1;
    var definePropertyModule$2$1 = objectDefineProperty$1;
    var createPropertyDescriptor$1$1 = createPropertyDescriptor$2$1;
    var createNonEnumerableProperty$2$1 = DESCRIPTORS$5$1 ? function(object2, key, value) {
      return definePropertyModule$2$1.f(object2, key, createPropertyDescriptor$1$1(1, value));
    } : function(object2, key, value) {
      object2[key] = value;
      return object2;
    };
    var shared$1$1 = sharedExports$1;
    var uid$4 = uid$2$1;
    var keys$1 = shared$1$1("keys");
    var sharedKey$1$1 = function(key) {
      return keys$1[key] || (keys$1[key] = uid$4(key));
    };
    var hiddenKeys$3$1 = {};
    var NATIVE_WEAK_MAP$1 = weakMapBasicDetection$1;
    var global$8$1 = global$h$1;
    var isObject$3$1 = isObject$8$1;
    var createNonEnumerableProperty$1$1 = createNonEnumerableProperty$2$1;
    var hasOwn$6$1 = hasOwnProperty_1$1;
    var shared$4 = sharedStore$1;
    var sharedKey$4 = sharedKey$1$1;
    var hiddenKeys$2$1 = hiddenKeys$3$1;
    var OBJECT_ALREADY_INITIALIZED$1 = "Object already initialized";
    var TypeError$2$1 = global$8$1.TypeError;
    var WeakMap$2 = global$8$1.WeakMap;
    var set$1$1, get$1, has$1;
    var enforce$1 = function(it) {
      return has$1(it) ? get$1(it) : set$1$1(it, {});
    };
    var getterFor$1 = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject$3$1(it) || (state = get$1(it)).type !== TYPE) {
          throw new TypeError$2$1("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP$1 || shared$4.state) {
      var store$4 = shared$4.state || (shared$4.state = new WeakMap$2());
      store$4.get = store$4.get;
      store$4.has = store$4.has;
      store$4.set = store$4.set;
      set$1$1 = function(it, metadata) {
        if (store$4.has(it))
          throw new TypeError$2$1(OBJECT_ALREADY_INITIALIZED$1);
        metadata.facade = it;
        store$4.set(it, metadata);
        return metadata;
      };
      get$1 = function(it) {
        return store$4.get(it) || {};
      };
      has$1 = function(it) {
        return store$4.has(it);
      };
    } else {
      var STATE$1 = sharedKey$4("state");
      hiddenKeys$2$1[STATE$1] = true;
      set$1$1 = function(it, metadata) {
        if (hasOwn$6$1(it, STATE$1))
          throw new TypeError$2$1(OBJECT_ALREADY_INITIALIZED$1);
        metadata.facade = it;
        createNonEnumerableProperty$1$1(it, STATE$1, metadata);
        return metadata;
      };
      get$1 = function(it) {
        return hasOwn$6$1(it, STATE$1) ? it[STATE$1] : {};
      };
      has$1 = function(it) {
        return hasOwn$6$1(it, STATE$1);
      };
    }
    var internalState$1 = {
      set: set$1$1,
      get: get$1,
      has: has$1,
      enforce: enforce$1,
      getterFor: getterFor$1
    };
    var uncurryThis$b$1 = functionUncurryThis$1;
    var fails$5$1 = fails$b$1;
    var isCallable$9$1 = isCallable$h$1;
    var hasOwn$5$1 = hasOwnProperty_1$1;
    var DESCRIPTORS$4$1 = descriptors$1;
    var CONFIGURABLE_FUNCTION_NAME$2 = functionName$1.CONFIGURABLE;
    var inspectSource$2$1 = inspectSource$3$1;
    var InternalStateModule$1$1 = internalState$1;
    var enforceInternalState$1 = InternalStateModule$1$1.enforce;
    var getInternalState$3 = InternalStateModule$1$1.get;
    var $String$1$1 = String;
    var defineProperty$3$1 = Object.defineProperty;
    var stringSlice$1$1 = uncurryThis$b$1("".slice);
    var replace$1 = uncurryThis$b$1("".replace);
    var join$1 = uncurryThis$b$1([].join);
    var CONFIGURABLE_LENGTH$1 = DESCRIPTORS$4$1 && !fails$5$1(function() {
      return defineProperty$3$1(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE$1 = String(String).split("String");
    var makeBuiltIn$2$1 = makeBuiltIn$3$1.exports = function(value, name, options) {
      if (stringSlice$1$1($String$1$1(name), 0, 7) === "Symbol(") {
        name = "[" + replace$1($String$1$1(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
      }
      if (options && options.getter)
        name = "get " + name;
      if (options && options.setter)
        name = "set " + name;
      if (!hasOwn$5$1(value, "name") || CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name) {
        if (DESCRIPTORS$4$1)
          defineProperty$3$1(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH$1 && options && hasOwn$5$1(options, "arity") && value.length !== options.arity) {
        defineProperty$3$1(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn$5$1(options, "constructor") && options.constructor) {
          if (DESCRIPTORS$4$1)
            defineProperty$3$1(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState$1(value);
      if (!hasOwn$5$1(state, "source")) {
        state.source = join$1(TEMPLATE$1, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn$2$1(function toString2() {
      return isCallable$9$1(this) && getInternalState$3(this).source || inspectSource$2$1(this);
    }, "toString");
    var makeBuiltInExports$1 = makeBuiltIn$3$1.exports;
    var makeBuiltIn$1$1 = makeBuiltInExports$1;
    var defineProperty$2$1 = objectDefineProperty$1;
    var defineBuiltInAccessor$2$1 = function(target, name, descriptor) {
      if (descriptor.get)
        makeBuiltIn$1$1(descriptor.get, name, { getter: true });
      if (descriptor.set)
        makeBuiltIn$1$1(descriptor.set, name, { setter: true });
      return defineProperty$2$1.f(target, name, descriptor);
    };
    var DESCRIPTORS$3$1 = descriptors$1;
    var FUNCTION_NAME_EXISTS$1 = functionName$1.EXISTS;
    var uncurryThis$a$1 = functionUncurryThis$1;
    var defineBuiltInAccessor$1$1 = defineBuiltInAccessor$2$1;
    var FunctionPrototype$1$1 = Function.prototype;
    var functionToString$2 = uncurryThis$a$1(FunctionPrototype$1$1.toString);
    var nameRE$1 = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
    var regExpExec$1 = uncurryThis$a$1(nameRE$1.exec);
    var NAME$1 = "name";
    if (DESCRIPTORS$3$1 && !FUNCTION_NAME_EXISTS$1) {
      defineBuiltInAccessor$1$1(FunctionPrototype$1$1, NAME$1, {
        configurable: true,
        get: function() {
          try {
            return regExpExec$1(nameRE$1, functionToString$2(this))[1];
          } catch (error) {
            return "";
          }
        }
      });
    }
    var objectGetOwnPropertyDescriptor$1 = {};
    var objectPropertyIsEnumerable$1 = {};
    var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor$2$1 = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG$1 = getOwnPropertyDescriptor$2$1 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);
    objectPropertyIsEnumerable$1.f = NASHORN_BUG$1 ? function propertyIsEnumerable2(V) {
      var descriptor = getOwnPropertyDescriptor$2$1(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable$1;
    var uncurryThis$9$1 = functionUncurryThis$1;
    var toString$1$1 = uncurryThis$9$1({}.toString);
    var stringSlice$3 = uncurryThis$9$1("".slice);
    var classofRaw$2$1 = function(it) {
      return stringSlice$3(toString$1$1(it), 8, -1);
    };
    var uncurryThis$8$1 = functionUncurryThis$1;
    var fails$4$1 = fails$b$1;
    var classof$5$1 = classofRaw$2$1;
    var $Object$1$1 = Object;
    var split$1 = uncurryThis$8$1("".split);
    var indexedObject$1 = fails$4$1(function() {
      return !$Object$1$1("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof$5$1(it) === "String" ? split$1(it, "") : $Object$1$1(it);
    } : $Object$1$1;
    var IndexedObject$1$1 = indexedObject$1;
    var requireObjectCoercible$4 = requireObjectCoercible$2$1;
    var toIndexedObject$3$1 = function(it) {
      return IndexedObject$1$1(requireObjectCoercible$4(it));
    };
    var DESCRIPTORS$2$1 = descriptors$1;
    var call$9$1 = functionCall$1;
    var propertyIsEnumerableModule$1$1 = objectPropertyIsEnumerable$1;
    var createPropertyDescriptor$5 = createPropertyDescriptor$2$1;
    var toIndexedObject$2$1 = toIndexedObject$3$1;
    var toPropertyKey$4 = toPropertyKey$2$1;
    var hasOwn$4$1 = hasOwnProperty_1$1;
    var IE8_DOM_DEFINE$2 = ie8DomDefine$1;
    var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
    objectGetOwnPropertyDescriptor$1.f = DESCRIPTORS$2$1 ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor2(O, P) {
      O = toIndexedObject$2$1(O);
      P = toPropertyKey$4(P);
      if (IE8_DOM_DEFINE$2)
        try {
          return $getOwnPropertyDescriptor$2(O, P);
        } catch (error) {
        }
      if (hasOwn$4$1(O, P))
        return createPropertyDescriptor$5(!call$9$1(propertyIsEnumerableModule$1$1.f, O, P), O[P]);
    };
    var isCallable$8$1 = isCallable$h$1;
    var definePropertyModule$1$1 = objectDefineProperty$1;
    var makeBuiltIn$4 = makeBuiltInExports$1;
    var defineGlobalProperty$1$1 = defineGlobalProperty$3$1;
    var defineBuiltIn$4$1 = function(O, key, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable$8$1(value))
        makeBuiltIn$4(value, name, options);
      if (options.global) {
        if (simple)
          O[key] = value;
        else
          defineGlobalProperty$1$1(key, value);
      } else {
        try {
          if (!options.unsafe)
            delete O[key];
          else if (O[key])
            simple = true;
        } catch (error) {
        }
        if (simple)
          O[key] = value;
        else
          definePropertyModule$1$1.f(O, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O;
    };
    var objectGetOwnPropertyNames$1 = {};
    var ceil$1 = Math.ceil;
    var floor$1 = Math.floor;
    var mathTrunc$1 = Math.trunc || function trunc2(x) {
      var n = +x;
      return (n > 0 ? floor$1 : ceil$1)(n);
    };
    var trunc$1 = mathTrunc$1;
    var toIntegerOrInfinity$2$1 = function(argument) {
      var number2 = +argument;
      return number2 !== number2 || number2 === 0 ? 0 : trunc$1(number2);
    };
    var toIntegerOrInfinity$1$1 = toIntegerOrInfinity$2$1;
    var max$3 = Math.max;
    var min$1$1 = Math.min;
    var toAbsoluteIndex$1$1 = function(index, length2) {
      var integer = toIntegerOrInfinity$1$1(index);
      return integer < 0 ? max$3(integer + length2, 0) : min$1$1(integer, length2);
    };
    var toIntegerOrInfinity$4 = toIntegerOrInfinity$2$1;
    var min$3 = Math.min;
    var toLength$1$1 = function(argument) {
      return argument > 0 ? min$3(toIntegerOrInfinity$4(argument), 9007199254740991) : 0;
    };
    var toLength$2 = toLength$1$1;
    var lengthOfArrayLike$2$1 = function(obj) {
      return toLength$2(obj.length);
    };
    var toIndexedObject$1$1 = toIndexedObject$3$1;
    var toAbsoluteIndex$3 = toAbsoluteIndex$1$1;
    var lengthOfArrayLike$1$1 = lengthOfArrayLike$2$1;
    var createMethod$3 = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject$1$1($this);
        var length2 = lengthOfArrayLike$1$1(O);
        var index = toAbsoluteIndex$3(fromIndex, length2);
        var value;
        if (IS_INCLUDES && el !== el)
          while (length2 > index) {
            value = O[index++];
            if (value !== value)
              return true;
          }
        else
          for (; length2 > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    var arrayIncludes$1 = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod$3(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod$3(false)
    };
    var uncurryThis$7$1 = functionUncurryThis$1;
    var hasOwn$3$1 = hasOwnProperty_1$1;
    var toIndexedObject$7 = toIndexedObject$3$1;
    var indexOf$1 = arrayIncludes$1.indexOf;
    var hiddenKeys$1$1 = hiddenKeys$3$1;
    var push$2 = uncurryThis$7$1([].push);
    var objectKeysInternal$1 = function(object2, names) {
      var O = toIndexedObject$7(object2);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        !hasOwn$3$1(hiddenKeys$1$1, key) && hasOwn$3$1(O, key) && push$2(result, key);
      while (names.length > i)
        if (hasOwn$3$1(O, key = names[i++])) {
          ~indexOf$1(result, key) || push$2(result, key);
        }
      return result;
    };
    var enumBugKeys$2$1 = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
    var internalObjectKeys$1$1 = objectKeysInternal$1;
    var enumBugKeys$1$1 = enumBugKeys$2$1;
    var hiddenKeys$6 = enumBugKeys$1$1.concat("length", "prototype");
    objectGetOwnPropertyNames$1.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys$1$1(O, hiddenKeys$6);
    };
    var objectGetOwnPropertySymbols$1 = {};
    objectGetOwnPropertySymbols$1.f = Object.getOwnPropertySymbols;
    var getBuiltIn$5$1 = getBuiltIn$7$1;
    var uncurryThis$6$1 = functionUncurryThis$1;
    var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames$1;
    var getOwnPropertySymbolsModule$1$1 = objectGetOwnPropertySymbols$1;
    var anObject$6$1 = anObject$8$1;
    var concat$1$1 = uncurryThis$6$1([].concat);
    var ownKeys$1$1 = getBuiltIn$5$1("Reflect", "ownKeys") || function ownKeys2(it) {
      var keys2 = getOwnPropertyNamesModule$2.f(anObject$6$1(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule$1$1.f;
      return getOwnPropertySymbols ? concat$1$1(keys2, getOwnPropertySymbols(it)) : keys2;
    };
    var hasOwn$2$1 = hasOwnProperty_1$1;
    var ownKeys$2 = ownKeys$1$1;
    var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor$1;
    var definePropertyModule$5 = objectDefineProperty$1;
    var copyConstructorProperties$1$1 = function(target, source, exceptions) {
      var keys2 = ownKeys$2(source);
      var defineProperty2 = definePropertyModule$5.f;
      var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule$1.f;
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        if (!hasOwn$2$1(target, key) && !(exceptions && hasOwn$2$1(exceptions, key))) {
          defineProperty2(target, key, getOwnPropertyDescriptor2(source, key));
        }
      }
    };
    var fails$3$1 = fails$b$1;
    var isCallable$7$1 = isCallable$h$1;
    var replacement$1 = /#|\.prototype\./;
    var isForced$2$1 = function(feature, detection) {
      var value = data$1[normalize$1(feature)];
      return value === POLYFILL$1 ? true : value === NATIVE$1 ? false : isCallable$7$1(detection) ? fails$3$1(detection) : !!detection;
    };
    var normalize$1 = isForced$2$1.normalize = function(string2) {
      return String(string2).replace(replacement$1, ".").toLowerCase();
    };
    var data$1 = isForced$2$1.data = {};
    var NATIVE$1 = isForced$2$1.NATIVE = "N";
    var POLYFILL$1 = isForced$2$1.POLYFILL = "P";
    var isForced_1$1 = isForced$2$1;
    var global$7$1 = global$h$1;
    var getOwnPropertyDescriptor$1$1 = objectGetOwnPropertyDescriptor$1.f;
    var createNonEnumerableProperty$5 = createNonEnumerableProperty$2$1;
    var defineBuiltIn$3$1 = defineBuiltIn$4$1;
    var defineGlobalProperty$4 = defineGlobalProperty$3$1;
    var copyConstructorProperties$2 = copyConstructorProperties$1$1;
    var isForced$1$1 = isForced_1$1;
    var _export$1 = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global$7$1;
      } else if (STATIC) {
        target = global$7$1[TARGET] || defineGlobalProperty$4(TARGET, {});
      } else {
        target = (global$7$1[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor$1$1(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED2 = isForced$1$1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED2 && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties$2(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty$5(sourceProperty, "sham", true);
          }
          defineBuiltIn$3$1(target, key, sourceProperty, options);
        }
    };
    var internalObjectKeys$2 = objectKeysInternal$1;
    var enumBugKeys$4 = enumBugKeys$2$1;
    var objectKeys$1$1 = Object.keys || function keys2(O) {
      return internalObjectKeys$2(O, enumBugKeys$4);
    };
    var DESCRIPTORS$1$1 = descriptors$1;
    var uncurryThis$5$1 = functionUncurryThis$1;
    var call$8$1 = functionCall$1;
    var fails$2$1 = fails$b$1;
    var objectKeys$3 = objectKeys$1$1;
    var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols$1;
    var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable$1;
    var toObject$6 = toObject$2$1;
    var IndexedObject$3 = indexedObject$1;
    var $assign$1 = Object.assign;
    var defineProperty$1$1 = Object.defineProperty;
    var concat$2 = uncurryThis$5$1([].concat);
    var objectAssign$1 = !$assign$1 || fails$2$1(function() {
      if (DESCRIPTORS$1$1 && $assign$1({ b: 1 }, $assign$1(defineProperty$1$1({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty$1$1(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), { b: 2 })).b !== 1)
        return true;
      var A5 = {};
      var B2 = {};
      var symbol2 = Symbol("assign detection");
      var alphabet = "abcdefghijklmnopqrst";
      A5[symbol2] = 7;
      alphabet.split("").forEach(function(chr) {
        B2[chr] = chr;
      });
      return $assign$1({}, A5)[symbol2] !== 7 || objectKeys$3($assign$1({}, B2)).join("") !== alphabet;
    }) ? function assign2(target, source) {
      var T = toObject$6(target);
      var argumentsLength = arguments.length;
      var index = 1;
      var getOwnPropertySymbols = getOwnPropertySymbolsModule$2.f;
      var propertyIsEnumerable2 = propertyIsEnumerableModule$2.f;
      while (argumentsLength > index) {
        var S = IndexedObject$3(arguments[index++]);
        var keys2 = getOwnPropertySymbols ? concat$2(objectKeys$3(S), getOwnPropertySymbols(S)) : objectKeys$3(S);
        var length2 = keys2.length;
        var j = 0;
        var key;
        while (length2 > j) {
          key = keys2[j++];
          if (!DESCRIPTORS$1$1 || call$8$1(propertyIsEnumerable2, S, key))
            T[key] = S[key];
        }
      }
      return T;
    } : $assign$1;
    var $$6$1 = _export$1;
    var assign$1 = objectAssign$1;
    $$6$1({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign$1 }, {
      assign: assign$1
    });
    var wellKnownSymbol$8$1 = wellKnownSymbol$a$1;
    var TO_STRING_TAG$2$1 = wellKnownSymbol$8$1("toStringTag");
    var test$1 = {};
    test$1[TO_STRING_TAG$2$1] = "z";
    var toStringTagSupport$1 = String(test$1) === "[object z]";
    var TO_STRING_TAG_SUPPORT$2$1 = toStringTagSupport$1;
    var isCallable$6$1 = isCallable$h$1;
    var classofRaw$1$1 = classofRaw$2$1;
    var wellKnownSymbol$7$1 = wellKnownSymbol$a$1;
    var TO_STRING_TAG$1$1 = wellKnownSymbol$7$1("toStringTag");
    var $Object$5 = Object;
    var CORRECT_ARGUMENTS$1 = classofRaw$1$1(function() {
      return arguments;
    }()) === "Arguments";
    var tryGet$1 = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    var classof$4$1 = TO_STRING_TAG_SUPPORT$2$1 ? classofRaw$1$1 : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet$1(O = $Object$5(it), TO_STRING_TAG$1$1)) == "string" ? tag : CORRECT_ARGUMENTS$1 ? classofRaw$1$1(O) : (result = classofRaw$1$1(O)) === "Object" && isCallable$6$1(O.callee) ? "Arguments" : result;
    };
    var TO_STRING_TAG_SUPPORT$1$1 = toStringTagSupport$1;
    var classof$3$1 = classof$4$1;
    var objectToString$1 = TO_STRING_TAG_SUPPORT$1$1 ? {}.toString : function toString2() {
      return "[object " + classof$3$1(this) + "]";
    };
    var TO_STRING_TAG_SUPPORT$3 = toStringTagSupport$1;
    var defineBuiltIn$2$1 = defineBuiltIn$4$1;
    var toString$6 = objectToString$1;
    if (!TO_STRING_TAG_SUPPORT$3) {
      defineBuiltIn$2$1(Object.prototype, "toString", toString$6, { unsafe: true });
    }
    var global$6$1 = global$h$1;
    var classof$2$1 = classofRaw$2$1;
    var engineIsNode$1 = classof$2$1(global$6$1.process) === "process";
    var uncurryThis$4$1 = functionUncurryThis$1;
    var aCallable$6$1 = aCallable$8$1;
    var functionUncurryThisAccessor$1 = function(object2, key, method2) {
      try {
        return uncurryThis$4$1(aCallable$6$1(Object.getOwnPropertyDescriptor(object2, key)[method2]));
      } catch (error) {
      }
    };
    var isCallable$5$1 = isCallable$h$1;
    var $String$6 = String;
    var $TypeError$6$1 = TypeError;
    var aPossiblePrototype$1$1 = function(argument) {
      if (typeof argument == "object" || isCallable$5$1(argument))
        return argument;
      throw new $TypeError$6$1("Can't set " + $String$6(argument) + " as a prototype");
    };
    var uncurryThisAccessor$1 = functionUncurryThisAccessor$1;
    var anObject$5$1 = anObject$8$1;
    var aPossiblePrototype$2 = aPossiblePrototype$1$1;
    var objectSetPrototypeOf$1 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test2 = {};
      var setter;
      try {
        setter = uncurryThisAccessor$1(Object.prototype, "__proto__", "set");
        setter(test2, []);
        CORRECT_SETTER = test2 instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf2(O, proto) {
        anObject$5$1(O);
        aPossiblePrototype$2(proto);
        if (CORRECT_SETTER)
          setter(O, proto);
        else
          O.__proto__ = proto;
        return O;
      };
    }() : void 0);
    var defineProperty$8 = objectDefineProperty$1.f;
    var hasOwn$1$1 = hasOwnProperty_1$1;
    var wellKnownSymbol$6$1 = wellKnownSymbol$a$1;
    var TO_STRING_TAG$3 = wellKnownSymbol$6$1("toStringTag");
    var setToStringTag$1$1 = function(target, TAG, STATIC) {
      if (target && !STATIC)
        target = target.prototype;
      if (target && !hasOwn$1$1(target, TO_STRING_TAG$3)) {
        defineProperty$8(target, TO_STRING_TAG$3, { configurable: true, value: TAG });
      }
    };
    var getBuiltIn$4$1 = getBuiltIn$7$1;
    var defineBuiltInAccessor$3 = defineBuiltInAccessor$2$1;
    var wellKnownSymbol$5$1 = wellKnownSymbol$a$1;
    var DESCRIPTORS$c = descriptors$1;
    var SPECIES$2$1 = wellKnownSymbol$5$1("species");
    var setSpecies$1$1 = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn$4$1(CONSTRUCTOR_NAME);
      if (DESCRIPTORS$c && Constructor && !Constructor[SPECIES$2$1]) {
        defineBuiltInAccessor$3(Constructor, SPECIES$2$1, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
    var isPrototypeOf$1$1 = objectIsPrototypeOf$1;
    var $TypeError$5$1 = TypeError;
    var anInstance$1$1 = function(it, Prototype) {
      if (isPrototypeOf$1$1(Prototype, it))
        return it;
      throw new $TypeError$5$1("Incorrect invocation");
    };
    var uncurryThis$3$1 = functionUncurryThis$1;
    var fails$1$1 = fails$b$1;
    var isCallable$4$1 = isCallable$h$1;
    var classof$1$1 = classof$4$1;
    var getBuiltIn$3$1 = getBuiltIn$7$1;
    var inspectSource$1$1 = inspectSource$3$1;
    var noop$1 = function() {
    };
    var empty$1 = [];
    var construct$1 = getBuiltIn$3$1("Reflect", "construct");
    var constructorRegExp$1 = /^\s*(?:class|function)\b/;
    var exec$1 = uncurryThis$3$1(constructorRegExp$1.exec);
    var INCORRECT_TO_STRING$1 = !constructorRegExp$1.test(noop$1);
    var isConstructorModern$1 = function isConstructor2(argument) {
      if (!isCallable$4$1(argument))
        return false;
      try {
        construct$1(noop$1, empty$1, argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy$1 = function isConstructor2(argument) {
      if (!isCallable$4$1(argument))
        return false;
      switch (classof$1$1(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING$1 || !!exec$1(constructorRegExp$1, inspectSource$1$1(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy$1.sham = true;
    var isConstructor$1$1 = !construct$1 || fails$1$1(function() {
      var called2;
      return isConstructorModern$1(isConstructorModern$1.call) || !isConstructorModern$1(Object) || !isConstructorModern$1(function() {
        called2 = true;
      }) || called2;
    }) ? isConstructorLegacy$1 : isConstructorModern$1;
    var isConstructor$3 = isConstructor$1$1;
    var tryToString$2$1 = tryToString$4$1;
    var $TypeError$4$1 = TypeError;
    var aConstructor$1$1 = function(argument) {
      if (isConstructor$3(argument))
        return argument;
      throw new $TypeError$4$1(tryToString$2$1(argument) + " is not a constructor");
    };
    var anObject$4$1 = anObject$8$1;
    var aConstructor$2 = aConstructor$1$1;
    var isNullOrUndefined$1$1 = isNullOrUndefined$4$1;
    var wellKnownSymbol$4$1 = wellKnownSymbol$a$1;
    var SPECIES$1$1 = wellKnownSymbol$4$1("species");
    var speciesConstructor$1$1 = function(O, defaultConstructor) {
      var C2 = anObject$4$1(O).constructor;
      var S;
      return C2 === void 0 || isNullOrUndefined$1$1(S = anObject$4$1(C2)[SPECIES$1$1]) ? defaultConstructor : aConstructor$2(S);
    };
    var NATIVE_BIND$1$1 = functionBindNative$1;
    var FunctionPrototype$4 = Function.prototype;
    var apply$1$1 = FunctionPrototype$4.apply;
    var call$7$1 = FunctionPrototype$4.call;
    var functionApply$1 = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$1$1 ? call$7$1.bind(apply$1$1) : function() {
      return call$7$1.apply(apply$1$1, arguments);
    });
    var classofRaw$3 = classofRaw$2$1;
    var uncurryThis$2$1 = functionUncurryThis$1;
    var functionUncurryThisClause$1 = function(fn) {
      if (classofRaw$3(fn) === "Function")
        return uncurryThis$2$1(fn);
    };
    var uncurryThis$1$1 = functionUncurryThisClause$1;
    var aCallable$5$1 = aCallable$8$1;
    var NATIVE_BIND$4 = functionBindNative$1;
    var bind$4$1 = uncurryThis$1$1(uncurryThis$1$1.bind);
    var functionBindContext$1 = function(fn, that) {
      aCallable$5$1(fn);
      return that === void 0 ? fn : NATIVE_BIND$4 ? bind$4$1(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
    var getBuiltIn$2$1 = getBuiltIn$7$1;
    var html$1$1 = getBuiltIn$2$1("document", "documentElement");
    var uncurryThis$l = functionUncurryThis$1;
    var arraySlice$1$1 = uncurryThis$l([].slice);
    var $TypeError$3$1 = TypeError;
    var validateArgumentsLength$1$1 = function(passed, required) {
      if (passed < required)
        throw new $TypeError$3$1("Not enough arguments");
      return passed;
    };
    var userAgent$2$1 = engineUserAgent$1;
    var engineIsIos$1 = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2$1);
    var global$5$1 = global$h$1;
    var apply$2 = functionApply$1;
    var bind$3$1 = functionBindContext$1;
    var isCallable$3$1 = isCallable$h$1;
    var hasOwn$c = hasOwnProperty_1$1;
    var fails$k = fails$b$1;
    var html$3 = html$1$1;
    var arraySlice$3 = arraySlice$1$1;
    var createElement$2 = documentCreateElement$3;
    var validateArgumentsLength$2 = validateArgumentsLength$1$1;
    var IS_IOS$1$1 = engineIsIos$1;
    var IS_NODE$3$1 = engineIsNode$1;
    var set$2 = global$5$1.setImmediate;
    var clear$1 = global$5$1.clearImmediate;
    var process$2$1 = global$5$1.process;
    var Dispatch$1 = global$5$1.Dispatch;
    var Function$1$1 = global$5$1.Function;
    var MessageChannel$1 = global$5$1.MessageChannel;
    var String$1$1 = global$5$1.String;
    var counter$1 = 0;
    var queue$2$1 = {};
    var ONREADYSTATECHANGE$1 = "onreadystatechange";
    var $location$1, defer$1, channel$1, port$1;
    fails$k(function() {
      $location$1 = global$5$1.location;
    });
    var run$1 = function(id2) {
      if (hasOwn$c(queue$2$1, id2)) {
        var fn = queue$2$1[id2];
        delete queue$2$1[id2];
        fn();
      }
    };
    var runner$1 = function(id2) {
      return function() {
        run$1(id2);
      };
    };
    var eventListener$1 = function(event) {
      run$1(event.data);
    };
    var globalPostMessageDefer$1 = function(id2) {
      global$5$1.postMessage(String$1$1(id2), $location$1.protocol + "//" + $location$1.host);
    };
    if (!set$2 || !clear$1) {
      set$2 = function setImmediate(handler) {
        validateArgumentsLength$2(arguments.length, 1);
        var fn = isCallable$3$1(handler) ? handler : Function$1$1(handler);
        var args = arraySlice$3(arguments, 1);
        queue$2$1[++counter$1] = function() {
          apply$2(fn, void 0, args);
        };
        defer$1(counter$1);
        return counter$1;
      };
      clear$1 = function clearImmediate(id2) {
        delete queue$2$1[id2];
      };
      if (IS_NODE$3$1) {
        defer$1 = function(id2) {
          process$2$1.nextTick(runner$1(id2));
        };
      } else if (Dispatch$1 && Dispatch$1.now) {
        defer$1 = function(id2) {
          Dispatch$1.now(runner$1(id2));
        };
      } else if (MessageChannel$1 && !IS_IOS$1$1) {
        channel$1 = new MessageChannel$1();
        port$1 = channel$1.port2;
        channel$1.port1.onmessage = eventListener$1;
        defer$1 = bind$3$1(port$1.postMessage, port$1);
      } else if (global$5$1.addEventListener && isCallable$3$1(global$5$1.postMessage) && !global$5$1.importScripts && $location$1 && $location$1.protocol !== "file:" && !fails$k(globalPostMessageDefer$1)) {
        defer$1 = globalPostMessageDefer$1;
        global$5$1.addEventListener("message", eventListener$1, false);
      } else if (ONREADYSTATECHANGE$1 in createElement$2("script")) {
        defer$1 = function(id2) {
          html$3.appendChild(createElement$2("script"))[ONREADYSTATECHANGE$1] = function() {
            html$3.removeChild(this);
            run$1(id2);
          };
        };
      } else {
        defer$1 = function(id2) {
          setTimeout(runner$1(id2), 0);
        };
      }
    }
    var task$1$1 = {
      set: set$2,
      clear: clear$1
    };
    var Queue$2$1 = function() {
      this.head = null;
      this.tail = null;
    };
    Queue$2$1.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null)
            this.tail = null;
          return entry.item;
        }
      }
    };
    var queue$1$1 = Queue$2$1;
    var userAgent$1$1 = engineUserAgent$1;
    var engineIsIosPebble$1 = /ipad|iphone|ipod/i.test(userAgent$1$1) && typeof Pebble != "undefined";
    var userAgent$4 = engineUserAgent$1;
    var engineIsWebosWebkit$1 = /web0s(?!.*chrome)/i.test(userAgent$4);
    var global$4$1 = global$h$1;
    var bind$2$1 = functionBindContext$1;
    var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor$1.f;
    var macrotask$1 = task$1$1.set;
    var Queue$1$1 = queue$1$1;
    var IS_IOS$2 = engineIsIos$1;
    var IS_IOS_PEBBLE$1 = engineIsIosPebble$1;
    var IS_WEBOS_WEBKIT$1 = engineIsWebosWebkit$1;
    var IS_NODE$2$1 = engineIsNode$1;
    var MutationObserver$2 = global$4$1.MutationObserver || global$4$1.WebKitMutationObserver;
    var document$2$1 = global$4$1.document;
    var process$1$1 = global$4$1.process;
    var Promise$1$1 = global$4$1.Promise;
    var queueMicrotaskDescriptor$1 = getOwnPropertyDescriptor$3(global$4$1, "queueMicrotask");
    var microtask$1$1 = queueMicrotaskDescriptor$1 && queueMicrotaskDescriptor$1.value;
    var notify$1$1, toggle$1, node$1, promise$1, then$1;
    if (!microtask$1$1) {
      var queue$3 = new Queue$1$1();
      var flush$1 = function() {
        var parent, fn;
        if (IS_NODE$2$1 && (parent = process$1$1.domain))
          parent.exit();
        while (fn = queue$3.get())
          try {
            fn();
          } catch (error) {
            if (queue$3.head)
              notify$1$1();
            throw error;
          }
        if (parent)
          parent.enter();
      };
      if (!IS_IOS$2 && !IS_NODE$2$1 && !IS_WEBOS_WEBKIT$1 && MutationObserver$2 && document$2$1) {
        toggle$1 = true;
        node$1 = document$2$1.createTextNode("");
        new MutationObserver$2(flush$1).observe(node$1, { characterData: true });
        notify$1$1 = function() {
          node$1.data = toggle$1 = !toggle$1;
        };
      } else if (!IS_IOS_PEBBLE$1 && Promise$1$1 && Promise$1$1.resolve) {
        promise$1 = Promise$1$1.resolve(void 0);
        promise$1.constructor = Promise$1$1;
        then$1 = bind$2$1(promise$1.then, promise$1);
        notify$1$1 = function() {
          then$1(flush$1);
        };
      } else if (IS_NODE$2$1) {
        notify$1$1 = function() {
          process$1$1.nextTick(flush$1);
        };
      } else {
        macrotask$1 = bind$2$1(macrotask$1, global$4$1);
        notify$1$1 = function() {
          macrotask$1(flush$1);
        };
      }
      microtask$1$1 = function(fn) {
        if (!queue$3.head)
          notify$1$1();
        queue$3.add(fn);
      };
    }
    var microtask_1$1 = microtask$1$1;
    var hostReportErrors$1$1 = function(a2, b) {
      try {
        arguments.length === 1 ? console.error(a2) : console.error(a2, b);
      } catch (error) {
      }
    };
    var perform$3$1 = function(exec2) {
      try {
        return { error: false, value: exec2() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
    var global$3$1 = global$h$1;
    var promiseNativeConstructor$1 = global$3$1.Promise;
    var engineIsDeno$1 = typeof Deno == "object" && Deno && typeof Deno.version == "object";
    var IS_DENO$1$1 = engineIsDeno$1;
    var IS_NODE$1$1 = engineIsNode$1;
    var engineIsBrowser$1 = !IS_DENO$1$1 && !IS_NODE$1$1 && typeof window == "object" && typeof document == "object";
    var global$2$1 = global$h$1;
    var NativePromiseConstructor$3$1 = promiseNativeConstructor$1;
    var isCallable$2$1 = isCallable$h$1;
    var isForced$4 = isForced_1$1;
    var inspectSource$4 = inspectSource$3$1;
    var wellKnownSymbol$3$1 = wellKnownSymbol$a$1;
    var IS_BROWSER$1 = engineIsBrowser$1;
    var IS_DENO$2 = engineIsDeno$1;
    var V8_VERSION$4 = engineV8Version$1;
    NativePromiseConstructor$3$1 && NativePromiseConstructor$3$1.prototype;
    var SPECIES$5 = wellKnownSymbol$3$1("species");
    var SUBCLASSING$1 = false;
    var NATIVE_PROMISE_REJECTION_EVENT$1$1 = isCallable$2$1(global$2$1.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR$5$1 = isForced$4("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource$4(NativePromiseConstructor$3$1);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3$1);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION$4 === 66)
        return true;
      if (!V8_VERSION$4 || V8_VERSION$4 < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise2 = new NativePromiseConstructor$3$1(function(resolve) {
          resolve(1);
        });
        var FakePromise = function(exec2) {
          exec2(function() {
          }, function() {
          });
        };
        var constructor = promise2.constructor = {};
        constructor[SPECIES$5] = FakePromise;
        SUBCLASSING$1 = promise2.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING$1)
          return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER$1 || IS_DENO$2) && !NATIVE_PROMISE_REJECTION_EVENT$1$1;
    });
    var promiseConstructorDetection$1 = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5$1,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1$1,
      SUBCLASSING: SUBCLASSING$1
    };
    var newPromiseCapability$2$1 = {};
    var aCallable$4$1 = aCallable$8$1;
    var $TypeError$2$1 = TypeError;
    var PromiseCapability$1 = function(C2) {
      var resolve, reject;
      this.promise = new C2(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0)
          throw new $TypeError$2$1("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable$4$1(resolve);
      this.reject = aCallable$4$1(reject);
    };
    newPromiseCapability$2$1.f = function(C2) {
      return new PromiseCapability$1(C2);
    };
    var $$5$1 = _export$1;
    var IS_NODE$4 = engineIsNode$1;
    var global$1$1 = global$h$1;
    var call$6$1 = functionCall$1;
    var defineBuiltIn$1$1 = defineBuiltIn$4$1;
    var setPrototypeOf$3 = objectSetPrototypeOf$1;
    var setToStringTag$6 = setToStringTag$1$1;
    var setSpecies$2 = setSpecies$1$1;
    var aCallable$3$1 = aCallable$8$1;
    var isCallable$1$1 = isCallable$h$1;
    var isObject$2$1 = isObject$8$1;
    var anInstance$4 = anInstance$1$1;
    var speciesConstructor$2 = speciesConstructor$1$1;
    var task$2 = task$1$1.set;
    var microtask$2 = microtask_1$1;
    var hostReportErrors$2 = hostReportErrors$1$1;
    var perform$2$1 = perform$3$1;
    var Queue$3 = queue$1$1;
    var InternalStateModule$5 = internalState$1;
    var NativePromiseConstructor$2$1 = promiseNativeConstructor$1;
    var PromiseConstructorDetection$1 = promiseConstructorDetection$1;
    var newPromiseCapabilityModule$3$1 = newPromiseCapability$2$1;
    var PROMISE$1 = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR$4$1 = PromiseConstructorDetection$1.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT$2 = PromiseConstructorDetection$1.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING$1 = PromiseConstructorDetection$1.SUBCLASSING;
    var getInternalPromiseState$1 = InternalStateModule$5.getterFor(PROMISE$1);
    var setInternalState$4 = InternalStateModule$5.set;
    var NativePromisePrototype$1$1 = NativePromiseConstructor$2$1 && NativePromiseConstructor$2$1.prototype;
    var PromiseConstructor$1 = NativePromiseConstructor$2$1;
    var PromisePrototype$1 = NativePromisePrototype$1$1;
    var TypeError$1$1 = global$1$1.TypeError;
    var document$1$1 = global$1$1.document;
    var process$4 = global$1$1.process;
    var newPromiseCapability$1$1 = newPromiseCapabilityModule$3$1.f;
    var newGenericPromiseCapability$1 = newPromiseCapability$1$1;
    var DISPATCH_EVENT$1 = !!(document$1$1 && document$1$1.createEvent && global$1$1.dispatchEvent);
    var UNHANDLED_REJECTION$1 = "unhandledrejection";
    var REJECTION_HANDLED$1 = "rejectionhandled";
    var PENDING$1 = 0;
    var FULFILLED$1 = 1;
    var REJECTED$1 = 2;
    var HANDLED$1 = 1;
    var UNHANDLED$1 = 2;
    var Internal$1, OwnPromiseCapability$1, PromiseWrapper$1, nativeThen$1;
    var isThenable$1 = function(it) {
      var then2;
      return isObject$2$1(it) && isCallable$1$1(then2 = it.then) ? then2 : false;
    };
    var callReaction$1 = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED$1;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then2, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED$1)
              onHandleUnhandled$1(state);
            state.rejection = HANDLED$1;
          }
          if (handler === true)
            result = value;
          else {
            if (domain)
              domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError$1$1("Promise-chain cycle"));
          } else if (then2 = isThenable$1(result)) {
            call$6$1(then2, result, resolve, reject);
          } else
            resolve(result);
        } else
          reject(value);
      } catch (error) {
        if (domain && !exited)
          domain.exit();
        reject(error);
      }
    };
    var notify$2 = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      microtask$2(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction$1(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled$1(state);
      });
    };
    var dispatchEvent$1 = function(name, promise2, reason) {
      var event, handler;
      if (DISPATCH_EVENT$1) {
        event = document$1$1.createEvent("Event");
        event.promise = promise2;
        event.reason = reason;
        event.initEvent(name, false, true);
        global$1$1.dispatchEvent(event);
      } else
        event = { promise: promise2, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT$2 && (handler = global$1$1["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION$1)
        hostReportErrors$2("Unhandled promise rejection", reason);
    };
    var onUnhandled$1 = function(state) {
      call$6$1(task$2, global$1$1, function() {
        var promise2 = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled$1(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform$2$1(function() {
            if (IS_NODE$4) {
              process$4.emit("unhandledRejection", value, promise2);
            } else
              dispatchEvent$1(UNHANDLED_REJECTION$1, promise2, value);
          });
          state.rejection = IS_NODE$4 || isUnhandled$1(state) ? UNHANDLED$1 : HANDLED$1;
          if (result.error)
            throw result.value;
        }
      });
    };
    var isUnhandled$1 = function(state) {
      return state.rejection !== HANDLED$1 && !state.parent;
    };
    var onHandleUnhandled$1 = function(state) {
      call$6$1(task$2, global$1$1, function() {
        var promise2 = state.facade;
        if (IS_NODE$4) {
          process$4.emit("rejectionHandled", promise2);
        } else
          dispatchEvent$1(REJECTION_HANDLED$1, promise2, state.value);
      });
    };
    var bind$1$1 = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject$1 = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED$1;
      notify$2(state, true);
    };
    var internalResolve$1 = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw new TypeError$1$1("Promise can't be resolved itself");
        var then2 = isThenable$1(value);
        if (then2) {
          microtask$2(function() {
            var wrapper = { done: false };
            try {
              call$6$1(
                then2,
                value,
                bind$1$1(internalResolve$1, wrapper, state),
                bind$1$1(internalReject$1, wrapper, state)
              );
            } catch (error) {
              internalReject$1(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED$1;
          notify$2(state, false);
        }
      } catch (error) {
        internalReject$1({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR$4$1) {
      PromiseConstructor$1 = function Promise2(executor) {
        anInstance$4(this, PromisePrototype$1);
        aCallable$3$1(executor);
        call$6$1(Internal$1, this);
        var state = getInternalPromiseState$1(this);
        try {
          executor(bind$1$1(internalResolve$1, state), bind$1$1(internalReject$1, state));
        } catch (error) {
          internalReject$1(state, error);
        }
      };
      PromisePrototype$1 = PromiseConstructor$1.prototype;
      Internal$1 = function Promise2(executor) {
        setInternalState$4(this, {
          type: PROMISE$1,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue$3(),
          rejection: false,
          state: PENDING$1,
          value: void 0
        });
      };
      Internal$1.prototype = defineBuiltIn$1$1(PromisePrototype$1, "then", function then2(onFulfilled, onRejected) {
        var state = getInternalPromiseState$1(this);
        var reaction = newPromiseCapability$1$1(speciesConstructor$2(this, PromiseConstructor$1));
        state.parent = true;
        reaction.ok = isCallable$1$1(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable$1$1(onRejected) && onRejected;
        reaction.domain = IS_NODE$4 ? process$4.domain : void 0;
        if (state.state === PENDING$1)
          state.reactions.add(reaction);
        else
          microtask$2(function() {
            callReaction$1(reaction, state);
          });
        return reaction.promise;
      });
      OwnPromiseCapability$1 = function() {
        var promise2 = new Internal$1();
        var state = getInternalPromiseState$1(promise2);
        this.promise = promise2;
        this.resolve = bind$1$1(internalResolve$1, state);
        this.reject = bind$1$1(internalReject$1, state);
      };
      newPromiseCapabilityModule$3$1.f = newPromiseCapability$1$1 = function(C2) {
        return C2 === PromiseConstructor$1 || C2 === PromiseWrapper$1 ? new OwnPromiseCapability$1(C2) : newGenericPromiseCapability$1(C2);
      };
      if (isCallable$1$1(NativePromiseConstructor$2$1) && NativePromisePrototype$1$1 !== Object.prototype) {
        nativeThen$1 = NativePromisePrototype$1$1.then;
        if (!NATIVE_PROMISE_SUBCLASSING$1) {
          defineBuiltIn$1$1(NativePromisePrototype$1$1, "then", function then2(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor$1(function(resolve, reject) {
              call$6$1(nativeThen$1, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype$1$1.constructor;
        } catch (error) {
        }
        if (setPrototypeOf$3) {
          setPrototypeOf$3(NativePromisePrototype$1$1, PromisePrototype$1);
        }
      }
    }
    $$5$1({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4$1 }, {
      Promise: PromiseConstructor$1
    });
    setToStringTag$6(PromiseConstructor$1, PROMISE$1, false);
    setSpecies$2(PROMISE$1);
    var iterators$1 = {};
    var wellKnownSymbol$2$1 = wellKnownSymbol$a$1;
    var Iterators$1$1 = iterators$1;
    var ITERATOR$2$1 = wellKnownSymbol$2$1("iterator");
    var ArrayPrototype$2 = Array.prototype;
    var isArrayIteratorMethod$1$1 = function(it) {
      return it !== void 0 && (Iterators$1$1.Array === it || ArrayPrototype$2[ITERATOR$2$1] === it);
    };
    var classof$a = classof$4$1;
    var getMethod$1$1 = getMethod$3$1;
    var isNullOrUndefined$7 = isNullOrUndefined$4$1;
    var Iterators$5 = iterators$1;
    var wellKnownSymbol$1$1 = wellKnownSymbol$a$1;
    var ITERATOR$1$1 = wellKnownSymbol$1$1("iterator");
    var getIteratorMethod$2$1 = function(it) {
      if (!isNullOrUndefined$7(it))
        return getMethod$1$1(it, ITERATOR$1$1) || getMethod$1$1(it, "@@iterator") || Iterators$5[classof$a(it)];
    };
    var call$5$1 = functionCall$1;
    var aCallable$2$1 = aCallable$8$1;
    var anObject$3$1 = anObject$8$1;
    var tryToString$1$1 = tryToString$4$1;
    var getIteratorMethod$1$1 = getIteratorMethod$2$1;
    var $TypeError$1$1 = TypeError;
    var getIterator$1$1 = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1$1(argument) : usingIterator;
      if (aCallable$2$1(iteratorMethod))
        return anObject$3$1(call$5$1(iteratorMethod, argument));
      throw new $TypeError$1$1(tryToString$1$1(argument) + " is not iterable");
    };
    var call$4$1 = functionCall$1;
    var anObject$2$1 = anObject$8$1;
    var getMethod$4 = getMethod$3$1;
    var iteratorClose$1$1 = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject$2$1(iterator);
      try {
        innerResult = getMethod$4(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call$4$1(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject$2$1(innerResult);
      return value;
    };
    var bind$6 = functionBindContext$1;
    var call$3$1 = functionCall$1;
    var anObject$1$1 = anObject$8$1;
    var tryToString$5 = tryToString$4$1;
    var isArrayIteratorMethod$2 = isArrayIteratorMethod$1$1;
    var lengthOfArrayLike$6 = lengthOfArrayLike$2$1;
    var isPrototypeOf$3 = objectIsPrototypeOf$1;
    var getIterator$2 = getIterator$1$1;
    var getIteratorMethod$3 = getIteratorMethod$2$1;
    var iteratorClose$2 = iteratorClose$1$1;
    var $TypeError$e = TypeError;
    var Result$1 = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype$1 = Result$1.prototype;
    var iterate$2$1 = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind$6(unboundFunction, that);
      var iterator, iterFn, index, length2, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose$2(iterator, "normal", condition);
        return new Result$1(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject$1$1(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod$3(iterable);
        if (!iterFn)
          throw new $TypeError$e(tryToString$5(iterable) + " is not iterable");
        if (isArrayIteratorMethod$2(iterFn)) {
          for (index = 0, length2 = lengthOfArrayLike$6(iterable); length2 > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf$3(ResultPrototype$1, result))
              return result;
          }
          return new Result$1(false);
        }
        iterator = getIterator$2(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call$3$1(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose$2(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf$3(ResultPrototype$1, result))
          return result;
      }
      return new Result$1(false);
    };
    var wellKnownSymbol$i = wellKnownSymbol$a$1;
    var ITERATOR$6 = wellKnownSymbol$i("iterator");
    var SAFE_CLOSING$1 = false;
    try {
      var called$1 = 0;
      var iteratorWithReturn$1 = {
        next: function() {
          return { done: !!called$1++ };
        },
        "return": function() {
          SAFE_CLOSING$1 = true;
        }
      };
      iteratorWithReturn$1[ITERATOR$6] = function() {
        return this;
      };
      Array.from(iteratorWithReturn$1, function() {
        throw 2;
      });
    } catch (error) {
    }
    var checkCorrectnessOfIteration$1$1 = function(exec2, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING$1)
          return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object2 = {};
        object2[ITERATOR$6] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec2(object2);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
    var NativePromiseConstructor$1$1 = promiseNativeConstructor$1;
    var checkCorrectnessOfIteration$3 = checkCorrectnessOfIteration$1$1;
    var FORCED_PROMISE_CONSTRUCTOR$3$1 = promiseConstructorDetection$1.CONSTRUCTOR;
    var promiseStaticsIncorrectIteration$1 = FORCED_PROMISE_CONSTRUCTOR$3$1 || !checkCorrectnessOfIteration$3(function(iterable) {
      NativePromiseConstructor$1$1.all(iterable).then(void 0, function() {
      });
    });
    var $$4$1 = _export$1;
    var call$2$1 = functionCall$1;
    var aCallable$1$1 = aCallable$8$1;
    var newPromiseCapabilityModule$2$1 = newPromiseCapability$2$1;
    var perform$1$1 = perform$3$1;
    var iterate$1$1 = iterate$2$1;
    var PROMISE_STATICS_INCORRECT_ITERATION$1$1 = promiseStaticsIncorrectIteration$1;
    $$4$1({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1$1 }, {
      all: function all(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule$2$1.f(C2);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform$1$1(function() {
          var $promiseResolve = aCallable$1$1(C2.resolve);
          var values2 = [];
          var counter2 = 0;
          var remaining = 1;
          iterate$1$1(iterable, function(promise2) {
            var index = counter2++;
            var alreadyCalled = false;
            remaining++;
            call$2$1($promiseResolve, C2, promise2).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values2[index] = value;
              --remaining || resolve(values2);
            }, reject);
          });
          --remaining || resolve(values2);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
    var $$3$1 = _export$1;
    var FORCED_PROMISE_CONSTRUCTOR$2$1 = promiseConstructorDetection$1.CONSTRUCTOR;
    var NativePromiseConstructor$4 = promiseNativeConstructor$1;
    var getBuiltIn$1$1 = getBuiltIn$7$1;
    var isCallable$n = isCallable$h$1;
    var defineBuiltIn$9 = defineBuiltIn$4$1;
    var NativePromisePrototype$2 = NativePromiseConstructor$4 && NativePromiseConstructor$4.prototype;
    $$3$1({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2$1, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (isCallable$n(NativePromiseConstructor$4)) {
      var method$1 = getBuiltIn$1$1("Promise").prototype["catch"];
      if (NativePromisePrototype$2["catch"] !== method$1) {
        defineBuiltIn$9(NativePromisePrototype$2, "catch", method$1, { unsafe: true });
      }
    }
    var $$2$1 = _export$1;
    var call$1$1 = functionCall$1;
    var aCallable$9 = aCallable$8$1;
    var newPromiseCapabilityModule$1$1 = newPromiseCapability$2$1;
    var perform$4 = perform$3$1;
    var iterate$5 = iterate$2$1;
    var PROMISE_STATICS_INCORRECT_ITERATION$2 = promiseStaticsIncorrectIteration$1;
    $$2$1({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$2 }, {
      race: function race(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule$1$1.f(C2);
        var reject = capability.reject;
        var result = perform$4(function() {
          var $promiseResolve = aCallable$9(C2.resolve);
          iterate$5(iterable, function(promise2) {
            call$1$1($promiseResolve, C2, promise2).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
    var $$1$1 = _export$1;
    var call$f = functionCall$1;
    var newPromiseCapabilityModule$4 = newPromiseCapability$2$1;
    var FORCED_PROMISE_CONSTRUCTOR$1$1 = promiseConstructorDetection$1.CONSTRUCTOR;
    $$1$1({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1$1 }, {
      reject: function reject(r) {
        var capability = newPromiseCapabilityModule$4.f(this);
        call$f(capability.reject, void 0, r);
        return capability.promise;
      }
    });
    var anObject$c = anObject$8$1;
    var isObject$1$1 = isObject$8$1;
    var newPromiseCapability$3 = newPromiseCapability$2$1;
    var promiseResolve$1$1 = function(C2, x) {
      anObject$c(C2);
      if (isObject$1$1(x) && x.constructor === C2)
        return x;
      var promiseCapability = newPromiseCapability$3.f(C2);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };
    var $$b = _export$1;
    var getBuiltIn$8 = getBuiltIn$7$1;
    var FORCED_PROMISE_CONSTRUCTOR$6 = promiseConstructorDetection$1.CONSTRUCTOR;
    var promiseResolve$2 = promiseResolve$1$1;
    getBuiltIn$8("Promise");
    $$b({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$6 }, {
      resolve: function resolve(x) {
        return promiseResolve$2(this, x);
      }
    });
    function defined(x) {
      return x != null && !Number.isNaN(x);
    }
    function ascendingDefined(a2, b) {
      return +defined(b) - +defined(a2) || ascending$1(a2, b);
    }
    function finite(x) {
      return isFinite(x) ? x : NaN;
    }
    function positive(x) {
      return x > 0 && isFinite(x) ? x : NaN;
    }
    function negative(x) {
      return x < 0 && isFinite(x) ? x : NaN;
    }
    function format(date2, fallback) {
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      if (isNaN(date2))
        return typeof fallback === "function" ? fallback(date2) : fallback;
      const hours = date2.getUTCHours();
      const minutes = date2.getUTCMinutes();
      const seconds = date2.getUTCSeconds();
      const milliseconds = date2.getUTCMilliseconds();
      return `${formatYear(date2.getUTCFullYear())}-${pad(date2.getUTCMonth() + 1, 2)}-${pad(date2.getUTCDate(), 2)}${hours || minutes || seconds || milliseconds ? `T${pad(hours, 2)}:${pad(minutes, 2)}${seconds || milliseconds ? `:${pad(seconds, 2)}${milliseconds ? `.${pad(milliseconds, 3)}` : ``}` : ``}Z` : ``}`;
    }
    function formatYear(year) {
      return year < 0 ? `-${pad(-year, 6)}` : year > 9999 ? `+${pad(year, 6)}` : pad(year, 4);
    }
    function pad(value, width) {
      return `${value}`.padStart(width, "0");
    }
    const re = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
    function parse(string2, fallback) {
      if (!re.test(string2 += ""))
        return typeof fallback === "function" ? fallback(string2) : fallback;
      return new Date(string2);
    }
    const timeIntervals = /* @__PURE__ */ new Map([
      ["second", second],
      ["minute", timeMinute],
      ["hour", timeHour],
      ["day", timeDay],
      ["week", timeSunday],
      ["month", timeMonth],
      ["quarter", timeMonth.every(3)],
      ["half", timeMonth.every(6)],
      ["year", timeYear],
      ["monday", timeMonday],
      ["tuesday", timeTuesday],
      ["wednesday", timeWednesday],
      ["thursday", timeThursday],
      ["friday", timeFriday],
      ["saturday", timeSaturday],
      ["sunday", timeSunday]
    ]);
    const utcIntervals = /* @__PURE__ */ new Map([
      ["second", second],
      ["minute", utcMinute],
      ["hour", utcHour],
      ["day", utcDay],
      ["week", utcSunday],
      ["month", utcMonth],
      ["quarter", utcMonth.every(3)],
      ["half", utcMonth.every(6)],
      ["year", utcYear],
      ["monday", utcMonday],
      ["tuesday", utcTuesday],
      ["wednesday", utcWednesday],
      ["thursday", utcThursday],
      ["friday", utcFriday],
      ["saturday", utcSaturday],
      ["sunday", utcSunday]
    ]);
    function maybeTimeInterval(interval2) {
      const i = timeIntervals.get(`${interval2}`.toLowerCase());
      if (!i)
        throw new Error(`unknown interval: ${interval2}`);
      return i;
    }
    function maybeUtcInterval(interval2) {
      const i = utcIntervals.get(`${interval2}`.toLowerCase());
      if (!i)
        throw new Error(`unknown interval: ${interval2}`);
      return i;
    }
    const TypedArray = Object.getPrototypeOf(Uint8Array);
    const objectToString$2 = Object.prototype.toString;
    const string = (x) => x == null ? x : `${x}`;
    const constant = (x) => () => x;
    function coerceNumbers(values2) {
      return values2 instanceof TypedArray ? values2 : map(values2, coerceNumber, Float64Array);
    }
    function coerceNumber(x) {
      return x == null ? NaN : Number(x);
    }
    function coerceDates(values2) {
      return map(values2, coerceDate);
    }
    function coerceDate(x) {
      return x instanceof Date && !isNaN(x) ? x : typeof x === "string" ? parse(x) : x == null || isNaN(x = +x) ? void 0 : new Date(x);
    }
    function maybeColorChannel(value, defaultValue) {
      if (value === void 0)
        value = defaultValue;
      return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
    }
    function maybeNumberChannel(value, defaultValue) {
      if (value === void 0)
        value = defaultValue;
      return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
    }
    function arrayify(data2) {
      return data2 == null || data2 instanceof Array || data2 instanceof TypedArray ? data2 : Array.from(data2);
    }
    function map(values2, f, type = Array) {
      return values2 == null ? values2 : values2 instanceof type ? values2.map(f) : type.from(values2, f);
    }
    function slice(values2, type = Array) {
      return values2 instanceof type ? values2.slice() : type.from(values2);
    }
    function isObject$g(option) {
      return (option == null ? void 0 : option.toString) === objectToString$2;
    }
    function isScaleOptions(option) {
      return isObject$g(option) && (option.type !== void 0 || option.domain !== void 0);
    }
    function maybeInterval(interval2, type) {
      if (interval2 == null)
        return;
      if (typeof interval2 === "number") {
        if (0 < interval2 && interval2 < 1 && Number.isInteger(1 / interval2))
          interval2 = -1 / interval2;
        const n = Math.abs(interval2);
        return interval2 < 0 ? {
          floor: (d) => Math.floor(d * n) / n,
          offset: (d) => (d * n + 1) / n,
          // note: no optional step for simplicity
          range: (lo, hi) => range(Math.ceil(lo * n), hi * n).map((x) => x / n)
        } : {
          floor: (d) => Math.floor(d / n) * n,
          offset: (d) => d + n,
          // note: no optional step for simplicity
          range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x) => x * n)
        };
      }
      if (typeof interval2 === "string")
        return (type === "time" ? maybeTimeInterval : maybeUtcInterval)(interval2);
      if (typeof interval2.floor !== "function")
        throw new Error("invalid interval; missing floor method");
      if (typeof interval2.offset !== "function")
        throw new Error("invalid interval; missing offset method");
      return interval2;
    }
    function maybeRangeInterval(interval2, type) {
      interval2 = maybeInterval(interval2, type);
      if (interval2 && typeof interval2.range !== "function")
        throw new Error("invalid interval: missing range method");
      return interval2;
    }
    function maybeNiceInterval(interval2, type) {
      interval2 = maybeRangeInterval(interval2, type);
      if (interval2 && typeof interval2.ceil !== "function")
        throw new Error("invalid interval: missing ceil method");
      return interval2;
    }
    function isOrdinal(values2) {
      for (const value of values2) {
        if (value == null)
          continue;
        const type = typeof value;
        return type === "string" || type === "boolean";
      }
    }
    function isTemporal(values2) {
      for (const value of values2) {
        if (value == null)
          continue;
        return value instanceof Date;
      }
    }
    function isTemporalString(values2) {
      for (const value of values2) {
        if (value == null)
          continue;
        return typeof value === "string" && isNaN(value) && parse(value);
      }
    }
    function isNumericString(values2) {
      for (const value of values2) {
        if (value == null)
          continue;
        if (typeof value !== "string")
          return false;
        if (!value.trim())
          continue;
        return !isNaN(value);
      }
    }
    function isColor(value) {
      if (typeof value !== "string")
        return false;
      value = value.toLowerCase().trim();
      return value === "none" || value === "currentcolor" || value.startsWith("url(") && value.endsWith(")") || // <funciri>, e.g. pattern or gradient
      value.startsWith("var(") && value.endsWith(")") || // CSS variable
      color$2(value) !== null;
    }
    function isNoneish(value) {
      return value == null || isNone(value);
    }
    function isNone(value) {
      return /^\s*none\s*$/i.test(value);
    }
    function orderof(values2) {
      if (values2 == null)
        return;
      const first = values2[0];
      const last = values2[values2.length - 1];
      return descending(first, last);
    }
    function inherit(options = {}, ...rest) {
      let o = options;
      for (const defaults of rest) {
        for (const key in defaults) {
          if (o[key] === void 0) {
            const value = defaults[key];
            if (o === options)
              o = { ...o, [key]: value };
            else
              o[key] = value;
          }
        }
      }
      return o;
    }
    const position = Symbol("position");
    const color = Symbol("color");
    const radius = Symbol("radius");
    const length = Symbol("length");
    const opacity = Symbol("opacity");
    const symbol = Symbol("symbol");
    const registry = /* @__PURE__ */ new Map([
      ["x", position],
      ["y", position],
      ["fx", position],
      ["fy", position],
      ["r", radius],
      ["color", color],
      ["opacity", opacity],
      ["symbol", symbol],
      ["length", length]
    ]);
    const sqrt3 = Math.sqrt(3);
    const sqrt4_3 = 2 / sqrt3;
    const symbolHexagon = {
      draw(context, size) {
        const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
        context.moveTo(0, ry);
        context.lineTo(rx, hy);
        context.lineTo(rx, -hy);
        context.lineTo(0, -ry);
        context.lineTo(-rx, -hy);
        context.lineTo(-rx, hy);
        context.closePath();
      }
    };
    const symbols = /* @__PURE__ */ new Map([
      ["asterisk", symbolAsterisk],
      ["circle", symbolCircle],
      ["cross", symbolCross],
      ["diamond", symbolDiamond],
      ["diamond2", symbolDiamond2],
      ["hexagon", symbolHexagon],
      ["plus", symbolPlus],
      ["square", symbolSquare],
      ["square2", symbolSquare2],
      ["star", symbolStar],
      ["times", symbolTimes],
      ["triangle", symbolTriangle],
      ["triangle2", symbolTriangle2],
      ["wye", symbolWye]
    ]);
    function isSymbolObject(value) {
      return value && typeof value.draw === "function";
    }
    function maybeSymbol(symbol2) {
      if (symbol2 == null || isSymbolObject(symbol2))
        return symbol2;
      const value = symbols.get(`${symbol2}`.toLowerCase());
      if (value)
        return value;
      throw new Error(`invalid symbol: ${symbol2}`);
    }
    function warn(message) {
      console.warn(message);
    }
    const pi = Math.PI;
    const tau = 2 * pi;
    function createProjection({
      projection: projection2,
      inset: globalInset = 0,
      insetTop = globalInset,
      insetRight = globalInset,
      insetBottom = globalInset,
      insetLeft = globalInset
    } = {}, dimensions) {
      if (projection2 == null)
        return;
      if (typeof projection2.stream === "function")
        return projection2;
      let options;
      let domain;
      let clip2 = "frame";
      if (isObject$g(projection2)) {
        let inset;
        ({
          type: projection2,
          domain,
          inset,
          insetTop = inset !== void 0 ? inset : insetTop,
          insetRight = inset !== void 0 ? inset : insetRight,
          insetBottom = inset !== void 0 ? inset : insetBottom,
          insetLeft = inset !== void 0 ? inset : insetLeft,
          clip: clip2 = clip2,
          ...options
        } = projection2);
        if (projection2 == null)
          return;
      }
      if (typeof projection2 !== "function")
        ({ type: projection2 } = namedProjection(projection2));
      const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
      const dx = width - marginLeft - marginRight - insetLeft - insetRight;
      const dy = height - marginTop - marginBottom - insetTop - insetBottom;
      projection2 = projection2 == null ? void 0 : projection2({ width: dx, height: dy, clip: clip2, ...options });
      if (projection2 == null)
        return;
      clip2 = maybePostClip(clip2, marginLeft, marginTop, width - marginRight, height - marginBottom);
      let tx = marginLeft + insetLeft;
      let ty = marginTop + insetTop;
      let transform;
      if (domain != null) {
        const [[x02, y02], [x12, y12]] = geoPath(projection2).bounds(domain);
        const k2 = Math.min(dx / (x12 - x02), dy / (y12 - y02));
        if (k2 > 0) {
          tx -= (k2 * (x02 + x12) - dx) / 2;
          ty -= (k2 * (y02 + y12) - dy) / 2;
          transform = geoTransform({
            point(x, y) {
              this.stream.point(x * k2 + tx, y * k2 + ty);
            }
          });
        } else {
          warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
        }
      }
      transform ?? (transform = tx === 0 && ty === 0 ? identity() : geoTransform({
        point(x, y) {
          this.stream.point(x + tx, y + ty);
        }
      }));
      return { stream: (s2) => projection2.stream(transform.stream(clip2(s2))) };
    }
    function namedProjection(projection2) {
      switch (`${projection2}`.toLowerCase()) {
        case "albers-usa":
          return scaleProjection(geoAlbersUsa, 0.7463, 0.4673);
        case "albers":
          return conicProjection(geoAlbers, 0.7463, 0.4673);
        case "azimuthal-equal-area":
          return scaleProjection(geoAzimuthalEqualArea, 4, 4);
        case "azimuthal-equidistant":
          return scaleProjection(geoAzimuthalEquidistant, tau, tau);
        case "conic-conformal":
          return conicProjection(geoConicConformal, tau, tau);
        case "conic-equal-area":
          return conicProjection(geoConicEqualArea, 6.1702, 2.9781);
        case "conic-equidistant":
          return conicProjection(geoConicEquidistant, 7.312, 3.6282);
        case "equal-earth":
          return scaleProjection(geoEqualEarth, 5.4133, 2.6347);
        case "equirectangular":
          return scaleProjection(geoEquirectangular, tau, pi);
        case "gnomonic":
          return scaleProjection(geoGnomonic, 3.4641, 3.4641);
        case "identity":
          return { type: identity };
        case "reflect-y":
          return { type: reflectY };
        case "mercator":
          return scaleProjection(geoMercator, tau, tau);
        case "orthographic":
          return scaleProjection(geoOrthographic, 2, 2);
        case "stereographic":
          return scaleProjection(geoStereographic, 2, 2);
        case "transverse-mercator":
          return scaleProjection(geoTransverseMercator, tau, tau);
        default:
          throw new Error(`unknown projection type: ${projection2}`);
      }
    }
    function maybePostClip(clip2, x12, y12, x2, y2) {
      if (clip2 === false || clip2 == null || typeof clip2 === "number")
        return (s2) => s2;
      if (clip2 === true)
        clip2 = "frame";
      switch (`${clip2}`.toLowerCase()) {
        case "frame":
          return clipRectangle(x12, y12, x2, y2);
        default:
          throw new Error(`unknown projection clip type: ${clip2}`);
      }
    }
    function scaleProjection(createProjection2, kx2, ky2) {
      return {
        type: ({ width, height, rotate, precision = 0.15, clip: clip2 }) => {
          var _a, _b, _c;
          const projection2 = createProjection2();
          if (precision != null)
            (_a = projection2.precision) == null ? void 0 : _a.call(projection2, precision);
          if (rotate != null)
            (_b = projection2.rotate) == null ? void 0 : _b.call(projection2, rotate);
          if (typeof clip2 === "number")
            (_c = projection2.clipAngle) == null ? void 0 : _c.call(projection2, clip2);
          projection2.scale(Math.min(width / kx2, height / ky2));
          projection2.translate([width / 2, height / 2]);
          return projection2;
        },
        aspectRatio: ky2 / kx2
      };
    }
    function conicProjection(createProjection2, kx2, ky2) {
      const { type, aspectRatio } = scaleProjection(createProjection2, kx2, ky2);
      return {
        type: (options) => {
          const { parallels, domain, width, height } = options;
          const projection2 = type(options);
          if (parallels != null) {
            projection2.parallels(parallels);
            if (domain === void 0) {
              projection2.fitSize([width, height], { type: "Sphere" });
            }
          }
          return projection2;
        },
        aspectRatio
      };
    }
    const identity = constant({ stream: (stream) => stream });
    const reflectY = constant(
      geoTransform({
        point(x, y) {
          this.stream.point(x, -y);
        }
      })
    );
    function createContext(options = {}, dimensions, className) {
      const { document: document2 = typeof window !== "undefined" ? window.document : void 0 } = options;
      return { document: document2, className, projection: createProjection(options, dimensions) };
    }
    function create$2(name, { document: document2 }) {
      return select$1(creator(name).call(document2.documentElement));
    }
    const ordinalSchemes = /* @__PURE__ */ new Map([
      // categorical
      ["accent", schemeAccent],
      ["category10", schemeCategory10],
      ["dark2", schemeDark2],
      ["paired", schemePaired],
      ["pastel1", schemePastel1],
      ["pastel2", schemePastel2],
      ["set1", schemeSet1],
      ["set2", schemeSet2],
      ["set3", schemeSet3],
      ["tableau10", schemeTableau10],
      // diverging
      ["brbg", scheme11(scheme$q, interpolateBrBG)],
      ["prgn", scheme11(scheme$p, interpolatePRGn)],
      ["piyg", scheme11(scheme$o, interpolatePiYG)],
      ["puor", scheme11(scheme$n, interpolatePuOr)],
      ["rdbu", scheme11(scheme$m, interpolateRdBu)],
      ["rdgy", scheme11(scheme$l, interpolateRdGy)],
      ["rdylbu", scheme11(scheme$k, interpolateRdYlBu)],
      ["rdylgn", scheme11(scheme$j, interpolateRdYlGn)],
      ["spectral", scheme11(scheme$i, interpolateSpectral)],
      // reversed diverging (for temperature data)
      ["burd", scheme11r(scheme$m, interpolateRdBu)],
      ["buylrd", scheme11r(scheme$k, interpolateRdYlBu)],
      // sequential (single-hue)
      ["blues", scheme9(scheme$5, interpolateBlues)],
      ["greens", scheme9(scheme$4, interpolateGreens)],
      ["greys", scheme9(scheme$3, interpolateGreys)],
      ["oranges", scheme9(scheme, interpolateOranges)],
      ["purples", scheme9(scheme$2, interpolatePurples)],
      ["reds", scheme9(scheme$1, interpolateReds)],
      // sequential (multi-hue)
      ["turbo", schemei(interpolateTurbo)],
      ["viridis", schemei(interpolateViridis)],
      ["magma", schemei(magma)],
      ["inferno", schemei(inferno)],
      ["plasma", schemei(plasma)],
      ["cividis", schemei(interpolateCividis)],
      ["cubehelix", schemei(interpolateCubehelixDefault)],
      ["warm", schemei(warm)],
      ["cool", schemei(cool)],
      ["bugn", scheme9(scheme$h, interpolateBuGn)],
      ["bupu", scheme9(scheme$g, interpolateBuPu)],
      ["gnbu", scheme9(scheme$f, interpolateGnBu)],
      ["orrd", scheme9(scheme$e, interpolateOrRd)],
      ["pubu", scheme9(scheme$c, interpolatePuBu)],
      ["pubugn", scheme9(scheme$d, interpolatePuBuGn)],
      ["purd", scheme9(scheme$b, interpolatePuRd)],
      ["rdpu", scheme9(scheme$a, interpolateRdPu)],
      ["ylgn", scheme9(scheme$8, interpolateYlGn)],
      ["ylgnbu", scheme9(scheme$9, interpolateYlGnBu)],
      ["ylorbr", scheme9(scheme$7, interpolateYlOrBr)],
      ["ylorrd", scheme9(scheme$6, interpolateYlOrRd)],
      // cyclical
      ["rainbow", schemeicyclical(interpolateRainbow)],
      ["sinebow", schemeicyclical(interpolateSinebow)]
    ]);
    function scheme9(scheme2, interpolate2) {
      return ({ length: n }) => {
        if (n === 1)
          return [scheme2[3][1]];
        if (n === 2)
          return [scheme2[3][1], scheme2[3][2]];
        n = Math.max(3, Math.floor(n));
        return n > 9 ? quantize(interpolate2, n) : scheme2[n];
      };
    }
    function scheme11(scheme2, interpolate2) {
      return ({ length: n }) => {
        if (n === 2)
          return [scheme2[3][0], scheme2[3][2]];
        n = Math.max(3, Math.floor(n));
        return n > 11 ? quantize(interpolate2, n) : scheme2[n];
      };
    }
    function scheme11r(scheme2, interpolate2) {
      return ({ length: n }) => {
        if (n === 2)
          return [scheme2[3][2], scheme2[3][0]];
        n = Math.max(3, Math.floor(n));
        return n > 11 ? quantize((t) => interpolate2(1 - t), n) : scheme2[n].slice().reverse();
      };
    }
    function schemei(interpolate2) {
      return ({ length: n }) => quantize(interpolate2, Math.max(2, Math.floor(n)));
    }
    function schemeicyclical(interpolate2) {
      return ({ length: n }) => quantize(interpolate2, Math.floor(n) + 1).slice(0, -1);
    }
    function ordinalScheme(scheme2) {
      const s2 = `${scheme2}`.toLowerCase();
      if (!ordinalSchemes.has(s2))
        throw new Error(`unknown ordinal scheme: ${s2}`);
      return ordinalSchemes.get(s2);
    }
    function ordinalRange(scheme2, length2) {
      const s2 = ordinalScheme(scheme2);
      const r = typeof s2 === "function" ? s2({ length: length2 }) : s2;
      return r.length !== length2 ? r.slice(0, length2) : r;
    }
    function maybeBooleanRange(domain, scheme2 = "greys") {
      const range2 = /* @__PURE__ */ new Set();
      const [f, t] = ordinalRange(scheme2, 2);
      for (const value of domain) {
        if (value == null)
          continue;
        if (value === true)
          range2.add(t);
        else if (value === false)
          range2.add(f);
        else
          return;
      }
      return [...range2];
    }
    const quantitativeSchemes = /* @__PURE__ */ new Map([
      // diverging
      ["brbg", interpolateBrBG],
      ["prgn", interpolatePRGn],
      ["piyg", interpolatePiYG],
      ["puor", interpolatePuOr],
      ["rdbu", interpolateRdBu],
      ["rdgy", interpolateRdGy],
      ["rdylbu", interpolateRdYlBu],
      ["rdylgn", interpolateRdYlGn],
      ["spectral", interpolateSpectral],
      // reversed diverging (for temperature data)
      ["burd", (t) => interpolateRdBu(1 - t)],
      ["buylrd", (t) => interpolateRdYlBu(1 - t)],
      // sequential (single-hue)
      ["blues", interpolateBlues],
      ["greens", interpolateGreens],
      ["greys", interpolateGreys],
      ["purples", interpolatePurples],
      ["reds", interpolateReds],
      ["oranges", interpolateOranges],
      // sequential (multi-hue)
      ["turbo", interpolateTurbo],
      ["viridis", interpolateViridis],
      ["magma", magma],
      ["inferno", inferno],
      ["plasma", plasma],
      ["cividis", interpolateCividis],
      ["cubehelix", interpolateCubehelixDefault],
      ["warm", warm],
      ["cool", cool],
      ["bugn", interpolateBuGn],
      ["bupu", interpolateBuPu],
      ["gnbu", interpolateGnBu],
      ["orrd", interpolateOrRd],
      ["pubugn", interpolatePuBuGn],
      ["pubu", interpolatePuBu],
      ["purd", interpolatePuRd],
      ["rdpu", interpolateRdPu],
      ["ylgnbu", interpolateYlGnBu],
      ["ylgn", interpolateYlGn],
      ["ylorbr", interpolateYlOrBr],
      ["ylorrd", interpolateYlOrRd],
      // cyclical
      ["rainbow", interpolateRainbow],
      ["sinebow", interpolateSinebow]
    ]);
    function quantitativeScheme(scheme2) {
      const s2 = `${scheme2}`.toLowerCase();
      if (!quantitativeSchemes.has(s2))
        throw new Error(`unknown quantitative scheme: ${s2}`);
      return quantitativeSchemes.get(s2);
    }
    const divergingSchemes = /* @__PURE__ */ new Set([
      "brbg",
      "prgn",
      "piyg",
      "puor",
      "rdbu",
      "rdgy",
      "rdylbu",
      "rdylgn",
      "spectral",
      "burd",
      "buylrd"
    ]);
    function isDivergingScheme(scheme2) {
      return scheme2 != null && divergingSchemes.has(`${scheme2}`.toLowerCase());
    }
    const flip$2 = (i) => (t) => i(1 - t);
    const unit = [0, 1];
    const interpolators = /* @__PURE__ */ new Map([
      // numbers
      ["number", interpolateNumber],
      // color spaces
      ["rgb", interpolateRgb],
      ["hsl", interpolateHsl],
      ["hcl", interpolateHcl],
      ["lab", lab]
    ]);
    function maybeInterpolator(interpolate2) {
      const i = `${interpolate2}`.toLowerCase();
      if (!interpolators.has(i))
        throw new Error(`unknown interpolator: ${i}`);
      return interpolators.get(i);
    }
    function createScaleQ(key, scale2, channels, {
      type,
      nice: nice2,
      clamp,
      zero: zero2,
      domain = inferAutoDomain(key, channels),
      unknown,
      round: round2,
      scheme: scheme2,
      interval: interval2,
      range: range2 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit : void 0,
      interpolate: interpolate2 = registry.get(key) === color ? scheme2 == null && range2 !== void 0 ? interpolateRgb : quantitativeScheme(scheme2 !== void 0 ? scheme2 : type === "cyclical" ? "rainbow" : "turbo") : round2 ? interpolateRound : interpolateNumber,
      reverse: reverse$1
    }) {
      interval2 = maybeRangeInterval(interval2, type);
      if (type === "cyclical" || type === "sequential")
        type = "linear";
      reverse$1 = !!reverse$1;
      if (typeof interpolate2 !== "function") {
        interpolate2 = maybeInterpolator(interpolate2);
      }
      if (interpolate2.length === 1) {
        if (reverse$1) {
          interpolate2 = flip$2(interpolate2);
          reverse$1 = false;
        }
        if (range2 === void 0) {
          range2 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));
          if (range2.length === 2)
            range2 = unit;
        }
        scale2.interpolate((range2 === unit ? constant : interpolatePiecewise)(interpolate2));
      } else {
        scale2.interpolate(interpolate2);
      }
      if (zero2) {
        const [min2, max2] = extent(domain);
        if (min2 > 0 || max2 < 0) {
          domain = slice(domain);
          if (orderof(domain) !== Math.sign(min2))
            domain[domain.length - 1] = 0;
          else
            domain[0] = 0;
        }
      }
      if (reverse$1)
        domain = reverse(domain);
      scale2.domain(domain).unknown(unknown);
      if (nice2)
        scale2.nice(maybeNice(nice2, type)), domain = scale2.domain();
      if (range2 !== void 0)
        scale2.range(range2);
      if (clamp)
        scale2.clamp(clamp);
      return { type, domain, range: range2, scale: scale2, interpolate: interpolate2, interval: interval2 };
    }
    function maybeNice(nice2, type) {
      return nice2 === true ? void 0 : typeof nice2 === "number" ? nice2 : maybeNiceInterval(nice2, type);
    }
    function createScaleLinear(key, channels, options) {
      return createScaleQ(key, linear(), channels, options);
    }
    function createScaleSqrt(key, channels, options) {
      return createScalePow(key, channels, { ...options, exponent: 0.5 });
    }
    function createScalePow(key, channels, { exponent: exponent2 = 1, ...options }) {
      return createScaleQ(key, pow().exponent(exponent2), channels, { ...options, type: "pow" });
    }
    function createScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {
      return createScaleQ(key, log().base(base), channels, { ...options, domain });
    }
    function createScaleSymlog(key, channels, { constant: constant2 = 1, ...options }) {
      return createScaleQ(key, symlog().constant(constant2), channels, options);
    }
    function createScaleQuantile(key, channels, {
      range: range2,
      quantiles = range2 === void 0 ? 5 : (range2 = [...range2]).length,
      // deprecated; use n instead
      n = quantiles,
      scheme: scheme2 = "rdylbu",
      domain = inferQuantileDomain(channels),
      unknown,
      interpolate: interpolate2,
      reverse: reverse2
    }) {
      if (range2 === void 0) {
        range2 = interpolate2 !== void 0 ? quantize(interpolate2, n) : registry.get(key) === color ? ordinalRange(scheme2, n) : void 0;
      }
      if (domain.length > 0) {
        domain = quantile(domain, range2 === void 0 ? { length: n } : range2).quantiles();
      }
      return createScaleThreshold(key, channels, { domain, range: range2, reverse: reverse2, unknown });
    }
    function createScaleQuantize(key, channels, {
      range: range2,
      n = range2 === void 0 ? 5 : (range2 = [...range2]).length,
      scheme: scheme2 = "rdylbu",
      domain = inferAutoDomain(key, channels),
      unknown,
      interpolate: interpolate2,
      reverse: reverse2
    }) {
      const [min2, max2] = extent(domain);
      let thresholds;
      if (range2 === void 0) {
        thresholds = ticks(min2, max2, n);
        if (thresholds[0] <= min2)
          thresholds.splice(0, 1);
        if (thresholds[thresholds.length - 1] >= max2)
          thresholds.pop();
        n = thresholds.length + 1;
        range2 = interpolate2 !== void 0 ? quantize(interpolate2, n) : registry.get(key) === color ? ordinalRange(scheme2, n) : void 0;
      } else {
        thresholds = quantize(interpolateNumber(min2, max2), n + 1).slice(1, -1);
        if (min2 instanceof Date)
          thresholds = thresholds.map((x) => new Date(x));
      }
      if (orderof(arrayify(domain)) < 0)
        thresholds.reverse();
      return createScaleThreshold(key, channels, { domain: thresholds, range: range2, reverse: reverse2, unknown });
    }
    function createScaleThreshold(key, channels, {
      domain = [0],
      // explicit thresholds in ascending order
      unknown,
      scheme: scheme2 = "rdylbu",
      interpolate: interpolate2,
      range: range2 = interpolate2 !== void 0 ? quantize(interpolate2, domain.length + 1) : registry.get(key) === color ? ordinalRange(scheme2, domain.length + 1) : void 0,
      reverse: reverse$1
    }) {
      domain = arrayify(domain);
      const sign2 = orderof(domain);
      if (!isNaN(sign2) && !isOrdered(domain, sign2))
        throw new Error(`the ${key} scale has a non-monotonic domain`);
      if (reverse$1)
        range2 = reverse(range2);
      return {
        type: "threshold",
        scale: threshold(sign2 < 0 ? reverse(domain) : domain, range2 === void 0 ? [] : range2).unknown(unknown),
        domain,
        range: range2
      };
    }
    function isOrdered(domain, sign2) {
      for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {
        const s2 = descending(d, d = domain[i]);
        if (s2 !== 0 && s2 !== sign2)
          return false;
      }
      return true;
    }
    function createScaleIdentity() {
      return { type: "identity", scale: identity$2() };
    }
    function inferDomain$1(channels, f = finite) {
      return channels.length ? [
        min$6(channels, ({ value }) => value === void 0 ? value : min$6(value, f)),
        max$5(channels, ({ value }) => value === void 0 ? value : max$5(value, f))
      ] : [0, 1];
    }
    function inferAutoDomain(key, channels) {
      const type = registry.get(key);
      return (type === radius || type === opacity || type === length ? inferZeroDomain : inferDomain$1)(channels);
    }
    function inferZeroDomain(channels) {
      return [0, channels.length ? max$5(channels, ({ value }) => value === void 0 ? value : max$5(value, finite)) : 1];
    }
    function inferRadialRange(channels, domain) {
      const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
      if (hint !== void 0)
        return [0, hint.radius];
      const h25 = quantile$1(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile$1(value, 0.25, positive));
      const range2 = domain.map((d) => 3 * Math.sqrt(d / h25));
      const k2 = 30 / max$5(range2);
      return k2 < 1 ? range2.map((r) => r * k2) : range2;
    }
    function inferLengthRange(channels, domain) {
      const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));
      const range2 = domain.map((d) => 12 * d / h50);
      const k2 = 60 / max$5(range2);
      return k2 < 1 ? range2.map((r) => r * k2) : range2;
    }
    function inferLogDomain(channels) {
      for (const { value } of channels) {
        if (value !== void 0) {
          for (let v of value) {
            if (v > 0)
              return inferDomain$1(channels, positive);
            if (v < 0)
              return inferDomain$1(channels, negative);
          }
        }
      }
      return [1, 10];
    }
    function inferQuantileDomain(channels) {
      const domain = [];
      for (const { value } of channels) {
        if (value === void 0)
          continue;
        for (const v of value)
          domain.push(v);
      }
      return domain;
    }
    function interpolatePiecewise(interpolate2) {
      return (i, j) => (t) => interpolate2(i + t * (j - i));
    }
    function createScaleD(key, scale2, transform, channels, {
      type,
      nice: nice2,
      clamp,
      domain = inferDomain$1(channels),
      unknown,
      pivot = 0,
      scheme: scheme2,
      range: range2,
      symmetric = true,
      interpolate: interpolate2 = registry.get(key) === color ? scheme2 == null && range2 !== void 0 ? interpolateRgb : quantitativeScheme(scheme2 !== void 0 ? scheme2 : "rdbu") : interpolateNumber,
      reverse: reverse2
    }) {
      pivot = +pivot;
      let [min2, max2] = domain;
      if (descending(min2, max2) < 0)
        [min2, max2] = [max2, min2], reverse2 = !reverse2;
      min2 = Math.min(min2, pivot);
      max2 = Math.max(max2, pivot);
      if (typeof interpolate2 !== "function") {
        interpolate2 = maybeInterpolator(interpolate2);
      }
      if (range2 !== void 0) {
        interpolate2 = interpolate2.length === 1 ? interpolatePiecewise(interpolate2)(...range2) : piecewise(interpolate2, range2);
      }
      if (reverse2)
        interpolate2 = flip$2(interpolate2);
      if (symmetric) {
        const mid = transform.apply(pivot);
        const mindelta = mid - transform.apply(min2);
        const maxdelta = transform.apply(max2) - mid;
        if (mindelta < maxdelta)
          min2 = transform.invert(mid - maxdelta);
        else if (mindelta > maxdelta)
          max2 = transform.invert(mid + mindelta);
      }
      scale2.domain([min2, pivot, max2]).unknown(unknown).interpolator(interpolate2);
      if (clamp)
        scale2.clamp(clamp);
      if (nice2)
        scale2.nice(nice2);
      return { type, domain: [min2, max2], pivot, interpolate: interpolate2, scale: scale2 };
    }
    function createScaleDiverging(key, channels, options) {
      return createScaleD(key, diverging(), transformIdentity, channels, options);
    }
    function createScaleDivergingSqrt(key, channels, options) {
      return createScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });
    }
    function createScaleDivergingPow(key, channels, { exponent: exponent2 = 1, ...options }) {
      return createScaleD(key, divergingPow().exponent(exponent2 = +exponent2), transformPow(exponent2), channels, {
        ...options,
        type: "diverging-pow"
      });
    }
    function createScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain$1(channels, pivot < 0 ? negative : positive), ...options }) {
      return createScaleD(key, divergingLog().base(base = +base), transformLog, channels, {
        domain,
        pivot,
        ...options
      });
    }
    function createScaleDivergingSymlog(key, channels, { constant: constant2 = 1, ...options }) {
      return createScaleD(
        key,
        divergingSymlog().constant(constant2 = +constant2),
        transformSymlog(constant2),
        channels,
        options
      );
    }
    const transformIdentity = {
      apply(x) {
        return x;
      },
      invert(x) {
        return x;
      }
    };
    const transformLog = {
      apply: Math.log,
      invert: Math.exp
    };
    const transformSqrt = {
      apply(x) {
        return Math.sign(x) * Math.sqrt(Math.abs(x));
      },
      invert(x) {
        return Math.sign(x) * (x * x);
      }
    };
    function transformPow(exponent2) {
      return exponent2 === 0.5 ? transformSqrt : {
        apply(x) {
          return Math.sign(x) * Math.pow(Math.abs(x), exponent2);
        },
        invert(x) {
          return Math.sign(x) * Math.pow(Math.abs(x), 1 / exponent2);
        }
      };
    }
    function transformSymlog(constant2) {
      return {
        apply(x) {
          return Math.sign(x) * Math.log1p(Math.abs(x / constant2));
        },
        invert(x) {
          return Math.sign(x) * Math.expm1(Math.abs(x)) * constant2;
        }
      };
    }
    function createScaleT(key, scale2, channels, options) {
      return createScaleQ(key, scale2, channels, options);
    }
    function createScaleTime(key, channels, options) {
      return createScaleT(key, time(), channels, options);
    }
    function createScaleUtc(key, channels, options) {
      return createScaleT(key, utcTime(), channels, options);
    }
    const ordinalImplicit = Symbol("ordinal");
    function createScaleO(key, scale2, channels, { type, interval: interval2, domain, range: range2, reverse: reverse$1, hint }) {
      interval2 = maybeRangeInterval(interval2, type);
      if (domain === void 0)
        domain = inferDomain(channels, interval2, key);
      if (type === "categorical" || type === ordinalImplicit)
        type = "ordinal";
      if (reverse$1)
        domain = reverse(domain);
      scale2.domain(domain);
      if (range2 !== void 0) {
        if (typeof range2 === "function")
          range2 = range2(domain);
        scale2.range(range2);
      }
      return { type, domain, range: range2, scale: scale2, hint, interval: interval2 };
    }
    function createScaleOrdinal(key, channels, { type, interval: interval2, domain, range: range2, scheme: scheme2, unknown, ...options }) {
      interval2 = maybeRangeInterval(interval2, type);
      if (domain === void 0)
        domain = inferDomain(channels, interval2, key);
      let hint;
      if (registry.get(key) === symbol) {
        hint = inferSymbolHint(channels);
        range2 = range2 === void 0 ? inferSymbolRange(hint) : map(range2, maybeSymbol);
      } else if (registry.get(key) === color) {
        if (range2 === void 0 && (type === "ordinal" || type === ordinalImplicit)) {
          range2 = maybeBooleanRange(domain, scheme2);
          if (range2 !== void 0)
            scheme2 = void 0;
        }
        if (scheme2 === void 0 && range2 === void 0) {
          scheme2 = type === "ordinal" ? "turbo" : "tableau10";
        }
        if (scheme2 !== void 0) {
          if (range2 !== void 0) {
            const interpolate2 = quantitativeScheme(scheme2);
            const t02 = range2[0], d = range2[1] - range2[0];
            range2 = ({ length: n }) => quantize((t) => interpolate2(t02 + d * t), n);
          } else {
            range2 = ordinalScheme(scheme2);
          }
        }
      }
      if (unknown === implicit) {
        throw new Error(`implicit unknown on ${key} scale is not supported`);
      }
      return createScaleO(key, ordinal().unknown(unknown), channels, { ...options, type, domain, range: range2, hint });
    }
    function createScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {
      return maybeRound(point().align(align).padding(padding), channels, options, key);
    }
    function createScaleBand(key, channels, {
      align = 0.5,
      padding = 0.1,
      paddingInner = padding,
      paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
      ...options
    }) {
      return maybeRound(
        band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
        channels,
        options,
        key
      );
    }
    function maybeRound(scale2, channels, options, key) {
      let { round: round2 } = options;
      if (round2 !== void 0)
        scale2.round(round2 = !!round2);
      scale2 = createScaleO(key, scale2, channels, options);
      scale2.round = round2;
      return scale2;
    }
    function inferDomain(channels, interval2, key) {
      const values2 = new InternSet();
      for (const { value, domain } of channels) {
        if (domain !== void 0)
          return domain();
        if (value === void 0)
          continue;
        for (const v of value)
          values2.add(v);
      }
      if (interval2 !== void 0) {
        const [min2, max2] = extent(values2).map(interval2.floor, interval2);
        return interval2.range(min2, interval2.offset(max2));
      }
      if (values2.size > 1e4 && registry.get(key) === position) {
        throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
      }
      return sort(values2, ascendingDefined);
    }
    function inferHint(channels, key) {
      let value;
      for (const { hint } of channels) {
        const candidate = hint == null ? void 0 : hint[key];
        if (candidate === void 0)
          continue;
        if (value === void 0)
          value = candidate;
        else if (value !== candidate)
          return;
      }
      return value;
    }
    function inferSymbolHint(channels) {
      return {
        fill: inferHint(channels, "fill"),
        stroke: inferHint(channels, "stroke")
      };
    }
    function inferSymbolRange(hint) {
      return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
    }
    function normalizeScale(key, scale2, hint) {
      return createScale(key, hint === void 0 ? void 0 : [{ hint }], { ...scale2 });
    }
    function createScale(key, channels = [], options = {}) {
      const type = inferScaleType(key, channels, options);
      if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({ type })) {
        const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
        if (values2.some(isTemporal))
          warn(
            `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
              type
            )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
              type
            )}".`
          );
        else if (values2.some(isTemporalString))
          warn(
            `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
              type
            )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
              type
            )}".`
          );
        else if (values2.some(isNumericString))
          warn(
            `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
              type
            )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
              type
            )}".`
          );
      }
      options.type = type;
      switch (type) {
        case "diverging":
        case "diverging-sqrt":
        case "diverging-pow":
        case "diverging-log":
        case "diverging-symlog":
        case "cyclical":
        case "sequential":
        case "linear":
        case "sqrt":
        case "threshold":
        case "quantile":
        case "pow":
        case "log":
        case "symlog":
          options = coerceType(channels, options, coerceNumbers);
          break;
        case "identity":
          switch (registry.get(key)) {
            case position:
              options = coerceType(channels, options, coerceNumbers);
              break;
            case symbol:
              options = coerceType(channels, options, coerceSymbols);
              break;
          }
          break;
        case "utc":
        case "time":
          options = coerceType(channels, options, coerceDates);
          break;
      }
      switch (type) {
        case "diverging":
          return createScaleDiverging(key, channels, options);
        case "diverging-sqrt":
          return createScaleDivergingSqrt(key, channels, options);
        case "diverging-pow":
          return createScaleDivergingPow(key, channels, options);
        case "diverging-log":
          return createScaleDivergingLog(key, channels, options);
        case "diverging-symlog":
          return createScaleDivergingSymlog(key, channels, options);
        case "categorical":
        case "ordinal":
        case ordinalImplicit:
          return createScaleOrdinal(key, channels, options);
        case "cyclical":
        case "sequential":
        case "linear":
          return createScaleLinear(key, channels, options);
        case "sqrt":
          return createScaleSqrt(key, channels, options);
        case "threshold":
          return createScaleThreshold(key, channels, options);
        case "quantile":
          return createScaleQuantile(key, channels, options);
        case "quantize":
          return createScaleQuantize(key, channels, options);
        case "pow":
          return createScalePow(key, channels, options);
        case "log":
          return createScaleLog(key, channels, options);
        case "symlog":
          return createScaleSymlog(key, channels, options);
        case "utc":
          return createScaleUtc(key, channels, options);
        case "time":
          return createScaleTime(key, channels, options);
        case "point":
          return createScalePoint(key, channels, options);
        case "band":
          return createScaleBand(key, channels, options);
        case "identity":
          return registry.get(key) === position ? createScaleIdentity() : { type: "identity" };
        case void 0:
          return;
        default:
          throw new Error(`unknown scale type: ${type}`);
      }
    }
    function formatScaleType(type) {
      return typeof type === "symbol" ? type.description : type;
    }
    const typeProjection = { toString: () => "projection" };
    function inferScaleType(key, channels, { type, domain, range: range2, scheme: scheme2, pivot, projection: projection2 }) {
      if (key === "fx" || key === "fy")
        return "band";
      if ((key === "x" || key === "y") && projection2 != null)
        type = typeProjection;
      for (const { type: t } of channels) {
        if (t === void 0)
          continue;
        else if (type === void 0)
          type = t;
        else if (type !== t)
          throw new Error(`scale incompatible with channel: ${type} !== ${t}`);
      }
      if (type === typeProjection)
        return;
      if (type !== void 0)
        return type;
      if (domain === void 0 && !channels.some(({ value }) => value !== void 0))
        return;
      const kind = registry.get(key);
      if (kind === radius)
        return "sqrt";
      if (kind === opacity || kind === length)
        return "linear";
      if (kind === symbol)
        return "ordinal";
      if ((domain || range2 || []).length > 2)
        return asOrdinalType(kind);
      if (domain !== void 0) {
        if (isOrdinal(domain))
          return asOrdinalType(kind);
        if (isTemporal(domain))
          return "utc";
        if (kind === color && (pivot != null || isDivergingScheme(scheme2)))
          return "diverging";
        return "linear";
      }
      const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
      if (values2.some(isOrdinal))
        return asOrdinalType(kind);
      if (values2.some(isTemporal))
        return "utc";
      if (kind === color && (pivot != null || isDivergingScheme(scheme2)))
        return "diverging";
      return "linear";
    }
    function asOrdinalType(kind) {
      switch (kind) {
        case position:
          return "point";
        case color:
          return ordinalImplicit;
        default:
          return "ordinal";
      }
    }
    function isOrdinalScale({ type }) {
      return type === "ordinal" || type === "point" || type === "band" || type === ordinalImplicit;
    }
    function isThresholdScale({ type }) {
      return type === "threshold";
    }
    function coerceType(channels, { domain, ...options }, coerceValues) {
      for (const c2 of channels) {
        if (c2.value !== void 0) {
          c2.value = coerceValues(c2.value);
        }
      }
      return {
        domain: domain === void 0 ? domain : coerceValues(domain),
        ...options
      };
    }
    function coerceSymbols(values2) {
      return map(values2, maybeSymbol);
    }
    function memoize1(compute) {
      let cacheValue, cacheKeys;
      return (...keys2) => {
        if ((cacheKeys == null ? void 0 : cacheKeys.length) !== keys2.length || cacheKeys.some((k2, i) => k2 !== keys2[i])) {
          cacheKeys = keys2;
          cacheValue = compute(...keys2);
        }
        return cacheValue;
      };
    }
    const numberFormat = memoize1((locale2) => {
      return new Intl.NumberFormat(locale2);
    });
    function formatNumber(locale2 = "en-US") {
      const format2 = numberFormat(locale2);
      return (i) => i != null && !isNaN(i) ? format2.format(i) : void 0;
    }
    function formatIsoDate(date2) {
      return format(date2, "Invalid Date");
    }
    function formatAuto(locale2 = "en-US") {
      const number2 = formatNumber(locale2);
      return (v) => (v instanceof Date ? formatIsoDate : typeof v === "number" ? number2 : string)(v);
    }
    formatAuto();
    function impliedString(value, impliedValue) {
      if ((value = string(value)) !== impliedValue)
        return value;
    }
    const validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
    function maybeClassName(name) {
      if (name === void 0)
        return "plot-d6a7b5";
      name = `${name}`;
      if (!validClassName.test(name))
        throw new Error(`invalid class name: ${name}`);
      return name;
    }
    function applyInlineStyles(selection2, style) {
      if (typeof style === "string") {
        selection2.property("style", style);
      } else if (style != null) {
        for (const element2 of selection2) {
          Object.assign(element2.style, style);
        }
      }
    }
    function inferFontVariant(scale2) {
      return isOrdinalScale(scale2) && scale2.interval === void 0 ? void 0 : "tabular-nums";
    }
    function maybeAutoTickFormat(tickFormat2, domain) {
      return tickFormat2 === void 0 ? isTemporal(domain) ? formatIsoDate : string : typeof tickFormat2 === "function" ? tickFormat2 : (typeof tickFormat2 === "string" ? isTemporal(domain) ? utcFormat : format$1 : constant)(tickFormat2);
    }
    function legendRamp(color2, options) {
      let {
        label = color2.label,
        tickSize = 6,
        width = 240,
        height = 44 + tickSize,
        marginTop = 18,
        marginRight = 0,
        marginBottom = 16 + tickSize,
        marginLeft = 0,
        style,
        ticks: ticks2 = (width - marginLeft - marginRight) / 64,
        tickFormat: tickFormat2,
        fontVariant = inferFontVariant(color2),
        round: round2 = true,
        opacity: opacity2,
        className
      } = options;
      const context = createContext(options);
      className = maybeClassName(className);
      opacity2 = maybeNumberChannel(opacity2)[1];
      if (tickFormat2 === null)
        tickFormat2 = () => null;
      const svg = create$2("svg", context).attr("class", `${className}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call(
        (svg2) => (
          // Warning: if you edit this, change defaultClassName.
          svg2.append("style").text(
            `.${className}-ramp {
  display: block;
  background: white;
  height: auto;
  height: intrinsic;
  max-width: 100%;
  overflow: visible;
}
.${className}-ramp text {
  white-space: pre;
}`
          )
        )
      ).call(applyInlineStyles, style);
      let tickAdjust = (g) => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
      let x;
      const applyRange = round2 ? (x2, range3) => x2.rangeRound(range3) : (x2, range3) => x2.range(range3);
      const { type, domain, range: range2, interpolate: interpolate2, scale: scale2, pivot } = color2;
      if (interpolate2) {
        const interpolator = range2 === void 0 ? interpolate2 : piecewise(interpolate2.length === 1 ? interpolatePiecewise(interpolate2) : interpolate2, range2);
        x = applyRange(
          scale2.copy(),
          quantize(
            interpolateNumber(marginLeft, width - marginRight),
            Math.min(domain.length + (pivot !== void 0), range2 === void 0 ? Infinity : range2.length)
          )
        );
        const n = 256;
        const canvas = context.document.createElement("canvas");
        canvas.width = n;
        canvas.height = 1;
        const context2 = canvas.getContext("2d");
        for (let i = 0, j = n - 1; i < n; ++i) {
          context2.fillStyle = interpolator(i / j);
          context2.fillRect(i, 0, 1, 1);
        }
        svg.append("image").attr("opacity", opacity2).attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
      } else if (type === "threshold") {
        const thresholds = domain;
        const thresholdFormat = tickFormat2 === void 0 ? (d) => d : typeof tickFormat2 === "string" ? format$1(tickFormat2) : tickFormat2;
        x = applyRange(linear().domain([-1, range2.length - 1]), [marginLeft, width - marginRight]);
        svg.append("g").attr("fill-opacity", opacity2).selectAll().data(range2).enter().append("rect").attr("x", (d, i) => x(i - 1)).attr("y", marginTop).attr("width", (d, i) => x(i) - x(i - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d) => d);
        ticks2 = map(thresholds, (_, i) => i);
        tickFormat2 = (i) => thresholdFormat(thresholds[i], i);
      } else {
        x = applyRange(band().domain(domain), [marginLeft, width - marginRight]);
        svg.append("g").attr("fill-opacity", opacity2).selectAll().data(domain).enter().append("rect").attr("x", x).attr("y", marginTop).attr("width", Math.max(0, x.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale2);
        tickAdjust = () => {
        };
      }
      svg.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(
        axisBottom(x).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === "string" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === "function" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)
      ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g) => g.select(".domain").remove());
      if (label !== void 0) {
        svg.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
      }
      return svg.node();
    }
    function maybeScale(scale2, key) {
      if (key == null)
        return key;
      const s2 = scale2(key);
      if (!s2)
        throw new Error(`scale not found: ${key}`);
      return s2;
    }
    function legendSwatches(color2, { opacity: opacity2, ...options } = {}) {
      if (!isOrdinalScale(color2) && !isThresholdScale(color2))
        throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color2.type})`);
      return legendItems(
        color2,
        options,
        (selection2, scale2, width, height) => selection2.append("svg").attr("width", width).attr("height", height).attr("fill", scale2.scale).attr("fill-opacity", maybeNumberChannel(opacity2)[1]).append("rect").attr("width", "100%").attr("height", "100%")
      );
    }
    function legendSymbols(symbol2, {
      fill: fill2 = ((_a) => (_a = symbol2.hint) == null ? void 0 : _a.fill)() !== void 0 ? symbol2.hint.fill : "none",
      fillOpacity = 1,
      stroke = ((_b) => (_b = symbol2.hint) == null ? void 0 : _b.stroke)() !== void 0 ? symbol2.hint.stroke : isNoneish(fill2) ? "currentColor" : "none",
      strokeOpacity = 1,
      strokeWidth = 1.5,
      r = 4.5,
      ...options
    } = {}, scale2) {
      const [vf, cf] = maybeColorChannel(fill2);
      const [vs, cs] = maybeColorChannel(stroke);
      const sf = maybeScale(scale2, vf);
      const ss = maybeScale(scale2, vs);
      const size = r * r * Math.PI;
      fillOpacity = maybeNumberChannel(fillOpacity)[1];
      strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
      strokeWidth = maybeNumberChannel(strokeWidth)[1];
      return legendItems(
        symbol2,
        options,
        (selection2, scale3, width, height) => selection2.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", width).attr("height", height).attr("fill", vf === "color" ? (d) => sf.scale(d) : cf).attr("fill-opacity", fillOpacity).attr("stroke", vs === "color" ? (d) => ss.scale(d) : cs).attr("stroke-opacity", strokeOpacity).attr("stroke-width", strokeWidth).append("path").attr("d", (d) => {
          const p = pathRound();
          symbol2.scale(d).draw(p, size);
          return p;
        })
      );
    }
    function legendItems(scale2, options = {}, swatch) {
      let {
        columns,
        tickFormat: tickFormat2,
        fontVariant = inferFontVariant(scale2),
        // TODO label,
        swatchSize = 15,
        swatchWidth = swatchSize,
        swatchHeight = swatchSize,
        marginLeft = 0,
        className,
        style,
        width
      } = options;
      const context = createContext(options);
      className = maybeClassName(className);
      tickFormat2 = maybeAutoTickFormat(tickFormat2, scale2.domain);
      const swatches = create$2("div", context).attr(
        "class",
        `${className}-swatches ${className}-swatches-${columns != null ? "columns" : "wrap"}`
      );
      let extraStyle;
      if (columns != null) {
        extraStyle = `.${className}-swatches-columns .${className}-swatch {
  display: flex;
  align-items: center;
  break-inside: avoid;
  padding-bottom: 1px;
}
.${className}-swatches-columns .${className}-swatch::before {
  flex-shrink: 0;
}
.${className}-swatches-columns .${className}-swatch-label {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}`;
        swatches.style("columns", columns).selectAll().data(scale2.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale2, swatchWidth, swatchHeight).call(
          (item) => item.append("div").attr("class", `${className}-swatch-label`).attr("title", tickFormat2).text(tickFormat2)
        );
      } else {
        extraStyle = `.${className}-swatches-wrap {
  display: flex;
  align-items: center;
  min-height: 33px;
  flex-wrap: wrap;
}
.${className}-swatches-wrap .${className}-swatch {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}`;
        swatches.selectAll().data(scale2.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale2, swatchWidth, swatchHeight).append(function() {
          return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));
        });
      }
      return swatches.call(
        (div) => div.insert("style", "*").text(
          `.${className}-swatches {
  font-family: system-ui, sans-serif;
  font-size: 10px;
  margin-bottom: 0.5em;
}
.${className}-swatch > svg {
  margin-right: 0.5em;
  overflow: visible;
}
${extraStyle}`
        )
      ).style("margin-left", marginLeft ? `${+marginLeft}px` : null).style("width", width === void 0 ? null : `${+width}px`).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style).node();
    }
    const legendRegistry = /* @__PURE__ */ new Map([
      ["symbol", legendSymbols],
      ["color", legendColor],
      ["opacity", legendOpacity]
    ]);
    function legend(options = {}) {
      for (const [key, value] of legendRegistry) {
        const scale2 = options[key];
        if (isScaleOptions(scale2)) {
          const context = createContext(options);
          let hint;
          if (key === "symbol") {
            const { fill: fill2, stroke = fill2 === void 0 && isScaleOptions(options.color) ? "color" : void 0 } = options;
            hint = { fill: fill2, stroke };
          }
          return value(
            normalizeScale(key, scale2, hint),
            legendOptions(context, scale2, options),
            (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null
          );
        }
      }
      throw new Error("unknown legend type; no scale found");
    }
    function legendOptions({ className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 } = {}, options) {
      return inherit(options, { className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 });
    }
    function legendColor(color2, { legend: legend2 = true, ...options }) {
      if (legend2 === true)
        legend2 = color2.type === "ordinal" ? "swatches" : "ramp";
      if (color2.domain === void 0)
        return;
      switch (`${legend2}`.toLowerCase()) {
        case "swatches":
          return legendSwatches(color2, options);
        case "ramp":
          return legendRamp(color2, options);
        default:
          throw new Error(`unknown legend type: ${legend2}`);
      }
    }
    function legendOpacity({ type, interpolate: interpolate2, ...scale2 }, { legend: legend2 = true, color: color2 = rgb(0, 0, 0), ...options }) {
      if (!interpolate2)
        throw new Error(`${type} opacity scales are not supported`);
      if (legend2 === true)
        legend2 = "ramp";
      if (`${legend2}`.toLowerCase() !== "ramp")
        throw new Error(`${legend2} opacity legends are not supported`);
      return legendColor({ type, ...scale2, interpolate: interpolateOpacity(color2) }, { legend: legend2, ...options });
    }
    function interpolateOpacity(color2) {
      const { r, g, b } = rgb(color2) || rgb(0, 0, 0);
      return (t) => `rgba(${r},${g},${b},${t})`;
    }
    var DEFAULT_SELECTOR$1 = "#ch-plugin-legend";
    var defaultOptions$1 = {
      // Whether to display the legend
      enabled: true,
      itemSelector: null,
      label: null,
      width: 130
    };
    var Legend = /* @__PURE__ */ function() {
      function Legend2(calendar2) {
        _classCallCheck$1(this, Legend2);
        this.name = "Legend";
        this.calendar = calendar2;
        this.root = null;
        this.shown = false;
        this.options = defaultOptions$1;
      }
      _createClass$1(Legend2, [{
        key: "setup",
        value: function setup(pluginOptions) {
          this.options = Object.assign(Object.assign({}, defaultOptions$1), pluginOptions);
        }
      }, {
        key: "paint",
        value: function paint() {
          var scaleOptions = this.calendar.options.options.scale;
          var _this$options = this.options, enabled = _this$options.enabled, itemSelector = _this$options.itemSelector;
          if (!enabled || itemSelector && select$1(itemSelector).empty()) {
            return this.destroy();
          }
          this.shown = true;
          this.root = select$1(itemSelector || this.calendar.options.options.itemSelector);
          if (this.root.select(DEFAULT_SELECTOR$1).empty()) {
            this.root = this.root.append("div").attr("id", DEFAULT_SELECTOR$1.slice(1));
          } else {
            this.root = this.root.select(DEFAULT_SELECTOR$1);
          }
          var node2 = legend(Object.assign(Object.assign({}, scaleOptions), this.options));
          this.root.selectAll("*").remove();
          this.root.append(function() {
            return node2;
          });
          return Promise.resolve();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.root !== null) {
            this.root.remove();
            this.root = null;
          }
          return Promise.resolve();
        }
      }]);
      return Legend2;
    }();
    var top$1 = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [top$1, bottom, right, left];
    var start = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    function getNodeName(element2) {
      return element2 ? (element2.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node2) {
      if (node2 == null) {
        return window;
      }
      if (node2.toString() !== "[object Window]") {
        var ownerDocument = node2.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node2;
    }
    function isElement(node2) {
      var OwnElement = getWindow(node2).Element;
      return node2 instanceof OwnElement || node2 instanceof Element;
    }
    function isHTMLElement(node2) {
      var OwnElement = getWindow(node2).HTMLElement;
      return node2 instanceof OwnElement || node2 instanceof HTMLElement;
    }
    function isShadowRoot(node2) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node2).ShadowRoot;
      return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element2 = state.elements[name];
        if (!isHTMLElement(element2) || !getNodeName(element2)) {
          return;
        }
        Object.assign(element2.style, style);
        Object.keys(attributes).forEach(function(name2) {
          var value = attributes[name2];
          if (value === false) {
            element2.removeAttribute(name2);
          } else {
            element2.setAttribute(name2, value === true ? "" : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state.elements).forEach(function(name) {
          var element2 = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
          var style = styleProperties.reduce(function(style2, property) {
            style2[property] = "";
            return style2;
          }, {});
          if (!isHTMLElement(element2) || !getNodeName(element2)) {
            return;
          }
          Object.assign(element2.style, style);
          Object.keys(attributes).forEach(function(attribute) {
            element2.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
    };
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    var max$2 = Math.max;
    var min$2 = Math.min;
    var round = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element2.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element2)) {
        scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
        scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width,
        height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x,
        y
      };
    }
    function getLayoutRect(element2) {
      var clientRect = getBoundingClientRect(element2);
      var width = element2.offsetWidth;
      var height = element2.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
      return {
        x: element2.offsetLeft,
        y: element2.offsetTop,
        width,
        height
      };
    }
    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
          if (next && parent.isSameNode(next)) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getComputedStyle(element2) {
      return getWindow(element2).getComputedStyle(element2);
    }
    function isTableElement(element2) {
      return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
    }
    function getDocumentElement(element2) {
      return ((isElement(element2) ? element2.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element2.document
      )) || window.document).documentElement;
    }
    function getParentNode(element2) {
      if (getNodeName(element2) === "html") {
        return element2;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element2.parentNode || // DOM Element detected
        (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element2)
      );
    }
    function getTrueOffsetParent(element2) {
      if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle(element2).position === "fixed") {
        return null;
      }
      return element2.offsetParent;
    }
    function getContainingBlock(element2) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element2)) {
        var elementCss = getComputedStyle(element2);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element2);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle(currentNode);
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element2) {
      var window2 = getWindow(element2);
      var offsetParent = getTrueOffsetParent(element2);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element2) || window2;
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within(min2, value, max2) {
      return max$2(min2, min$2(value, max2));
    }
    function withinMaxClamp(min2, value, max2) {
      var v = within(min2, value, max2);
      return v > max2 ? max2 : v;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys2) {
      return keys2.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject = function toPaddingObject2(padding, state) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow(_ref) {
      var _state$modifiersData$;
      var state = _ref.state, name = _ref.name, options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis2 = getMainAxisFromPlacement(basePlacement);
      var isVertical2 = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical2 ? "height" : "width";
      if (!arrowElement || !popperOffsets2) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis2 === "y" ? top$1 : left;
      var maxProp = axis2 === "y" ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis2] - popperOffsets2[axis2] - state.rects.popper[len];
      var startDiff = popperOffsets2[axis2] - state.rects.reference[axis2];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis2 === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min2 = paddingObject[minProp];
      var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center2 = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset2 = within(min2, center2, max2);
      var axisProp = axis2;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center2, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains(state.elements.popper, arrowElement)) {
        return;
      }
      state.elements.arrow = arrowElement;
    }
    const arrow$1 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref, win) {
      var x = _ref.x, y = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x,
        y
      }) : {
        x,
        y
      };
      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top$1;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle(offsetParent).position !== "static" && position2 === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top$1 || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top$1 || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position: position2
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x,
        y
      }, getWindow(popper2)) : {
        x,
        y
      };
      x = _ref4.x;
      y = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
      });
    }
    const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state = _ref.state, instance2 = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance2.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance2.update, passive);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance2.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance2.update, passive);
        }
      };
    }
    const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn() {
      },
      effect,
      data: {}
    };
    var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
      });
    }
    var hash = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
      });
    }
    function getWindowScroll(node2) {
      var win = getWindow(node2);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX(element2) {
      return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
    }
    function getViewportRect(element2, strategy) {
      var win = getWindow(element2);
      var html2 = getDocumentElement(element2);
      var visualViewport = win.visualViewport;
      var width = html2.clientWidth;
      var height = html2.clientHeight;
      var x = 0;
      var y = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x + getWindowScrollBarX(element2),
        y
      };
    }
    function getDocumentRect(element2) {
      var _element$ownerDocumen;
      var html2 = getDocumentElement(element2);
      var winScroll = getWindowScroll(element2);
      var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max$2(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max$2(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
      var y = -winScroll.scrollTop;
      if (getComputedStyle(body || html2).direction === "rtl") {
        x += max$2(html2.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x,
        y
      };
    }
    function isScrollParent(element2) {
      var _getComputedStyle = getComputedStyle(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent(node2) {
      if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
        return node2.ownerDocument.body;
      }
      if (isHTMLElement(node2) && isScrollParent(node2)) {
        return node2;
      }
      return getScrollParent(getParentNode(node2));
    }
    function listScrollParents(element2, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element2);
      var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents(getParentNode(target)))
      );
    }
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element2, strategy) {
      var rect = getBoundingClientRect(element2, false, strategy === "fixed");
      rect.top = rect.top + element2.clientTop;
      rect.left = rect.left + element2.clientLeft;
      rect.bottom = rect.top + element2.clientHeight;
      rect.right = rect.left + element2.clientWidth;
      rect.width = element2.clientWidth;
      rect.height = element2.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element2, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
    }
    function getClippingParents(element2) {
      var clippingParents2 = listScrollParents(getParentNode(element2));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element2).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element2, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
        accRect.top = max$2(rect.top, accRect.top);
        accRect.right = min$2(rect.right, accRect.right);
        accRect.bottom = min$2(rect.bottom, accRect.bottom);
        accRect.left = max$2(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
      var offsets;
      switch (basePlacement) {
        case top$1:
          offsets = {
            x: commonX,
            y: reference2.y - element2.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element2.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element2 = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis2 = [top$1, bottom].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset2[axis2] * multiply;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a2, b) {
        return overflows[a2] - overflows[b];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      if (state.modifiersData[name]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i = 0; i < placements2.length; i++) {
        var placement = placements2[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical2 = [top$1, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical2 ? "width" : "height";
        var overflow = detectOverflow(state, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical2 ? isStartVariation ? right : left : isStartVariation ? bottom : top$1;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check2) {
          return check2;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i2).every(function(check2) {
                return check2;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break")
            break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    }
    const flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow) {
      return [top$1, right, bottom, left].some(function(side) {
        return overflow[side] >= 0;
      });
    }
    function hide(_ref) {
      var state = _ref.state, name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
    function distanceAndSkiddingToXY(placement, rects, offset2) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top$1].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
        placement
      })) : offset2, skidding = _ref[0], distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset(_ref2) {
      var state = _ref2.state, options = _ref2.options, name = _ref2.name;
      var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data2 = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
      }, {});
      var _data$state$placement = data2[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }
      state.modifiersData[name] = data2;
    }
    const offset$1 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset
    };
    function popperOffsets(_ref) {
      var state = _ref.state, name = _ref.name;
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
      });
    }
    const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    function getAltAxis(axis2) {
      return axis2 === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data2 = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top$1 : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min2 = offset2 + overflow[mainSide];
        var max2 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min$2(min2, tetherMin) : min2, offset2, tether ? max$2(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset;
        data2[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top$1 : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top$1, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data2[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name] = data2;
    }
    const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll(element2) {
      return {
        scrollLeft: element2.scrollLeft,
        scrollTop: element2.scrollTop
      };
    }
    function getNodeScroll(node2) {
      if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
        return getWindowScroll(node2);
      } else {
        return getHTMLElementScroll(node2);
      }
    }
    function isElementScaled(element2) {
      var rect = element2.getBoundingClientRect();
      var scaleX = round(rect.width) / element2.offsetWidth || 1;
      var scaleY = round(rect.height) / element2.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order(modifiers) {
      var map2 = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map2.set(modifier.name, modifier);
      });
      function sort2(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map2.get(dep);
            if (depModifier) {
              sort2(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort2(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce(fn) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve(fn());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    var DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element2) {
        return !(element2 && typeof element2.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions2;
        }
        var state = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance2 = {
          state,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions2, state.options, options2);
            state.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
            state.orderedModifiers = orderedModifiers.filter(function(m) {
              return m.enabled;
            });
            runModifierEffects();
            return instance2.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state.reset = false;
            state.placement = state.options.placement;
            state.orderedModifiers.forEach(function(modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
              if (typeof fn === "function") {
                state = fn({
                  state,
                  options: _options,
                  name,
                  instance: instance2
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function() {
            return new Promise(function(resolve) {
              instance2.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance2;
        }
        instance2.setOptions(options).then(function(state2) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state2);
          }
        });
        function runModifierEffects() {
          state.orderedModifiers.forEach(function(_ref) {
            var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state,
                name,
                instance: instance2,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn) {
            return fn();
          });
          effectCleanupFns = [];
        }
        return instance2;
      };
    }
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var check = function(it) {
      return it && it.Math === Math && it;
    };
    var global$j = (
      // eslint-disable-next-line es/no-global-this -- safe
      check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
      function() {
        return this;
      }() || Function("return this")()
    );
    var objectGetOwnPropertyDescriptor = {};
    var fails$j = function(exec2) {
      try {
        return !!exec2();
      } catch (error) {
        return true;
      }
    };
    var fails$i = fails$j;
    var descriptors = !fails$i(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
    var fails$h = fails$j;
    var functionBindNative = !fails$h(function() {
      var test2 = (function() {
      }).bind();
      return typeof test2 != "function" || test2.hasOwnProperty("prototype");
    });
    var NATIVE_BIND$3 = functionBindNative;
    var call$e = Function.prototype.call;
    var functionCall = NATIVE_BIND$3 ? call$e.bind(call$e) : function() {
      return call$e.apply(call$e, arguments);
    };
    var objectPropertyIsEnumerable = {};
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable2(V) {
      var descriptor = getOwnPropertyDescriptor$2(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
    var createPropertyDescriptor$4 = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
    var NATIVE_BIND$2 = functionBindNative;
    var FunctionPrototype$3 = Function.prototype;
    var call$d = FunctionPrototype$3.call;
    var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$3.bind.bind(call$d, call$d);
    var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function(fn) {
      return function() {
        return call$d.apply(fn, arguments);
      };
    };
    var uncurryThis$k = functionUncurryThis;
    var toString$5 = uncurryThis$k({}.toString);
    var stringSlice$2 = uncurryThis$k("".slice);
    var classofRaw$2 = function(it) {
      return stringSlice$2(toString$5(it), 8, -1);
    };
    var uncurryThis$j = functionUncurryThis;
    var fails$g = fails$j;
    var classof$9 = classofRaw$2;
    var $Object$4 = Object;
    var split = uncurryThis$j("".split);
    var indexedObject = fails$g(function() {
      return !$Object$4("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof$9(it) === "String" ? split(it, "") : $Object$4(it);
    } : $Object$4;
    var isNullOrUndefined$6 = function(it) {
      return it === null || it === void 0;
    };
    var isNullOrUndefined$5 = isNullOrUndefined$6;
    var $TypeError$d = TypeError;
    var requireObjectCoercible$3 = function(it) {
      if (isNullOrUndefined$5(it))
        throw new $TypeError$d("Can't call method on " + it);
      return it;
    };
    var IndexedObject$2 = indexedObject;
    var requireObjectCoercible$2 = requireObjectCoercible$3;
    var toIndexedObject$6 = function(it) {
      return IndexedObject$2(requireObjectCoercible$2(it));
    };
    var documentAll$2 = typeof document == "object" && document.all;
    var IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
    var documentAll_1 = {
      all: documentAll$2,
      IS_HTMLDDA
    };
    var $documentAll$1 = documentAll_1;
    var documentAll$1 = $documentAll$1.all;
    var isCallable$m = $documentAll$1.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll$1;
    } : function(argument) {
      return typeof argument == "function";
    };
    var isCallable$l = isCallable$m;
    var $documentAll = documentAll_1;
    var documentAll = $documentAll.all;
    var isObject$f = $documentAll.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable$l(it) || it === documentAll;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable$l(it);
    };
    var global$i = global$j;
    var isCallable$k = isCallable$m;
    var aFunction = function(argument) {
      return isCallable$k(argument) ? argument : void 0;
    };
    var getBuiltIn$7 = function(namespace2, method2) {
      return arguments.length < 2 ? aFunction(global$i[namespace2]) : global$i[namespace2] && global$i[namespace2][method2];
    };
    var uncurryThis$i = functionUncurryThis;
    var objectIsPrototypeOf = uncurryThis$i({}.isPrototypeOf);
    var engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
    var global$h = global$j;
    var userAgent$3 = engineUserAgent;
    var process$3 = global$h.process;
    var Deno$1 = global$h.Deno;
    var versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;
    var v8 = versions && versions.v8;
    var match, version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent$3) {
      match = userAgent$3.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent$3.match(/Chrome\/(\d+)/);
        if (match)
          version = +match[1];
      }
    }
    var engineV8Version = version;
    var V8_VERSION$3 = engineV8Version;
    var fails$f = fails$j;
    var global$g = global$j;
    var $String$5 = global$g.String;
    var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$f(function() {
      var symbol2 = Symbol("symbol detection");
      return !$String$5(symbol2) || !(Object(symbol2) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION$3 && V8_VERSION$3 < 41;
    });
    var NATIVE_SYMBOL$1 = symbolConstructorDetection;
    var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
    var getBuiltIn$6 = getBuiltIn$7;
    var isCallable$j = isCallable$m;
    var isPrototypeOf$2 = objectIsPrototypeOf;
    var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
    var $Object$3 = Object;
    var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn$6("Symbol");
      return isCallable$j($Symbol) && isPrototypeOf$2($Symbol.prototype, $Object$3(it));
    };
    var $String$4 = String;
    var tryToString$4 = function(argument) {
      try {
        return $String$4(argument);
      } catch (error) {
        return "Object";
      }
    };
    var isCallable$i = isCallable$m;
    var tryToString$3 = tryToString$4;
    var $TypeError$c = TypeError;
    var aCallable$8 = function(argument) {
      if (isCallable$i(argument))
        return argument;
      throw new $TypeError$c(tryToString$3(argument) + " is not a function");
    };
    var aCallable$7 = aCallable$8;
    var isNullOrUndefined$4 = isNullOrUndefined$6;
    var getMethod$3 = function(V, P) {
      var func = V[P];
      return isNullOrUndefined$4(func) ? void 0 : aCallable$7(func);
    };
    var call$c = functionCall;
    var isCallable$h = isCallable$m;
    var isObject$e = isObject$f;
    var $TypeError$b = TypeError;
    var ordinaryToPrimitive$1 = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable$h(fn = input.toString) && !isObject$e(val = call$c(fn, input)))
        return val;
      if (isCallable$h(fn = input.valueOf) && !isObject$e(val = call$c(fn, input)))
        return val;
      if (pref !== "string" && isCallable$h(fn = input.toString) && !isObject$e(val = call$c(fn, input)))
        return val;
      throw new $TypeError$b("Can't convert object to primitive value");
    };
    var shared$3 = { exports: {} };
    var global$f = global$j;
    var defineProperty$7 = Object.defineProperty;
    var defineGlobalProperty$3 = function(key, value) {
      try {
        defineProperty$7(global$f, key, { value, configurable: true, writable: true });
      } catch (error) {
        global$f[key] = value;
      }
      return value;
    };
    var global$e = global$j;
    var defineGlobalProperty$2 = defineGlobalProperty$3;
    var SHARED = "__core-js_shared__";
    var store$3 = global$e[SHARED] || defineGlobalProperty$2(SHARED, {});
    var sharedStore = store$3;
    var store$2 = sharedStore;
    (shared$3.exports = function(key, value) {
      return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.34.0",
      mode: "global",
      copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.34.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
    var sharedExports = shared$3.exports;
    var requireObjectCoercible$1 = requireObjectCoercible$3;
    var $Object$2 = Object;
    var toObject$5 = function(argument) {
      return $Object$2(requireObjectCoercible$1(argument));
    };
    var uncurryThis$h = functionUncurryThis;
    var toObject$4 = toObject$5;
    var hasOwnProperty = uncurryThis$h({}.hasOwnProperty);
    var hasOwnProperty_1 = Object.hasOwn || function hasOwn2(it, key) {
      return hasOwnProperty(toObject$4(it), key);
    };
    var uncurryThis$g = functionUncurryThis;
    var id$2 = 0;
    var postfix = Math.random();
    var toString$4 = uncurryThis$g(1 .toString);
    var uid$3 = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$4(++id$2 + postfix, 36);
    };
    var global$d = global$j;
    var shared$2 = sharedExports;
    var hasOwn$b = hasOwnProperty_1;
    var uid$2 = uid$3;
    var NATIVE_SYMBOL = symbolConstructorDetection;
    var USE_SYMBOL_AS_UID = useSymbolAsUid;
    var Symbol$1 = global$d.Symbol;
    var WellKnownSymbolsStore = shared$2("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1["for"] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;
    var wellKnownSymbol$h = function(name) {
      if (!hasOwn$b(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$b(Symbol$1, name) ? Symbol$1[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
    var call$b = functionCall;
    var isObject$d = isObject$f;
    var isSymbol$1 = isSymbol$2;
    var getMethod$2 = getMethod$3;
    var ordinaryToPrimitive = ordinaryToPrimitive$1;
    var wellKnownSymbol$g = wellKnownSymbol$h;
    var $TypeError$a = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol$g("toPrimitive");
    var toPrimitive$1 = function(input, pref) {
      if (!isObject$d(input) || isSymbol$1(input))
        return input;
      var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call$b(exoticToPrim, input, pref);
        if (!isObject$d(result) || isSymbol$1(result))
          return result;
        throw new $TypeError$a("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
    var toPrimitive = toPrimitive$1;
    var isSymbol = isSymbol$2;
    var toPropertyKey$3 = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
    var global$c = global$j;
    var isObject$c = isObject$f;
    var document$3 = global$c.document;
    var EXISTS$1 = isObject$c(document$3) && isObject$c(document$3.createElement);
    var documentCreateElement$2 = function(it) {
      return EXISTS$1 ? document$3.createElement(it) : {};
    };
    var DESCRIPTORS$b = descriptors;
    var fails$e = fails$j;
    var createElement$1 = documentCreateElement$2;
    var ie8DomDefine = !DESCRIPTORS$b && !fails$e(function() {
      return Object.defineProperty(createElement$1("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
    var DESCRIPTORS$a = descriptors;
    var call$a = functionCall;
    var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
    var createPropertyDescriptor$3 = createPropertyDescriptor$4;
    var toIndexedObject$5 = toIndexedObject$6;
    var toPropertyKey$2 = toPropertyKey$3;
    var hasOwn$a = hasOwnProperty_1;
    var IE8_DOM_DEFINE$1 = ie8DomDefine;
    var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
    objectGetOwnPropertyDescriptor.f = DESCRIPTORS$a ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor2(O, P) {
      O = toIndexedObject$5(O);
      P = toPropertyKey$2(P);
      if (IE8_DOM_DEFINE$1)
        try {
          return $getOwnPropertyDescriptor$1(O, P);
        } catch (error) {
        }
      if (hasOwn$a(O, P))
        return createPropertyDescriptor$3(!call$a(propertyIsEnumerableModule$1.f, O, P), O[P]);
    };
    var objectDefineProperty = {};
    var DESCRIPTORS$9 = descriptors;
    var fails$d = fails$j;
    var v8PrototypeDefineBug = DESCRIPTORS$9 && fails$d(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
    var isObject$b = isObject$f;
    var $String$3 = String;
    var $TypeError$9 = TypeError;
    var anObject$b = function(argument) {
      if (isObject$b(argument))
        return argument;
      throw new $TypeError$9($String$3(argument) + " is not an object");
    };
    var DESCRIPTORS$8 = descriptors;
    var IE8_DOM_DEFINE = ie8DomDefine;
    var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
    var anObject$a = anObject$b;
    var toPropertyKey$1 = toPropertyKey$3;
    var $TypeError$8 = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE$1 = "configurable";
    var WRITABLE = "writable";
    objectDefineProperty.f = DESCRIPTORS$8 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty2(O, P, Attributes) {
      anObject$a(O);
      P = toPropertyKey$1(P);
      anObject$a(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty2(O, P, Attributes) {
      anObject$a(O);
      P = toPropertyKey$1(P);
      anObject$a(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw new $TypeError$8("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
    var DESCRIPTORS$7 = descriptors;
    var definePropertyModule$4 = objectDefineProperty;
    var createPropertyDescriptor$2 = createPropertyDescriptor$4;
    var createNonEnumerableProperty$4 = DESCRIPTORS$7 ? function(object2, key, value) {
      return definePropertyModule$4.f(object2, key, createPropertyDescriptor$2(1, value));
    } : function(object2, key, value) {
      object2[key] = value;
      return object2;
    };
    var makeBuiltIn$3 = { exports: {} };
    var DESCRIPTORS$6 = descriptors;
    var hasOwn$9 = hasOwnProperty_1;
    var FunctionPrototype$2 = Function.prototype;
    var getDescriptor = DESCRIPTORS$6 && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn$9(FunctionPrototype$2, "name");
    var PROPER = EXISTS && (function something() {
    }).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS$6 || DESCRIPTORS$6 && getDescriptor(FunctionPrototype$2, "name").configurable);
    var functionName = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
    var uncurryThis$f = functionUncurryThis;
    var isCallable$g = isCallable$m;
    var store$1 = sharedStore;
    var functionToString$1 = uncurryThis$f(Function.toString);
    if (!isCallable$g(store$1.inspectSource)) {
      store$1.inspectSource = function(it) {
        return functionToString$1(it);
      };
    }
    var inspectSource$3 = store$1.inspectSource;
    var global$b = global$j;
    var isCallable$f = isCallable$m;
    var WeakMap$1 = global$b.WeakMap;
    var weakMapBasicDetection = isCallable$f(WeakMap$1) && /native code/.test(String(WeakMap$1));
    var shared$1 = sharedExports;
    var uid$1 = uid$3;
    var keys = shared$1("keys");
    var sharedKey$3 = function(key) {
      return keys[key] || (keys[key] = uid$1(key));
    };
    var hiddenKeys$5 = {};
    var NATIVE_WEAK_MAP = weakMapBasicDetection;
    var global$a = global$j;
    var isObject$a = isObject$f;
    var createNonEnumerableProperty$3 = createNonEnumerableProperty$4;
    var hasOwn$8 = hasOwnProperty_1;
    var shared = sharedStore;
    var sharedKey$2 = sharedKey$3;
    var hiddenKeys$4 = hiddenKeys$5;
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError$2 = global$a.TypeError;
    var WeakMap = global$a.WeakMap;
    var set$1, get, has;
    var enforce = function(it) {
      return has(it) ? get(it) : set$1(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject$a(it) || (state = get(it)).type !== TYPE) {
          throw new TypeError$2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      var store = shared.state || (shared.state = new WeakMap());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set$1 = function(it, metadata) {
        if (store.has(it))
          throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      var STATE = sharedKey$2("state");
      hiddenKeys$4[STATE] = true;
      set$1 = function(it, metadata) {
        if (hasOwn$8(it, STATE))
          throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty$3(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return hasOwn$8(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn$8(it, STATE);
      };
    }
    var internalState = {
      set: set$1,
      get,
      has,
      enforce,
      getterFor
    };
    var uncurryThis$e = functionUncurryThis;
    var fails$c = fails$j;
    var isCallable$e = isCallable$m;
    var hasOwn$7 = hasOwnProperty_1;
    var DESCRIPTORS$5 = descriptors;
    var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
    var inspectSource$2 = inspectSource$3;
    var InternalStateModule$4 = internalState;
    var enforceInternalState = InternalStateModule$4.enforce;
    var getInternalState$2 = InternalStateModule$4.get;
    var $String$2 = String;
    var defineProperty$6 = Object.defineProperty;
    var stringSlice$1 = uncurryThis$e("".slice);
    var replace = uncurryThis$e("".replace);
    var join = uncurryThis$e([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS$5 && !fails$c(function() {
      return defineProperty$6(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn$2 = makeBuiltIn$3.exports = function(value, name, options) {
      if (stringSlice$1($String$2(name), 0, 7) === "Symbol(") {
        name = "[" + replace($String$2(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
      }
      if (options && options.getter)
        name = "get " + name;
      if (options && options.setter)
        name = "set " + name;
      if (!hasOwn$7(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
        if (DESCRIPTORS$5)
          defineProperty$6(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn$7(options, "arity") && value.length !== options.arity) {
        defineProperty$6(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn$7(options, "constructor") && options.constructor) {
          if (DESCRIPTORS$5)
            defineProperty$6(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn$7(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn$2(function toString2() {
      return isCallable$e(this) && getInternalState$2(this).source || inspectSource$2(this);
    }, "toString");
    var makeBuiltInExports = makeBuiltIn$3.exports;
    var isCallable$d = isCallable$m;
    var definePropertyModule$3 = objectDefineProperty;
    var makeBuiltIn$1 = makeBuiltInExports;
    var defineGlobalProperty$1 = defineGlobalProperty$3;
    var defineBuiltIn$8 = function(O, key, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable$d(value))
        makeBuiltIn$1(value, name, options);
      if (options.global) {
        if (simple)
          O[key] = value;
        else
          defineGlobalProperty$1(key, value);
      } else {
        try {
          if (!options.unsafe)
            delete O[key];
          else if (O[key])
            simple = true;
        } catch (error) {
        }
        if (simple)
          O[key] = value;
        else
          definePropertyModule$3.f(O, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O;
    };
    var objectGetOwnPropertyNames = {};
    var ceil = Math.ceil;
    var floor = Math.floor;
    var mathTrunc = Math.trunc || function trunc2(x) {
      var n = +x;
      return (n > 0 ? floor : ceil)(n);
    };
    var trunc = mathTrunc;
    var toIntegerOrInfinity$3 = function(argument) {
      var number2 = +argument;
      return number2 !== number2 || number2 === 0 ? 0 : trunc(number2);
    };
    var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;
    var max$1 = Math.max;
    var min$1 = Math.min;
    var toAbsoluteIndex$2 = function(index, length2) {
      var integer = toIntegerOrInfinity$2(index);
      return integer < 0 ? max$1(integer + length2, 0) : min$1(integer, length2);
    };
    var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;
    var min = Math.min;
    var toLength$1 = function(argument) {
      return argument > 0 ? min(toIntegerOrInfinity$1(argument), 9007199254740991) : 0;
    };
    var toLength = toLength$1;
    var lengthOfArrayLike$5 = function(obj) {
      return toLength(obj.length);
    };
    var toIndexedObject$4 = toIndexedObject$6;
    var toAbsoluteIndex$1 = toAbsoluteIndex$2;
    var lengthOfArrayLike$4 = lengthOfArrayLike$5;
    var createMethod$2 = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject$4($this);
        var length2 = lengthOfArrayLike$4(O);
        var index = toAbsoluteIndex$1(fromIndex, length2);
        var value;
        if (IS_INCLUDES && el !== el)
          while (length2 > index) {
            value = O[index++];
            if (value !== value)
              return true;
          }
        else
          for (; length2 > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    var arrayIncludes = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod$2(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod$2(false)
    };
    var uncurryThis$d = functionUncurryThis;
    var hasOwn$6 = hasOwnProperty_1;
    var toIndexedObject$3 = toIndexedObject$6;
    var indexOf = arrayIncludes.indexOf;
    var hiddenKeys$3 = hiddenKeys$5;
    var push$1 = uncurryThis$d([].push);
    var objectKeysInternal = function(object2, names) {
      var O = toIndexedObject$3(object2);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        !hasOwn$6(hiddenKeys$3, key) && hasOwn$6(O, key) && push$1(result, key);
      while (names.length > i)
        if (hasOwn$6(O, key = names[i++])) {
          ~indexOf(result, key) || push$1(result, key);
        }
      return result;
    };
    var enumBugKeys$3 = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
    var internalObjectKeys$1 = objectKeysInternal;
    var enumBugKeys$2 = enumBugKeys$3;
    var hiddenKeys$2 = enumBugKeys$2.concat("length", "prototype");
    objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys$1(O, hiddenKeys$2);
    };
    var objectGetOwnPropertySymbols = {};
    objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
    var getBuiltIn$5 = getBuiltIn$7;
    var uncurryThis$c = functionUncurryThis;
    var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
    var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
    var anObject$9 = anObject$b;
    var concat$1 = uncurryThis$c([].concat);
    var ownKeys$1 = getBuiltIn$5("Reflect", "ownKeys") || function ownKeys2(it) {
      var keys2 = getOwnPropertyNamesModule$1.f(anObject$9(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
      return getOwnPropertySymbols ? concat$1(keys2, getOwnPropertySymbols(it)) : keys2;
    };
    var hasOwn$5 = hasOwnProperty_1;
    var ownKeys = ownKeys$1;
    var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
    var definePropertyModule$2 = objectDefineProperty;
    var copyConstructorProperties$1 = function(target, source, exceptions) {
      var keys2 = ownKeys(source);
      var defineProperty2 = definePropertyModule$2.f;
      var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {
          defineProperty2(target, key, getOwnPropertyDescriptor2(source, key));
        }
      }
    };
    var fails$b = fails$j;
    var isCallable$c = isCallable$m;
    var replacement = /#|\.prototype\./;
    var isForced$3 = function(feature, detection) {
      var value = data[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable$c(detection) ? fails$b(detection) : !!detection;
    };
    var normalize = isForced$3.normalize = function(string2) {
      return String(string2).replace(replacement, ".").toLowerCase();
    };
    var data = isForced$3.data = {};
    var NATIVE = isForced$3.NATIVE = "N";
    var POLYFILL = isForced$3.POLYFILL = "P";
    var isForced_1 = isForced$3;
    var global$9 = global$j;
    var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
    var createNonEnumerableProperty$2 = createNonEnumerableProperty$4;
    var defineBuiltIn$7 = defineBuiltIn$8;
    var defineGlobalProperty = defineGlobalProperty$3;
    var copyConstructorProperties = copyConstructorProperties$1;
    var isForced$2 = isForced_1;
    var _export = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global$9;
      } else if (STATIC) {
        target = global$9[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = (global$9[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor$1(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED2 = isForced$2(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED2 && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty$2(sourceProperty, "sham", true);
          }
          defineBuiltIn$7(target, key, sourceProperty, options);
        }
    };
    var classof$8 = classofRaw$2;
    var isArray$2 = Array.isArray || function isArray2(argument) {
      return classof$8(argument) === "Array";
    };
    var $TypeError$7 = TypeError;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var doesNotExceedSafeInteger$1 = function(it) {
      if (it > MAX_SAFE_INTEGER)
        throw $TypeError$7("Maximum allowed index exceeded");
      return it;
    };
    var toPropertyKey = toPropertyKey$3;
    var definePropertyModule$1 = objectDefineProperty;
    var createPropertyDescriptor$1 = createPropertyDescriptor$4;
    var createProperty$2 = function(object2, key, value) {
      var propertyKey = toPropertyKey(key);
      if (propertyKey in object2)
        definePropertyModule$1.f(object2, propertyKey, createPropertyDescriptor$1(0, value));
      else
        object2[propertyKey] = value;
    };
    var wellKnownSymbol$f = wellKnownSymbol$h;
    var TO_STRING_TAG$2 = wellKnownSymbol$f("toStringTag");
    var test = {};
    test[TO_STRING_TAG$2] = "z";
    var toStringTagSupport = String(test) === "[object z]";
    var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
    var isCallable$b = isCallable$m;
    var classofRaw$1 = classofRaw$2;
    var wellKnownSymbol$e = wellKnownSymbol$h;
    var TO_STRING_TAG$1 = wellKnownSymbol$e("toStringTag");
    var $Object$1 = Object;
    var CORRECT_ARGUMENTS = classofRaw$1(function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    var classof$7 = TO_STRING_TAG_SUPPORT$2 ? classofRaw$1 : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$1)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw$1(O) : (result = classofRaw$1(O)) === "Object" && isCallable$b(O.callee) ? "Arguments" : result;
    };
    var uncurryThis$b = functionUncurryThis;
    var fails$a = fails$j;
    var isCallable$a = isCallable$m;
    var classof$6 = classof$7;
    var getBuiltIn$4 = getBuiltIn$7;
    var inspectSource$1 = inspectSource$3;
    var noop = function() {
    };
    var empty = [];
    var construct = getBuiltIn$4("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis$b(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
    var isConstructorModern = function isConstructor2(argument) {
      if (!isCallable$a(argument))
        return false;
      try {
        construct(noop, empty, argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor2(argument) {
      if (!isCallable$a(argument))
        return false;
      switch (classof$6(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    var isConstructor$2 = !construct || fails$a(function() {
      var called2;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called2 = true;
      }) || called2;
    }) ? isConstructorLegacy : isConstructorModern;
    var isArray$1 = isArray$2;
    var isConstructor$1 = isConstructor$2;
    var isObject$9 = isObject$f;
    var wellKnownSymbol$d = wellKnownSymbol$h;
    var SPECIES$4 = wellKnownSymbol$d("species");
    var $Array$1 = Array;
    var arraySpeciesConstructor$1 = function(originalArray) {
      var C2;
      if (isArray$1(originalArray)) {
        C2 = originalArray.constructor;
        if (isConstructor$1(C2) && (C2 === $Array$1 || isArray$1(C2.prototype)))
          C2 = void 0;
        else if (isObject$9(C2)) {
          C2 = C2[SPECIES$4];
          if (C2 === null)
            C2 = void 0;
        }
      }
      return C2 === void 0 ? $Array$1 : C2;
    };
    var arraySpeciesConstructor = arraySpeciesConstructor$1;
    var arraySpeciesCreate$2 = function(originalArray, length2) {
      return new (arraySpeciesConstructor(originalArray))(length2 === 0 ? 0 : length2);
    };
    var fails$9 = fails$j;
    var wellKnownSymbol$c = wellKnownSymbol$h;
    var V8_VERSION$2 = engineV8Version;
    var SPECIES$3 = wellKnownSymbol$c("species");
    var arrayMethodHasSpeciesSupport$1 = function(METHOD_NAME) {
      return V8_VERSION$2 >= 51 || !fails$9(function() {
        var array2 = [];
        var constructor = array2.constructor = {};
        constructor[SPECIES$3] = function() {
          return { foo: 1 };
        };
        return array2[METHOD_NAME](Boolean).foo !== 1;
      });
    };
    var $$a = _export;
    var fails$8 = fails$j;
    var isArray = isArray$2;
    var isObject$8 = isObject$f;
    var toObject$3 = toObject$5;
    var lengthOfArrayLike$3 = lengthOfArrayLike$5;
    var doesNotExceedSafeInteger = doesNotExceedSafeInteger$1;
    var createProperty$1 = createProperty$2;
    var arraySpeciesCreate$1 = arraySpeciesCreate$2;
    var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$1;
    var wellKnownSymbol$b = wellKnownSymbol$h;
    var V8_VERSION$1 = engineV8Version;
    var IS_CONCAT_SPREADABLE = wellKnownSymbol$b("isConcatSpreadable");
    var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION$1 >= 51 || !fails$8(function() {
      var array2 = [];
      array2[IS_CONCAT_SPREADABLE] = false;
      return array2.concat()[0] !== array2;
    });
    var isConcatSpreadable = function(O) {
      if (!isObject$8(O))
        return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== void 0 ? !!spreadable : isArray(O);
    };
    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
    $$a({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat2(arg) {
        var O = toObject$3(this);
        var A5 = arraySpeciesCreate$1(O, 0);
        var n = 0;
        var i, k2, length2, len, E2;
        for (i = -1, length2 = arguments.length; i < length2; i++) {
          E2 = i === -1 ? O : arguments[i];
          if (isConcatSpreadable(E2)) {
            len = lengthOfArrayLike$3(E2);
            doesNotExceedSafeInteger(n + len);
            for (k2 = 0; k2 < len; k2++, n++)
              if (k2 in E2)
                createProperty$1(A5, n, E2[k2]);
          } else {
            doesNotExceedSafeInteger(n + 1);
            createProperty$1(A5, n++, E2);
          }
        }
        A5.length = n;
        return A5;
      }
    });
    var makeBuiltIn = makeBuiltInExports;
    var defineProperty$5 = objectDefineProperty;
    var defineBuiltInAccessor$2 = function(target, name, descriptor) {
      if (descriptor.get)
        makeBuiltIn(descriptor.get, name, { getter: true });
      if (descriptor.set)
        makeBuiltIn(descriptor.set, name, { setter: true });
      return defineProperty$5.f(target, name, descriptor);
    };
    var DESCRIPTORS$4 = descriptors;
    var FUNCTION_NAME_EXISTS = functionName.EXISTS;
    var uncurryThis$a = functionUncurryThis;
    var defineBuiltInAccessor$1 = defineBuiltInAccessor$2;
    var FunctionPrototype$1 = Function.prototype;
    var functionToString = uncurryThis$a(FunctionPrototype$1.toString);
    var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
    var regExpExec = uncurryThis$a(nameRE.exec);
    var NAME = "name";
    if (DESCRIPTORS$4 && !FUNCTION_NAME_EXISTS) {
      defineBuiltInAccessor$1(FunctionPrototype$1, NAME, {
        configurable: true,
        get: function() {
          try {
            return regExpExec(nameRE, functionToString(this))[1];
          } catch (error) {
            return "";
          }
        }
      });
    }
    var internalObjectKeys = objectKeysInternal;
    var enumBugKeys$1 = enumBugKeys$3;
    var objectKeys$2 = Object.keys || function keys2(O) {
      return internalObjectKeys(O, enumBugKeys$1);
    };
    var DESCRIPTORS$3 = descriptors;
    var uncurryThis$9 = functionUncurryThis;
    var call$9 = functionCall;
    var fails$7 = fails$j;
    var objectKeys$1 = objectKeys$2;
    var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
    var propertyIsEnumerableModule = objectPropertyIsEnumerable;
    var toObject$2 = toObject$5;
    var IndexedObject$1 = indexedObject;
    var $assign = Object.assign;
    var defineProperty$4 = Object.defineProperty;
    var concat = uncurryThis$9([].concat);
    var objectAssign = !$assign || fails$7(function() {
      if (DESCRIPTORS$3 && $assign({ b: 1 }, $assign(defineProperty$4({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty$4(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), { b: 2 })).b !== 1)
        return true;
      var A5 = {};
      var B2 = {};
      var symbol2 = Symbol("assign detection");
      var alphabet = "abcdefghijklmnopqrst";
      A5[symbol2] = 7;
      alphabet.split("").forEach(function(chr) {
        B2[chr] = chr;
      });
      return $assign({}, A5)[symbol2] !== 7 || objectKeys$1($assign({}, B2)).join("") !== alphabet;
    }) ? function assign2(target, source) {
      var T = toObject$2(target);
      var argumentsLength = arguments.length;
      var index = 1;
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      var propertyIsEnumerable2 = propertyIsEnumerableModule.f;
      while (argumentsLength > index) {
        var S = IndexedObject$1(arguments[index++]);
        var keys2 = getOwnPropertySymbols ? concat(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);
        var length2 = keys2.length;
        var j = 0;
        var key;
        while (length2 > j) {
          key = keys2[j++];
          if (!DESCRIPTORS$3 || call$9(propertyIsEnumerable2, S, key))
            T[key] = S[key];
        }
      }
      return T;
    } : $assign;
    var $$9 = _export;
    var assign = objectAssign;
    $$9({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign }, {
      assign
    });
    var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
    var classof$5 = classof$7;
    var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString2() {
      return "[object " + classof$5(this) + "]";
    };
    var TO_STRING_TAG_SUPPORT = toStringTagSupport;
    var defineBuiltIn$6 = defineBuiltIn$8;
    var toString$3 = objectToString;
    if (!TO_STRING_TAG_SUPPORT) {
      defineBuiltIn$6(Object.prototype, "toString", toString$3, { unsafe: true });
    }
    var global$8 = global$j;
    var classof$4 = classofRaw$2;
    var engineIsNode = classof$4(global$8.process) === "process";
    var uncurryThis$8 = functionUncurryThis;
    var aCallable$6 = aCallable$8;
    var functionUncurryThisAccessor = function(object2, key, method2) {
      try {
        return uncurryThis$8(aCallable$6(Object.getOwnPropertyDescriptor(object2, key)[method2]));
      } catch (error) {
      }
    };
    var isCallable$9 = isCallable$m;
    var $String$1 = String;
    var $TypeError$6 = TypeError;
    var aPossiblePrototype$1 = function(argument) {
      if (typeof argument == "object" || isCallable$9(argument))
        return argument;
      throw new $TypeError$6("Can't set " + $String$1(argument) + " as a prototype");
    };
    var uncurryThisAccessor = functionUncurryThisAccessor;
    var anObject$8 = anObject$b;
    var aPossiblePrototype = aPossiblePrototype$1;
    var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test2 = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test2, []);
        CORRECT_SETTER = test2 instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf2(O, proto) {
        anObject$8(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER)
          setter(O, proto);
        else
          O.__proto__ = proto;
        return O;
      };
    }() : void 0);
    var defineProperty$3 = objectDefineProperty.f;
    var hasOwn$4 = hasOwnProperty_1;
    var wellKnownSymbol$a = wellKnownSymbol$h;
    var TO_STRING_TAG = wellKnownSymbol$a("toStringTag");
    var setToStringTag$5 = function(target, TAG, STATIC) {
      if (target && !STATIC)
        target = target.prototype;
      if (target && !hasOwn$4(target, TO_STRING_TAG)) {
        defineProperty$3(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };
    var getBuiltIn$3 = getBuiltIn$7;
    var defineBuiltInAccessor = defineBuiltInAccessor$2;
    var wellKnownSymbol$9 = wellKnownSymbol$h;
    var DESCRIPTORS$2 = descriptors;
    var SPECIES$2 = wellKnownSymbol$9("species");
    var setSpecies$1 = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);
      if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$2]) {
        defineBuiltInAccessor(Constructor, SPECIES$2, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
    var isPrototypeOf$1 = objectIsPrototypeOf;
    var $TypeError$5 = TypeError;
    var anInstance$3 = function(it, Prototype) {
      if (isPrototypeOf$1(Prototype, it))
        return it;
      throw new $TypeError$5("Incorrect invocation");
    };
    var isConstructor = isConstructor$2;
    var tryToString$2 = tryToString$4;
    var $TypeError$4 = TypeError;
    var aConstructor$1 = function(argument) {
      if (isConstructor(argument))
        return argument;
      throw new $TypeError$4(tryToString$2(argument) + " is not a constructor");
    };
    var anObject$7 = anObject$b;
    var aConstructor = aConstructor$1;
    var isNullOrUndefined$3 = isNullOrUndefined$6;
    var wellKnownSymbol$8 = wellKnownSymbol$h;
    var SPECIES$1 = wellKnownSymbol$8("species");
    var speciesConstructor$1 = function(O, defaultConstructor) {
      var C2 = anObject$7(O).constructor;
      var S;
      return C2 === void 0 || isNullOrUndefined$3(S = anObject$7(C2)[SPECIES$1]) ? defaultConstructor : aConstructor(S);
    };
    var NATIVE_BIND$1 = functionBindNative;
    var FunctionPrototype = Function.prototype;
    var apply$1 = FunctionPrototype.apply;
    var call$8 = FunctionPrototype.call;
    var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$1 ? call$8.bind(apply$1) : function() {
      return call$8.apply(apply$1, arguments);
    });
    var classofRaw = classofRaw$2;
    var uncurryThis$7 = functionUncurryThis;
    var functionUncurryThisClause = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis$7(fn);
    };
    var uncurryThis$6 = functionUncurryThisClause;
    var aCallable$5 = aCallable$8;
    var NATIVE_BIND = functionBindNative;
    var bind$5 = uncurryThis$6(uncurryThis$6.bind);
    var functionBindContext = function(fn, that) {
      aCallable$5(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind$5(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
    var getBuiltIn$2 = getBuiltIn$7;
    var html$2 = getBuiltIn$2("document", "documentElement");
    var uncurryThis$5 = functionUncurryThis;
    var arraySlice$2 = uncurryThis$5([].slice);
    var $TypeError$3 = TypeError;
    var validateArgumentsLength$1 = function(passed, required) {
      if (passed < required)
        throw new $TypeError$3("Not enough arguments");
      return passed;
    };
    var userAgent$2 = engineUserAgent;
    var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);
    var global$7 = global$j;
    var apply = functionApply;
    var bind$4 = functionBindContext;
    var isCallable$8 = isCallable$m;
    var hasOwn$3 = hasOwnProperty_1;
    var fails$6 = fails$j;
    var html$1 = html$2;
    var arraySlice$1 = arraySlice$2;
    var createElement = documentCreateElement$2;
    var validateArgumentsLength = validateArgumentsLength$1;
    var IS_IOS$1 = engineIsIos;
    var IS_NODE$3 = engineIsNode;
    var set = global$7.setImmediate;
    var clear = global$7.clearImmediate;
    var process$2 = global$7.process;
    var Dispatch = global$7.Dispatch;
    var Function$1 = global$7.Function;
    var MessageChannel = global$7.MessageChannel;
    var String$1 = global$7.String;
    var counter = 0;
    var queue$2 = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location, defer, channel, port;
    fails$6(function() {
      $location = global$7.location;
    });
    var run = function(id2) {
      if (hasOwn$3(queue$2, id2)) {
        var fn = queue$2[id2];
        delete queue$2[id2];
        fn();
      }
    };
    var runner = function(id2) {
      return function() {
        run(id2);
      };
    };
    var eventListener = function(event) {
      run(event.data);
    };
    var globalPostMessageDefer = function(id2) {
      global$7.postMessage(String$1(id2), $location.protocol + "//" + $location.host);
    };
    if (!set || !clear) {
      set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable$8(handler) ? handler : Function$1(handler);
        var args = arraySlice$1(arguments, 1);
        queue$2[++counter] = function() {
          apply(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id2) {
        delete queue$2[id2];
      };
      if (IS_NODE$3) {
        defer = function(id2) {
          process$2.nextTick(runner(id2));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id2) {
          Dispatch.now(runner(id2));
        };
      } else if (MessageChannel && !IS_IOS$1) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind$4(port.postMessage, port);
      } else if (global$7.addEventListener && isCallable$8(global$7.postMessage) && !global$7.importScripts && $location && $location.protocol !== "file:" && !fails$6(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        global$7.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id2) {
          html$1.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html$1.removeChild(this);
            run(id2);
          };
        };
      } else {
        defer = function(id2) {
          setTimeout(runner(id2), 0);
        };
      }
    }
    var task$1 = {
      set,
      clear
    };
    var Queue$2 = function() {
      this.head = null;
      this.tail = null;
    };
    Queue$2.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null)
            this.tail = null;
          return entry.item;
        }
      }
    };
    var queue$1 = Queue$2;
    var userAgent$1 = engineUserAgent;
    var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && typeof Pebble != "undefined";
    var userAgent = engineUserAgent;
    var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);
    var global$6 = global$j;
    var bind$3 = functionBindContext;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var macrotask = task$1.set;
    var Queue$1 = queue$1;
    var IS_IOS = engineIsIos;
    var IS_IOS_PEBBLE = engineIsIosPebble;
    var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
    var IS_NODE$2 = engineIsNode;
    var MutationObserver$1 = global$6.MutationObserver || global$6.WebKitMutationObserver;
    var document$2 = global$6.document;
    var process$1 = global$6.process;
    var Promise$1 = global$6.Promise;
    var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$6, "queueMicrotask");
    var microtask$1 = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    var notify$1, toggle, node, promise, then;
    if (!microtask$1) {
      var queue = new Queue$1();
      var flush = function() {
        var parent, fn;
        if (IS_NODE$2 && (parent = process$1.domain))
          parent.exit();
        while (fn = queue.get())
          try {
            fn();
          } catch (error) {
            if (queue.head)
              notify$1();
            throw error;
          }
        if (parent)
          parent.enter();
      };
      if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver$1 && document$2) {
        toggle = true;
        node = document$2.createTextNode("");
        new MutationObserver$1(flush).observe(node, { characterData: true });
        notify$1 = function() {
          node.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
        promise = Promise$1.resolve(void 0);
        promise.constructor = Promise$1;
        then = bind$3(promise.then, promise);
        notify$1 = function() {
          then(flush);
        };
      } else if (IS_NODE$2) {
        notify$1 = function() {
          process$1.nextTick(flush);
        };
      } else {
        macrotask = bind$3(macrotask, global$6);
        notify$1 = function() {
          macrotask(flush);
        };
      }
      microtask$1 = function(fn) {
        if (!queue.head)
          notify$1();
        queue.add(fn);
      };
    }
    var microtask_1 = microtask$1;
    var hostReportErrors$1 = function(a2, b) {
      try {
        arguments.length === 1 ? console.error(a2) : console.error(a2, b);
      } catch (error) {
      }
    };
    var perform$3 = function(exec2) {
      try {
        return { error: false, value: exec2() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
    var global$5 = global$j;
    var promiseNativeConstructor = global$5.Promise;
    var engineIsDeno = typeof Deno == "object" && Deno && typeof Deno.version == "object";
    var IS_DENO$1 = engineIsDeno;
    var IS_NODE$1 = engineIsNode;
    var engineIsBrowser = !IS_DENO$1 && !IS_NODE$1 && typeof window == "object" && typeof document == "object";
    var global$4 = global$j;
    var NativePromiseConstructor$3 = promiseNativeConstructor;
    var isCallable$7 = isCallable$m;
    var isForced$1 = isForced_1;
    var inspectSource = inspectSource$3;
    var wellKnownSymbol$7 = wellKnownSymbol$h;
    var IS_BROWSER = engineIsBrowser;
    var IS_DENO = engineIsDeno;
    var V8_VERSION = engineV8Version;
    NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
    var SPECIES = wellKnownSymbol$7("species");
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$7(global$4.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR$5 = isForced$1("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
        return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise2 = new NativePromiseConstructor$3(function(resolve) {
          resolve(1);
        });
        var FakePromise = function(exec2) {
          exec2(function() {
          }, function() {
          });
        };
        var constructor = promise2.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise2.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING)
          return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT$1;
    });
    var promiseConstructorDetection = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
      SUBCLASSING
    };
    var newPromiseCapability$2 = {};
    var aCallable$4 = aCallable$8;
    var $TypeError$2 = TypeError;
    var PromiseCapability = function(C2) {
      var resolve, reject;
      this.promise = new C2(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0)
          throw new $TypeError$2("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable$4(resolve);
      this.reject = aCallable$4(reject);
    };
    newPromiseCapability$2.f = function(C2) {
      return new PromiseCapability(C2);
    };
    var $$8 = _export;
    var IS_NODE = engineIsNode;
    var global$3 = global$j;
    var call$7 = functionCall;
    var defineBuiltIn$5 = defineBuiltIn$8;
    var setPrototypeOf$2 = objectSetPrototypeOf;
    var setToStringTag$4 = setToStringTag$5;
    var setSpecies = setSpecies$1;
    var aCallable$3 = aCallable$8;
    var isCallable$6 = isCallable$m;
    var isObject$7 = isObject$f;
    var anInstance$2 = anInstance$3;
    var speciesConstructor = speciesConstructor$1;
    var task = task$1.set;
    var microtask = microtask_1;
    var hostReportErrors = hostReportErrors$1;
    var perform$2 = perform$3;
    var Queue = queue$1;
    var InternalStateModule$3 = internalState;
    var NativePromiseConstructor$2 = promiseNativeConstructor;
    var PromiseConstructorDetection = promiseConstructorDetection;
    var newPromiseCapabilityModule$3 = newPromiseCapability$2;
    var PROMISE = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule$3.getterFor(PROMISE);
    var setInternalState$3 = InternalStateModule$3.set;
    var NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;
    var PromiseConstructor = NativePromiseConstructor$2;
    var PromisePrototype = NativePromisePrototype$1;
    var TypeError$1 = global$3.TypeError;
    var document$1 = global$3.document;
    var process = global$3.process;
    var newPromiseCapability$1 = newPromiseCapabilityModule$3.f;
    var newGenericPromiseCapability = newPromiseCapability$1;
    var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$3.dispatchEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
    var isThenable = function(it) {
      var then2;
      return isObject$7(it) && isCallable$6(then2 = it.then) ? then2 : false;
    };
    var callReaction = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then2, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED)
              onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true)
            result = value;
          else {
            if (domain)
              domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError$1("Promise-chain cycle"));
          } else if (then2 = isThenable(result)) {
            call$7(then2, result, resolve, reject);
          } else
            resolve(result);
        } else
          reject(value);
      } catch (error) {
        if (domain && !exited)
          domain.exit();
        reject(error);
      }
    };
    var notify = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    };
    var dispatchEvent = function(name, promise2, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document$1.createEvent("Event");
        event.promise = promise2;
        event.reason = reason;
        event.initEvent(name, false, true);
        global$3.dispatchEvent(event);
      } else
        event = { promise: promise2, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$3["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      call$7(task, global$3, function() {
        var promise2 = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform$2(function() {
            if (IS_NODE) {
              process.emit("unhandledRejection", value, promise2);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise2, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      call$7(task, global$3, function() {
        var promise2 = state.facade;
        if (IS_NODE) {
          process.emit("rejectionHandled", promise2);
        } else
          dispatchEvent(REJECTION_HANDLED, promise2, state.value);
      });
    };
    var bind$2 = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw new TypeError$1("Promise can't be resolved itself");
        var then2 = isThenable(value);
        if (then2) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call$7(
                then2,
                value,
                bind$2(internalResolve, wrapper, state),
                bind$2(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR$4) {
      PromiseConstructor = function Promise2(executor) {
        anInstance$2(this, PromisePrototype);
        aCallable$3(executor);
        call$7(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind$2(internalResolve, state), bind$2(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState$3(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: void 0
        });
      };
      Internal.prototype = defineBuiltIn$5(PromisePrototype, "then", function then2(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable$6(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable$6(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process.domain : void 0;
        if (state.state === PENDING)
          state.reactions.add(reaction);
        else
          microtask(function() {
            callReaction(reaction, state);
          });
        return reaction.promise;
      });
      OwnPromiseCapability = function() {
        var promise2 = new Internal();
        var state = getInternalPromiseState(promise2);
        this.promise = promise2;
        this.resolve = bind$2(internalResolve, state);
        this.reject = bind$2(internalReject, state);
      };
      newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function(C2) {
        return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
      };
      if (isCallable$6(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {
        nativeThen = NativePromisePrototype$1.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn$5(NativePromisePrototype$1, "then", function then2(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              call$7(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype$1.constructor;
        } catch (error) {
        }
        if (setPrototypeOf$2) {
          setPrototypeOf$2(NativePromisePrototype$1, PromisePrototype);
        }
      }
    }
    $$8({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
      Promise: PromiseConstructor
    });
    setToStringTag$4(PromiseConstructor, PROMISE, false);
    setSpecies(PROMISE);
    var iterators = {};
    var wellKnownSymbol$6 = wellKnownSymbol$h;
    var Iterators$4 = iterators;
    var ITERATOR$5 = wellKnownSymbol$6("iterator");
    var ArrayPrototype$1 = Array.prototype;
    var isArrayIteratorMethod$1 = function(it) {
      return it !== void 0 && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);
    };
    var classof$3 = classof$7;
    var getMethod$1 = getMethod$3;
    var isNullOrUndefined$2 = isNullOrUndefined$6;
    var Iterators$3 = iterators;
    var wellKnownSymbol$5 = wellKnownSymbol$h;
    var ITERATOR$4 = wellKnownSymbol$5("iterator");
    var getIteratorMethod$2 = function(it) {
      if (!isNullOrUndefined$2(it))
        return getMethod$1(it, ITERATOR$4) || getMethod$1(it, "@@iterator") || Iterators$3[classof$3(it)];
    };
    var call$6 = functionCall;
    var aCallable$2 = aCallable$8;
    var anObject$6 = anObject$b;
    var tryToString$1 = tryToString$4;
    var getIteratorMethod$1 = getIteratorMethod$2;
    var $TypeError$1 = TypeError;
    var getIterator$1 = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
      if (aCallable$2(iteratorMethod))
        return anObject$6(call$6(iteratorMethod, argument));
      throw new $TypeError$1(tryToString$1(argument) + " is not iterable");
    };
    var call$5 = functionCall;
    var anObject$5 = anObject$b;
    var getMethod = getMethod$3;
    var iteratorClose$1 = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject$5(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call$5(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject$5(innerResult);
      return value;
    };
    var bind$1 = functionBindContext;
    var call$4 = functionCall;
    var anObject$4 = anObject$b;
    var tryToString = tryToString$4;
    var isArrayIteratorMethod = isArrayIteratorMethod$1;
    var lengthOfArrayLike$2 = lengthOfArrayLike$5;
    var isPrototypeOf = objectIsPrototypeOf;
    var getIterator = getIterator$1;
    var getIteratorMethod = getIteratorMethod$2;
    var iteratorClose = iteratorClose$1;
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    var iterate$4 = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind$1(unboundFunction, that);
      var iterator, iterFn, index, length2, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject$4(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw new $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length2 = lengthOfArrayLike$2(iterable); length2 > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call$4(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    };
    var wellKnownSymbol$4 = wellKnownSymbol$h;
    var ITERATOR$3 = wellKnownSymbol$4("iterator");
    var SAFE_CLOSING = false;
    try {
      var called = 0;
      var iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR$3] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var checkCorrectnessOfIteration$2 = function(exec2, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING)
          return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object2 = {};
        object2[ITERATOR$3] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec2(object2);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
    var NativePromiseConstructor$1 = promiseNativeConstructor;
    var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;
    var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
    var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$1(function(iterable) {
      NativePromiseConstructor$1.all(iterable).then(void 0, function() {
      });
    });
    var $$7 = _export;
    var call$3 = functionCall;
    var aCallable$1 = aCallable$8;
    var newPromiseCapabilityModule$2 = newPromiseCapability$2;
    var perform$1 = perform$3;
    var iterate$3 = iterate$4;
    var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;
    $$7({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {
      all: function all(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule$2.f(C2);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform$1(function() {
          var $promiseResolve = aCallable$1(C2.resolve);
          var values2 = [];
          var counter2 = 0;
          var remaining = 1;
          iterate$3(iterable, function(promise2) {
            var index = counter2++;
            var alreadyCalled = false;
            remaining++;
            call$3($promiseResolve, C2, promise2).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values2[index] = value;
              --remaining || resolve(values2);
            }, reject);
          });
          --remaining || resolve(values2);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
    var $$6 = _export;
    var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
    var NativePromiseConstructor = promiseNativeConstructor;
    var getBuiltIn$1 = getBuiltIn$7;
    var isCallable$5 = isCallable$m;
    var defineBuiltIn$4 = defineBuiltIn$8;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $$6({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (isCallable$5(NativePromiseConstructor)) {
      var method = getBuiltIn$1("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn$4(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    var $$5 = _export;
    var call$2 = functionCall;
    var aCallable = aCallable$8;
    var newPromiseCapabilityModule$1 = newPromiseCapability$2;
    var perform = perform$3;
    var iterate$2 = iterate$4;
    var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;
    $$5({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: function race(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule$1.f(C2);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C2.resolve);
          iterate$2(iterable, function(promise2) {
            call$2($promiseResolve, C2, promise2).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
    var $$4 = _export;
    var call$1 = functionCall;
    var newPromiseCapabilityModule = newPromiseCapability$2;
    var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
    $$4({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
      reject: function reject(r) {
        var capability = newPromiseCapabilityModule.f(this);
        call$1(capability.reject, void 0, r);
        return capability.promise;
      }
    });
    var anObject$3 = anObject$b;
    var isObject$6 = isObject$f;
    var newPromiseCapability = newPromiseCapability$2;
    var promiseResolve$1 = function(C2, x) {
      anObject$3(C2);
      if (isObject$6(x) && x.constructor === C2)
        return x;
      var promiseCapability = newPromiseCapability.f(C2);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };
    var $$3 = _export;
    var getBuiltIn = getBuiltIn$7;
    var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
    var promiseResolve = promiseResolve$1;
    getBuiltIn("Promise");
    $$3({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: function resolve(x) {
        return promiseResolve(this, x);
      }
    });
    var objectDefineProperties = {};
    var DESCRIPTORS$1 = descriptors;
    var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
    var definePropertyModule = objectDefineProperty;
    var anObject$2 = anObject$b;
    var toIndexedObject$2 = toIndexedObject$6;
    var objectKeys = objectKeys$2;
    objectDefineProperties.f = DESCRIPTORS$1 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject$2(O);
      var props = toIndexedObject$2(Properties);
      var keys2 = objectKeys(Properties);
      var length2 = keys2.length;
      var index = 0;
      var key;
      while (length2 > index)
        definePropertyModule.f(O, key = keys2[index++], props[key]);
      return O;
    };
    var anObject$1 = anObject$b;
    var definePropertiesModule = objectDefineProperties;
    var enumBugKeys = enumBugKeys$3;
    var hiddenKeys$1 = hiddenKeys$5;
    var html = html$2;
    var documentCreateElement$1 = documentCreateElement$2;
    var sharedKey$1 = sharedKey$3;
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO$1 = sharedKey$1("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement$1("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length2 = enumBugKeys.length;
      while (length2--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length2]];
      return NullProtoObject();
    };
    hiddenKeys$1[IE_PROTO$1] = true;
    var objectCreate = Object.create || function create2(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject$1(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO$1] = O;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
    var wellKnownSymbol$3 = wellKnownSymbol$h;
    var create$1 = objectCreate;
    var defineProperty$2 = objectDefineProperty.f;
    var UNSCOPABLES = wellKnownSymbol$3("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === void 0) {
      defineProperty$2(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create$1(null)
      });
    }
    var addToUnscopables$1 = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
    var fails$5 = fails$j;
    var correctPrototypeGetter = !fails$5(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
    var hasOwn$2 = hasOwnProperty_1;
    var isCallable$4 = isCallable$m;
    var toObject$1 = toObject$5;
    var sharedKey = sharedKey$3;
    var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
    var IE_PROTO = sharedKey("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
      var object2 = toObject$1(O);
      if (hasOwn$2(object2, IE_PROTO))
        return object2[IE_PROTO];
      var constructor = object2.constructor;
      if (isCallable$4(constructor) && object2 instanceof constructor) {
        return constructor.prototype;
      }
      return object2 instanceof $Object ? ObjectPrototype : null;
    };
    var fails$4 = fails$j;
    var isCallable$3 = isCallable$m;
    var isObject$5 = isObject$f;
    var getPrototypeOf$1 = objectGetPrototypeOf;
    var defineBuiltIn$3 = defineBuiltIn$8;
    var wellKnownSymbol$2 = wellKnownSymbol$h;
    var ITERATOR$2 = wellKnownSymbol$2("iterator");
    var BUGGY_SAFARI_ITERATORS$1 = false;
    var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS$1 = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject$5(IteratorPrototype$2) || fails$4(function() {
      var test2 = {};
      return IteratorPrototype$2[ITERATOR$2].call(test2) !== test2;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype$2 = {};
    if (!isCallable$3(IteratorPrototype$2[ITERATOR$2])) {
      defineBuiltIn$3(IteratorPrototype$2, ITERATOR$2, function() {
        return this;
      });
    }
    var iteratorsCore = {
      IteratorPrototype: IteratorPrototype$2,
      BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
    };
    var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
    var create = objectCreate;
    var createPropertyDescriptor = createPropertyDescriptor$4;
    var setToStringTag$3 = setToStringTag$5;
    var Iterators$2 = iterators;
    var returnThis$1 = function() {
      return this;
    };
    var iteratorCreateConstructor = function(IteratorConstructor, NAME2, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG2 = NAME2 + " Iterator";
      IteratorConstructor.prototype = create(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag$3(IteratorConstructor, TO_STRING_TAG2, false);
      Iterators$2[TO_STRING_TAG2] = returnThis$1;
      return IteratorConstructor;
    };
    var $$2 = _export;
    var call = functionCall;
    var FunctionName = functionName;
    var isCallable$2 = isCallable$m;
    var createIteratorConstructor = iteratorCreateConstructor;
    var getPrototypeOf = objectGetPrototypeOf;
    var setPrototypeOf$1 = objectSetPrototypeOf;
    var setToStringTag$2 = setToStringTag$5;
    var createNonEnumerableProperty$1 = createNonEnumerableProperty$4;
    var defineBuiltIn$2 = defineBuiltIn$8;
    var wellKnownSymbol$1 = wellKnownSymbol$h;
    var Iterators$1 = iterators;
    var IteratorsCore = iteratorsCore;
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR$1 = wellKnownSymbol$1("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    var iteratorDefine = function(Iterable, NAME2, IteratorConstructor, next, DEFAULT, IS_SET, FORCED2) {
      createIteratorConstructor(IteratorConstructor, NAME2, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys2() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values2() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG2 = NAME2 + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME2 === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf$1) {
              setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable$2(CurrentIteratorPrototype[ITERATOR$1])) {
              defineBuiltIn$2(CurrentIteratorPrototype, ITERATOR$1, returnThis);
            }
          }
          setToStringTag$2(CurrentIteratorPrototype, TO_STRING_TAG2, true);
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty$1(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values2() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED2)
          for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn$2(IterablePrototype, KEY, methods[KEY]);
            }
          }
        else
          $$2({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
        defineBuiltIn$2(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
      }
      Iterators$1[NAME2] = defaultIterator;
      return methods;
    };
    var createIterResultObject$2 = function(value, done) {
      return { value, done };
    };
    var toIndexedObject$1 = toIndexedObject$6;
    var addToUnscopables = addToUnscopables$1;
    var Iterators = iterators;
    var InternalStateModule$2 = internalState;
    var defineProperty$1 = objectDefineProperty.f;
    var defineIterator$1 = iteratorDefine;
    var createIterResultObject$1 = createIterResultObject$2;
    var DESCRIPTORS = descriptors;
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState$2 = InternalStateModule$2.set;
    var getInternalState$1 = InternalStateModule$2.getterFor(ARRAY_ITERATOR);
    var es_array_iterator = defineIterator$1(Array, "Array", function(iterated, kind) {
      setInternalState$2(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject$1(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState$1(this);
      var target = state.target;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = void 0;
        return createIterResultObject$1(void 0, true);
      }
      switch (state.kind) {
        case "keys":
          return createIterResultObject$1(index, false);
        case "values":
          return createIterResultObject$1(target[index], false);
      }
      return createIterResultObject$1([index, target[index]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (DESCRIPTORS && values.name !== "values")
      try {
        defineProperty$1(values, "name", { value: "values" });
      } catch (error) {
      }
    var classof$2 = classof$7;
    var $String = String;
    var toString$2 = function(argument) {
      if (classof$2(argument) === "Symbol")
        throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
    var uncurryThis$4 = functionUncurryThis;
    var toIntegerOrInfinity = toIntegerOrInfinity$3;
    var toString$1 = toString$2;
    var requireObjectCoercible = requireObjectCoercible$3;
    var charAt$1 = uncurryThis$4("".charAt);
    var charCodeAt = uncurryThis$4("".charCodeAt);
    var stringSlice = uncurryThis$4("".slice);
    var createMethod$1 = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = toString$1(requireObjectCoercible($this));
        var position2 = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second2;
        if (position2 < 0 || position2 >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S, position2);
        return first < 55296 || first > 56319 || position2 + 1 === size || (second2 = charCodeAt(S, position2 + 1)) < 56320 || second2 > 57343 ? CONVERT_TO_STRING ? charAt$1(S, position2) : first : CONVERT_TO_STRING ? stringSlice(S, position2, position2 + 2) : (first - 55296 << 10) + (second2 - 56320) + 65536;
      };
    };
    var stringMultibyte = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod$1(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod$1(true)
    };
    var charAt = stringMultibyte.charAt;
    var toString = toString$2;
    var InternalStateModule$1 = internalState;
    var defineIterator = iteratorDefine;
    var createIterResultObject = createIterResultObject$2;
    var STRING_ITERATOR = "String Iterator";
    var setInternalState$1 = InternalStateModule$1.set;
    var getInternalState = InternalStateModule$1.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState$1(this, {
        type: STRING_ITERATOR,
        string: toString(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState(this);
      var string2 = state.string;
      var index = state.index;
      var point2;
      if (index >= string2.length)
        return createIterResultObject(void 0, true);
      point2 = charAt(string2, index);
      state.index += point2.length;
      return createIterResultObject(point2, false);
    });
    var internalMetadata = { exports: {} };
    var objectGetOwnPropertyNamesExternal = {};
    var toAbsoluteIndex = toAbsoluteIndex$2;
    var lengthOfArrayLike$1 = lengthOfArrayLike$5;
    var createProperty = createProperty$2;
    var $Array = Array;
    var max = Math.max;
    var arraySliceSimple = function(O, start2, end2) {
      var length2 = lengthOfArrayLike$1(O);
      var k2 = toAbsoluteIndex(start2, length2);
      var fin = toAbsoluteIndex(end2 === void 0 ? length2 : end2, length2);
      var result = $Array(max(fin - k2, 0));
      var n = 0;
      for (; k2 < fin; k2++, n++)
        createProperty(result, n, O[k2]);
      result.length = n;
      return result;
    };
    var classof$1 = classofRaw$2;
    var toIndexedObject = toIndexedObject$6;
    var $getOwnPropertyNames = objectGetOwnPropertyNames.f;
    var arraySlice = arraySliceSimple;
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function(it) {
      try {
        return $getOwnPropertyNames(it);
      } catch (error) {
        return arraySlice(windowNames);
      }
    };
    objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
      return windowNames && classof$1(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
    };
    var fails$3 = fails$j;
    var arrayBufferNonExtensible = fails$3(function() {
      if (typeof ArrayBuffer == "function") {
        var buffer = new ArrayBuffer(8);
        if (Object.isExtensible(buffer))
          Object.defineProperty(buffer, "a", { value: 8 });
      }
    });
    var fails$2 = fails$j;
    var isObject$4 = isObject$f;
    var classof = classofRaw$2;
    var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;
    var $isExtensible = Object.isExtensible;
    var FAILS_ON_PRIMITIVES = fails$2(function() {
      $isExtensible(1);
    });
    var objectIsExtensible = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible2(it) {
      if (!isObject$4(it))
        return false;
      if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer")
        return false;
      return $isExtensible ? $isExtensible(it) : true;
    } : $isExtensible;
    var fails$1 = fails$j;
    var freezing = !fails$1(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
    var $$1 = _export;
    var uncurryThis$3 = functionUncurryThis;
    var hiddenKeys = hiddenKeys$5;
    var isObject$3 = isObject$f;
    var hasOwn$1 = hasOwnProperty_1;
    var defineProperty = objectDefineProperty.f;
    var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
    var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
    var isExtensible = objectIsExtensible;
    var uid = uid$3;
    var FREEZING = freezing;
    var REQUIRED = false;
    var METADATA = uid("meta");
    var id$1 = 0;
    var setMetadata = function(it) {
      defineProperty(it, METADATA, { value: {
        objectID: "O" + id$1++,
        // object ID
        weakData: {}
        // weak collections IDs
      } });
    };
    var fastKey = function(it, create2) {
      if (!isObject$3(it))
        return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!hasOwn$1(it, METADATA)) {
        if (!isExtensible(it))
          return "F";
        if (!create2)
          return "E";
        setMetadata(it);
      }
      return it[METADATA].objectID;
    };
    var getWeakData$1 = function(it, create2) {
      if (!hasOwn$1(it, METADATA)) {
        if (!isExtensible(it))
          return true;
        if (!create2)
          return false;
        setMetadata(it);
      }
      return it[METADATA].weakData;
    };
    var onFreeze = function(it) {
      if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn$1(it, METADATA))
        setMetadata(it);
      return it;
    };
    var enable = function() {
      meta.enable = function() {
      };
      REQUIRED = true;
      var getOwnPropertyNames = getOwnPropertyNamesModule.f;
      var splice2 = uncurryThis$3([].splice);
      var test2 = {};
      test2[METADATA] = 1;
      if (getOwnPropertyNames(test2).length) {
        getOwnPropertyNamesModule.f = function(it) {
          var result = getOwnPropertyNames(it);
          for (var i = 0, length2 = result.length; i < length2; i++) {
            if (result[i] === METADATA) {
              splice2(result, i, 1);
              break;
            }
          }
          return result;
        };
        $$1({ target: "Object", stat: true, forced: true }, {
          getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
        });
      }
    };
    var meta = internalMetadata.exports = {
      enable,
      fastKey,
      getWeakData: getWeakData$1,
      onFreeze
    };
    hiddenKeys[METADATA] = true;
    var internalMetadataExports = internalMetadata.exports;
    var isCallable$1 = isCallable$m;
    var isObject$2 = isObject$f;
    var setPrototypeOf = objectSetPrototypeOf;
    var inheritIfRequired$1 = function($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (
        // it can work only with native `setPrototypeOf`
        setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        isCallable$1(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
      )
        setPrototypeOf($this, NewTargetPrototype);
      return $this;
    };
    var $ = _export;
    var global$2 = global$j;
    var uncurryThis$2 = functionUncurryThis;
    var isForced = isForced_1;
    var defineBuiltIn$1 = defineBuiltIn$8;
    var InternalMetadataModule = internalMetadataExports;
    var iterate$1 = iterate$4;
    var anInstance$1 = anInstance$3;
    var isCallable = isCallable$m;
    var isNullOrUndefined$1 = isNullOrUndefined$6;
    var isObject$1 = isObject$f;
    var fails = fails$j;
    var checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;
    var setToStringTag$1 = setToStringTag$5;
    var inheritIfRequired = inheritIfRequired$1;
    var collection$1 = function(CONSTRUCTOR_NAME, wrapper, common) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
      var ADDER = IS_MAP ? "set" : "add";
      var NativeConstructor = global$2[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var Constructor = NativeConstructor;
      var exported = {};
      var fixMethod = function(KEY) {
        var uncurriedNativeMethod = uncurryThis$2(NativePrototype[KEY]);
        defineBuiltIn$1(
          NativePrototype,
          KEY,
          KEY === "add" ? function add(value) {
            uncurriedNativeMethod(this, value === 0 ? 0 : value);
            return this;
          } : KEY === "delete" ? function(key) {
            return IS_WEAK && !isObject$1(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY === "get" ? function get2(key) {
            return IS_WEAK && !isObject$1(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY === "has" ? function has2(key) {
            return IS_WEAK && !isObject$1(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : function set2(key, value) {
            uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
            return this;
          }
        );
      };
      var REPLACE2 = isForced(
        CONSTRUCTOR_NAME,
        !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
          new NativeConstructor().entries().next();
        }))
      );
      if (REPLACE2) {
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule.enable();
      } else if (isForced(CONSTRUCTOR_NAME, true)) {
        var instance2 = new Constructor();
        var HASNT_CHAINING = instance2[ADDER](IS_WEAK ? {} : -0, 1) !== instance2;
        var THROWS_ON_PRIMITIVES = fails(function() {
          instance2.has(1);
        });
        var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
          new NativeConstructor(iterable);
        });
        var BUGGY_ZERO = !IS_WEAK && fails(function() {
          var $instance = new NativeConstructor();
          var index = 5;
          while (index--)
            $instance[ADDER](index, index);
          return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
          Constructor = wrapper(function(dummy, iterable) {
            anInstance$1(dummy, NativePrototype);
            var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
            if (!isNullOrUndefined$1(iterable))
              iterate$1(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
            return that;
          });
          Constructor.prototype = NativePrototype;
          NativePrototype.constructor = Constructor;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
          fixMethod("delete");
          fixMethod("has");
          IS_MAP && fixMethod("get");
        }
        if (BUGGY_ZERO || HASNT_CHAINING)
          fixMethod(ADDER);
        if (IS_WEAK && NativePrototype.clear)
          delete NativePrototype.clear;
      }
      exported[CONSTRUCTOR_NAME] = Constructor;
      $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
      setToStringTag$1(Constructor, CONSTRUCTOR_NAME);
      if (!IS_WEAK)
        common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };
    var defineBuiltIn = defineBuiltIn$8;
    var defineBuiltIns$1 = function(target, src, options) {
      for (var key in src)
        defineBuiltIn(target, key, src[key], options);
      return target;
    };
    var bind = functionBindContext;
    var uncurryThis$1 = functionUncurryThis;
    var IndexedObject = indexedObject;
    var toObject = toObject$5;
    var lengthOfArrayLike = lengthOfArrayLike$5;
    var arraySpeciesCreate = arraySpeciesCreate$2;
    var push = uncurryThis$1([].push);
    var createMethod = function(TYPE) {
      var IS_MAP = TYPE === 1;
      var IS_FILTER = TYPE === 2;
      var IS_SOME = TYPE === 3;
      var IS_EVERY = TYPE === 4;
      var IS_FIND_INDEX = TYPE === 6;
      var IS_FILTER_REJECT = TYPE === 7;
      var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self2 = IndexedObject(O);
        var length2 = lengthOfArrayLike(self2);
        var boundFunction = bind(callbackfn, that);
        var index = 0;
        var create2 = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create2($this, length2) : IS_FILTER || IS_FILTER_REJECT ? create2($this, 0) : void 0;
        var value, result;
        for (; length2 > index; index++)
          if (NO_HOLES || index in self2) {
            value = self2[index];
            result = boundFunction(value, index, O);
            if (TYPE) {
              if (IS_MAP)
                target[index] = result;
              else if (result)
                switch (TYPE) {
                  case 3:
                    return true;
                  case 5:
                    return value;
                  case 6:
                    return index;
                  case 2:
                    push(target, value);
                }
              else
                switch (TYPE) {
                  case 4:
                    return false;
                  case 7:
                    push(target, value);
                }
            }
          }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    var arrayIteration = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod(6),
      // `Array.prototype.filterReject` method
      // https://github.com/tc39/proposal-array-filtering
      filterReject: createMethod(7)
    };
    var uncurryThis = functionUncurryThis;
    var defineBuiltIns = defineBuiltIns$1;
    var getWeakData = internalMetadataExports.getWeakData;
    var anInstance = anInstance$3;
    var anObject = anObject$b;
    var isNullOrUndefined = isNullOrUndefined$6;
    var isObject = isObject$f;
    var iterate = iterate$4;
    var ArrayIterationModule = arrayIteration;
    var hasOwn = hasOwnProperty_1;
    var InternalStateModule = internalState;
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    var find = ArrayIterationModule.find;
    var findIndex = ArrayIterationModule.findIndex;
    var splice = uncurryThis([].splice);
    var id = 0;
    var uncaughtFrozenStore = function(state) {
      return state.frozen || (state.frozen = new UncaughtFrozenStore());
    };
    var UncaughtFrozenStore = function() {
      this.entries = [];
    };
    var findUncaughtFrozen = function(store2, key) {
      return find(store2.entries, function(it) {
        return it[0] === key;
      });
    };
    UncaughtFrozenStore.prototype = {
      get: function(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry)
          return entry[1];
      },
      has: function(key) {
        return !!findUncaughtFrozen(this, key);
      },
      set: function(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry)
          entry[1] = value;
        else
          this.entries.push([key, value]);
      },
      "delete": function(key) {
        var index = findIndex(this.entries, function(it) {
          return it[0] === key;
        });
        if (~index)
          splice(this.entries, index, 1);
        return !!~index;
      }
    };
    var collectionWeak$1 = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function(that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            id: id++,
            frozen: void 0
          });
          if (!isNullOrUndefined(iterable))
            iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var Prototype = Constructor.prototype;
        var getInternalState2 = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define2 = function(that, key, value) {
          var state = getInternalState2(that);
          var data2 = getWeakData(anObject(key), true);
          if (data2 === true)
            uncaughtFrozenStore(state).set(key, value);
          else
            data2[state.id] = value;
          return that;
        };
        defineBuiltIns(Prototype, {
          // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
          // https://tc39.es/ecma262/#sec-weakset.prototype.delete
          "delete": function(key) {
            var state = getInternalState2(this);
            if (!isObject(key))
              return false;
            var data2 = getWeakData(key);
            if (data2 === true)
              return uncaughtFrozenStore(state)["delete"](key);
            return data2 && hasOwn(data2, state.id) && delete data2[state.id];
          },
          // `{ WeakMap, WeakSet }.prototype.has(key)` methods
          // https://tc39.es/ecma262/#sec-weakmap.prototype.has
          // https://tc39.es/ecma262/#sec-weakset.prototype.has
          has: function has2(key) {
            var state = getInternalState2(this);
            if (!isObject(key))
              return false;
            var data2 = getWeakData(key);
            if (data2 === true)
              return uncaughtFrozenStore(state).has(key);
            return data2 && hasOwn(data2, state.id);
          }
        });
        defineBuiltIns(Prototype, IS_MAP ? {
          // `WeakMap.prototype.get(key)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.get
          get: function get2(key) {
            var state = getInternalState2(this);
            if (isObject(key)) {
              var data2 = getWeakData(key);
              if (data2 === true)
                return uncaughtFrozenStore(state).get(key);
              return data2 ? data2[state.id] : void 0;
            }
          },
          // `WeakMap.prototype.set(key, value)` method
          // https://tc39.es/ecma262/#sec-weakmap.prototype.set
          set: function set2(key, value) {
            return define2(this, key, value);
          }
        } : {
          // `WeakSet.prototype.add(value)` method
          // https://tc39.es/ecma262/#sec-weakset.prototype.add
          add: function add(value) {
            return define2(this, value, true);
          }
        });
        return Constructor;
      }
    };
    var collection = collection$1;
    var collectionWeak = collectionWeak$1;
    collection("WeakSet", function(init2) {
      return function WeakSet2() {
        return init2(this, arguments.length ? arguments[0] : void 0);
      };
    }, collectionWeak);
    var domIterables = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
    var documentCreateElement = documentCreateElement$2;
    var classList = documentCreateElement("span").classList;
    var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;
    var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;
    var global$1 = global$j;
    var DOMIterables = domIterables;
    var DOMTokenListPrototype = domTokenListPrototype;
    var ArrayIteratorMethods = es_array_iterator;
    var createNonEnumerableProperty = createNonEnumerableProperty$4;
    var setToStringTag = setToStringTag$5;
    var wellKnownSymbol = wellKnownSymbol$h;
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues)
          try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
        setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
        if (DOMIterables[COLLECTION_NAME2])
          for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
              try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
              }
          }
      }
    };
    for (var COLLECTION_NAME in DOMIterables) {
      handlePrototype(global$1[COLLECTION_NAME] && global$1[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
    function __classPrivateFieldGet(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    var _Tooltip_instances, _Tooltip_show, _Tooltip_hide;
    var DEFAULT_SELECTOR = "#ch-tooltip";
    var defaultOptions = {
      enabled: true,
      // Expecting a function, which will return the tooltip content
      text: function text2(_timestamp, value, dayjsDate) {
        return (
          // eslint-disable-next-line implicit-arrow-linebreak
          "".concat(value, " - ").concat(dayjsDate.format("LLLL"))
        );
      }
    };
    var DEFAULT_POPPER_OPTIONS = {
      placement: "top",
      modifiers: [{
        name: "offset",
        options: {
          offset: [0, 8]
        }
      }]
    };
    var virtualElement = {
      getBoundingClientRect: function getBoundingClientRect2() {
        var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return {
          width: 0,
          height: 0,
          top: y,
          right: x,
          bottom: y,
          left: x,
          x,
          y,
          toJSON: function toJSON() {
          }
        };
      }
    };
    var Tooltip = /* @__PURE__ */ function() {
      function Tooltip2(calendar2) {
        _classCallCheck(this, Tooltip2);
        _Tooltip_instances.add(this);
        this.name = "Tooltip";
        this.calendar = calendar2;
        this.root = null;
        this.popperInstance = null;
        this.options = defaultOptions;
        this.listenerAttached = false;
      }
      _createClass(Tooltip2, [{
        key: "setup",
        value: function setup(pluginOptions) {
          this.options = Object.assign(Object.assign({}, defaultOptions), pluginOptions);
          var event = this.calendar.eventEmitter;
          if (!this.options.enabled) {
            if (this.listenerAttached) {
              event.off("mouseover", this.mouseOverCallback, this);
              event.off("mouseout", this.mouseOutCallback, this);
              this.listenerAttached = false;
            }
            this.destroy();
            return;
          }
          this.popperOptions = Object.assign(Object.assign({}, DEFAULT_POPPER_OPTIONS), this.options);
          this.root = document.getElementById(DEFAULT_SELECTOR.slice(1));
          if (!this.root) {
            var tooltipElem = document.createElement("div");
            tooltipElem.setAttribute("id", DEFAULT_SELECTOR.slice(1));
            tooltipElem.setAttribute("role", "tooltip");
            tooltipElem.innerHTML = '<div id="'.concat(DEFAULT_SELECTOR.slice(1), '-arrow" data-popper-arrow="true"></div>') + '<span id="'.concat(DEFAULT_SELECTOR.slice(1), '-body"></span>');
            this.root = document.body.appendChild(tooltipElem);
          }
          this.root.setAttribute("data-theme", this.calendar.options.options.theme);
          this.popperInstance = createPopper(virtualElement, this.root, this.popperOptions);
          if (!this.listenerAttached) {
            event.on("mouseover", this.mouseOverCallback, this);
            event.on("mouseout", this.mouseOutCallback, this);
            this.listenerAttached = true;
          }
        }
      }, {
        key: "mouseOverCallback",
        value: function mouseOverCallback(e, timestamp, value) {
          __classPrivateFieldGet(this, _Tooltip_instances, "m", _Tooltip_show).call(this, e.target, timestamp, value);
        }
      }, {
        key: "mouseOutCallback",
        value: function mouseOutCallback() {
          __classPrivateFieldGet(this, _Tooltip_instances, "m", _Tooltip_hide).call(this);
        }
        // eslint-disable-next-line class-methods-use-this
      }, {
        key: "paint",
        value: function paint() {
          return Promise.resolve();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.root) {
            this.root.remove();
          }
          return Promise.resolve();
        }
      }]);
      return Tooltip2;
    }();
    _Tooltip_instances = /* @__PURE__ */ new WeakSet(), _Tooltip_show = function _Tooltip_show2(e, timestamp, value) {
      var _this = this;
      var formatter = this.options.text;
      var title = formatter ? formatter(timestamp, value, this.calendar.dateHelper.date(timestamp)) : null;
      if (!title) {
        return;
      }
      virtualElement.getBoundingClientRect = function() {
        return e.getBoundingClientRect();
      };
      document.getElementById("".concat(DEFAULT_SELECTOR.slice(1), "-body")).innerHTML = title;
      this.popperInstance.setOptions(function() {
        return Object.assign(Object.assign({}, _this.popperOptions), {
          modifiers: [].concat(_toConsumableArray(_this.popperOptions.modifiers), [{
            name: "eventListeners",
            enabled: true
          }])
        });
      });
      this.popperInstance.update();
      this.root.setAttribute("data-show", "1");
    }, _Tooltip_hide = function _Tooltip_hide2() {
      var _this2 = this;
      this.root.removeAttribute("data-show");
      this.popperInstance.setOptions(function() {
        return Object.assign(Object.assign({}, _this2.popperOptions), {
          modifiers: [].concat(_toConsumableArray(_this2.popperOptions.modifiers), [{
            name: "eventListeners",
            enabled: false
          }])
        });
      });
    };
    const CalHeatmap_svelte_svelte_type_style_lang = "";
    function create_fragment$2(ctx) {
      let div;
      return {
        c() {
          div = element("div");
          attr(div, "id", "cal-heatmap");
          attr(div, "class", "svelte-56wfia");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          ctx[3](div);
        },
        p: noop$5,
        i: noop$5,
        o: noop$5,
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          ctx[3](null);
        }
      };
    }
    const legendContainer = "#legend";
    const legendLabel = "Sim’s daily absent votes";
    function instance$2($$self, $$props, $$invalidate) {
      let { data: data2 = [] } = $$props;
      let cal, container;
      function initHeatmap() {
        $$invalidate(2, cal = new CalHeatmap());
        paintCal(cal, data2);
      }
      function paintCal(cal2, data3) {
        if (!cal2 || data3.length < 1)
          return;
        const domainMax = max$5(data3, (d) => +d.n);
        cal2.paint(
          {
            data: {
              source: data3,
              x: "vote_date",
              y: (d) => +d["n"]
            },
            date: {
              start: new Date(data3[0].vote_date),
              end: /* @__PURE__ */ new Date("2024-11-05")
            },
            // end: new Date(data[data.length - 1].vote_date)
            domain: {
              dynamicDimension: true,
              label: {
                height: 40,
                offset: { x: 0, y: -20 },
                position: top,
                text: "MMM YYYY",
                textAlign: "left"
              },
              padding: [10, 5, 20, 5],
              type: "month"
            },
            itemSelector: container,
            range: 25,
            scale: {
              color: {
                // type: 'linear',
                type: "quantile",
                scheme: "Blues",
                domain: [0, domainMax]
              }
            },
            subDomain: {
              type: "xDay",
              height: 25,
              width: 25,
              radius: 2,
              label: "D"
            },
            verticalOrientation: true
          },
          [
            [
              Legend,
              {
                itemSelector: legendContainer,
                label: legendLabel
              }
            ],
            [
              Tooltip,
              {
                text(vote_date, n, dayjsDate) {
                  const voteLabel = n > 1 ? "votes" : "vote";
                  const text2 = (n ? `Sim missed ${n} ${voteLabel}` : "No missed votes") + " on " + dayjsDate.format("ll");
                  return text2;
                }
              }
            ]
          ]
        );
      }
      onMount(initHeatmap);
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          container = $$value;
          $$invalidate(0, container);
        });
      }
      $$self.$$set = ($$props2) => {
        if ("data" in $$props2)
          $$invalidate(1, data2 = $$props2.data);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*data, cal*/
        6) {
          paintCal(cal, data2);
        }
      };
      return [container, data2, cal, div_binding];
    }
    class CalHeatmap_1 extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$2, create_fragment$2, safe_not_equal, { data: 1 });
      }
    }
    const sim = "/xxxx-missed-votes/assets/sim-9d21b501.png";
    const TextColumn_svelte_svelte_type_style_lang = "";
    function create_fragment$1(ctx) {
      let div8;
      return {
        c() {
          div8 = element("div");
          div8.innerHTML = `<div id="intro" class="step svelte-tsqub1"><img id="sim-img" src="${sim}" alt="Kem Sim" class="svelte-tsqub1"/> <p class="svelte-tsqub1">Mayor Ken Sim has been absent for city council votes far more often than his recent predecessors.</p> <p class="svelte-tsqub1">The calendar to the right shows how many votes Sim missed on any given day since he was elected. Hover or tap a day to see how many votes the mayor missed that day.</p></div> <div id="legend" class="step svelte-tsqub1"></div> <div id="mayor-chart" class="step svelte-tsqub1"><iframe src="https://flo.uri.sh/visualisation/20404697/embed" title="Interactive or visual content" class="flourish-embed-iframe" frameborder="0" scrolling="no" style="max-width:200px;height:150px;" sandbox="allow-same-origin allow-forms allow-scripts allow-downloads allow-popups allow-popups-to-escape-sandbox allow-top-navigation-by-user-activation"></iframe></div> <div id="council-chart" class="step svelte-tsqub1"><p class="svelte-tsqub1">The mayor missed more votes than his colleagues...</p> <iframe src="https://flo.uri.sh/visualisation/20404954/embed" title="Interactive or visual content" class="flourish-embed-iframe" frameborder="0" scrolling="no" style="max-width:200px;height:350px;" sandbox="allow-same-origin allow-forms allow-scripts allow-downloads allow-popups allow-popups-to-escape-sandbox allow-top-navigation-by-user-activation"></iframe></div> <div id="summer23" class="step svelte-tsqub1"><p class="svelte-tsqub1">...and in the summer of 2023 he missed seven days of council meetings, totalling 81 votes – 43 of them for attending the three-day Collision tech conference, which Vancouver will host in 2025.</p></div> <div id="meeting-type" class="step svelte-tsqub1"><p class="svelte-tsqub1">The mayor is most likely to skip public hearings, which are often held in the evening.</p> <iframe src="https://flo.uri.sh/visualisation/20405084/embed" title="Interactive or visual content" class="flourish-embed-iframe" frameborder="0" scrolling="no" style="max-width:200px;height:250px;" sandbox="allow-same-origin allow-forms allow-scripts allow-downloads allow-popups allow-popups-to-escape-sandbox allow-top-navigation-by-user-activation"></iframe></div> <div id="metro-meetings" class="step svelte-tsqub1"><p class="svelte-tsqub1">He isn’t just skipping council meetings. He’s only attended a quarter of  41 committee and board meetings at Metro Vancouver, though he sometimes sends an ABC councillor in his place.</p> <iframe src="https://flo.uri.sh/visualisation/20405301/embed" title="Interactive or visual content" class="flourish-embed-iframe" frameborder="0" scrolling="no" style="max-width:200px;height:150px;" sandbox="allow-same-origin allow-forms allow-scripts allow-downloads allow-popups allow-popups-to-escape-sandbox allow-top-navigation-by-user-activation"></iframe></div> <div id="summer24" class="step svelte-tsqub1"><p class="svelte-tsqub1">Sim missed 114 votes in the summer of 2024, many of which were connected to his attendance at two tech conferences: Collision in Toronto and London Tech Week.</p></div>`;
          attr(div8, "id", "right-column");
          attr(div8, "class", "svelte-tsqub1");
        },
        m(target, anchor) {
          insert(target, div8, anchor);
        },
        p: noop$5,
        i: noop$5,
        o: noop$5,
        d(detaching) {
          if (detaching) {
            detach(div8);
          }
        }
      };
    }
    function init() {
    }
    function instance$1($$self) {
      onMount(init);
      return [];
    }
    class TextColumn extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$1, create_fragment$1, safe_not_equal, {});
      }
    }
    const App_svelte_svelte_type_style_lang = "";
    function create_fragment(ctx) {
      let header;
      let t12;
      let main2;
      let div0;
      let textcolumn;
      let t22;
      let calheatmap;
      let t32;
      let footer;
      let current;
      textcolumn = new TextColumn({});
      calheatmap = new CalHeatmap_1({ props: { data: (
        /*data*/
        ctx[0]
      ) } });
      return {
        c() {
          header = element("header");
          header.innerHTML = `<h1 class="svelte-vvs1n9">Where’s the Mayor?</h1>`;
          t12 = space();
          main2 = element("main");
          div0 = element("div");
          create_component(textcolumn.$$.fragment);
          t22 = space();
          create_component(calheatmap.$$.fragment);
          t32 = space();
          footer = element("footer");
          footer.innerHTML = `<p class="note">NOTE: Voting record data as of Nov. 19, 2024, unless otherwise noted.</p> <div class="bottom-row svelte-vvs1n9"><p class="source">Source:  <a href="https://opendata.vancouver.ca/explore/dataset/council-voting-records/information/?disjunctive.meeting_type&amp;disjunctive.vote_number&amp;disjunctive.council_member&amp;disjunctive.vote" target="_blank">City of Vancouver</a></p> <div style="width:100%!;margin-top:4px!important;text-align:right!important;"><a class="flourish-credit" href="https://public.flourish.studio/visualisation/20405301/?utm_source=embed&amp;utm_campaign=visualisation/20405301" target="_top" style="text-decoration:none!important"><img alt="Made with Flourish" src="https://public.flourish.studio/resources/made_with_flourish.svg" style="width:105px!important;height:16px!important;border:none!important;margin:0!important;"/></a></div></div>`;
          attr(header, "class", "svelte-vvs1n9");
          attr(div0, "id", "chart-container");
          attr(div0, "class", "svelte-vvs1n9");
          attr(footer, "class", "svelte-vvs1n9");
        },
        m(target, anchor) {
          insert(target, header, anchor);
          insert(target, t12, anchor);
          insert(target, main2, anchor);
          append$2(main2, div0);
          mount_component(textcolumn, div0, null);
          append$2(div0, t22);
          mount_component(calheatmap, div0, null);
          insert(target, t32, anchor);
          insert(target, footer, anchor);
          current = true;
        },
        p(ctx2, [dirty]) {
          const calheatmap_changes = {};
          if (dirty & /*data*/
          1)
            calheatmap_changes.data = /*data*/
            ctx2[0];
          calheatmap.$set(calheatmap_changes);
        },
        i(local) {
          if (current)
            return;
          transition_in(textcolumn.$$.fragment, local);
          transition_in(calheatmap.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(textcolumn.$$.fragment, local);
          transition_out(calheatmap.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(header);
            detach(t12);
            detach(main2);
            detach(t32);
            detach(footer);
          }
          destroy_component(textcolumn);
          destroy_component(calheatmap);
        }
      };
    }
    const dataUrl = "https://vs-postmedia-data.sfo2.digitaloceanspaces.com/misc/sim-absent-daily.csv";
    function instance($$self, $$props, $$invalidate) {
      let data2;
      async function fetchData(url) {
        const resp = await fetch(url);
        $$invalidate(0, data2 = await resp.text());
        console.log(data2);
        return csvParse(data2);
      }
      async function init2() {
        $$invalidate(0, data2 = await fetchData(dataUrl));
      }
      onMount(init2);
      return [data2];
    }
    class App extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance, create_fragment, safe_not_equal, {});
      }
    }
    new App({
      target: document.getElementById("app")
    });
  }
});
export default require_index_001();
